```mqh

//+------------------------------------------------------------------+
//|                            Settings.mqh                          |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این فایل شامل تمام تنظیمات ورودی اکسپرت Elemento است. تنظیمات به‌صورت گروه‌بندی شده برای کاربرپسندی تعریف شده‌اند:
// - General Settings: تنظیمات عمومی مثل مجیک نامبر پایه، درصد ریسک، و حالت دیباگ.
// - Ichimoku Trend Filter Settings: تنظیمات فیلتر روند ایچیموکو (جدید در نسخه 1.5).
// - Visual Display Settings: تنظیمات نمایشگر چارت (جدید در نسخه 1.5).
// - Range X Settings: تنظیمات اختصاصی برای هر رنج (1 تا 4)، شامل فعال/غیرفعال، زمان، تایم‌فریم، فیلترهای رنج، تنظیمات ATR، و تایم‌فریم فیلتر روند (جدید).
// تمام ورودی‌ها به‌صورت enum یا مقادیر محدود برای جلوگیری از خطای کاربر تعریف شده‌اند.
// این فایل فقط برای تعریف متغیرهای ورودی است و هیچ منطق اجرایی ندارد.
// کامنت‌های ورودی‌ها فارسی هستند برای وضوح.
// این کامنت بخشی از سند کلی نسخه 1.5 است: توصیف تمام ورودی‌ها و enumها برای پیکربندی اکسپرت، با تمرکز بر قابلیت‌های جدید فیلتر و نمایش.

#ifndef SETTINGS_MQH
#define SETTINGS_MQH

// تعریف enum برای حالت‌های مختلف
enum ENUM_PLACEMENT_MODE
{
   PLACEMENT_ATR,    // استفاده از ATR برای ثبت سفارش
   PLACEMENT_PERCENT // استفاده از درصد ارتفاع رنج برای ثبت سفارش
};

enum ENUM_SL_MODE
{
   SL_ATR,    // استفاده از ATR برای استاپ لاس
   SL_PERCENT // استفاده از درصد ارتفاع رنج برای استاپ لاس
};

enum ENUM_TRAILING_MODE
{
   TRAILING_ATR,   // استفاده از ATR برای تریلینگ استاپ
   TRAILING_SIMPLE // استفاده از فاصله ثابت برای تریلینگ استاپ
};

// تنظیمات عمومی
input group "تنظیمات عمومی"
input long InpBaseMagicNumber = 123456; // مجیک نامبر پایه (برای تخصیص منحصربه‌فرد به رنج‌ها)
input double InpRiskPercent = 1.0; // درصد ریسک (0.1 تا 5.0 برای محاسبه حجم معامله)
input bool InpDebugMode = true; // حالت دیباگ (فعال برای لاگ‌گذاری بیشتر)

// تنظیمات فیلتر روند ایچیموکو (جدید)
input group "فیلتر روند ایچیموکو"
input bool Inp_IchimokuFilter_Enabled = true; // فعال کردن فیلتر روند ایچیموکو
input int Inp_Ichimoku_Tenkan = 9; // دوره تنکان-سن
input int Inp_Ichimoku_Kijun = 26; // دوره کیجون-سن
input int Inp_Ichimoku_SenkouB = 52; // دوره سنکو اسپن B
input int Inp_Ichimoku_FlatThreshold_Points = 90; // آستانه تشخیص ابر فلت به پوینت

// تنظیمات نمایشگر چارت (جدید)
input group "تنظیمات نمایشگر چارت"
input bool Inp_Visual_ShowTrendStatus = true; // فعال کردن نمایش وضعیت روند
input int Inp_Visual_FontSize = 12; // اندازه فونت نمایشگر
input color Inp_Visual_FontColor_Buy = clrGreen; // رنگ متن برای روند BUY
input color Inp_Visual_FontColor_Sell = clrRed; // رنگ متن برای روند SELL
input color Inp_Visual_FontColor_Neutral = clrGray; // رنگ متن برای روند NEUTRAL
input int Inp_Visual_X_Offset = 10; // فاصله افقی از لبه چارت (پیکسل)
input int Inp_Visual_Y_Offset = 10; // فاصله عمودی از لبه چارت (پیکسل)

// تنظیمات رنج ۱
input group "تنظیمات رنج 1"
input bool InpRange1_Enabled = false; // فعال کردن رنج 1
input ENUM_TIMEFRAMES InpRange1_Execution_Timeframe = PERIOD_M5; // تایم‌فریم اجرا رنج 1
input ENUM_TIMEFRAMES InpRange1_TrendFilter_Timeframe = PERIOD_H1; // تایم‌فریم فیلتر روند رنج 1 (جدید)
input int InpRange1_Start_Hour = 22; // ساعت شروع رنج 1 (0-23)
input int InpRange1_Start_Minute = 0; // دقیقه شروع رنج 1 (0-59)
input int InpRange1_End_Hour = 9; // ساعت پایان رنج 1 (0-23)
input int InpRange1_End_Minute = 30; // دقیقه پایان رنج 1 (0-59)
input int InpRange1_MinRangePoints = 200; // حداقل ارتفاع رنج 1 به پوینت
input int InpRange1_MaxRangePoints = 1500; // حداکثر ارتفاع رنج 1 به پوینت
input ENUM_PLACEMENT_MODE InpRange1_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 1
input int InpRange1_ATR_Period = 122; // دوره ATR برای ثبت سفارش رنج 1
input double InpRange1_ATR_Multiplier = 2.3; // ضریب ATR برای ثبت سفارش رنج 1
input ENUM_SL_MODE InpRange1_SL_Mode = SL_ATR; // حالت استاپ لاس رنج 1
input int InpRange1_SL_ATR_Period = 62; // دوره ATR برای استاپ لاس رنج 1
input double InpRange1_SL_ATR_Multiplier = 1.3; // ضریب ATR برای استاپ لاس رنج 1
input ENUM_TRAILING_MODE InpRange1_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 1
input int InpRange1_Trailing_ATR_Period = 43; // دوره ATR برای تریلینگ رنج 1
input double InpRange1_Trailing_ATR_Multiplier = 1.4; // ضریب ATR برای تریلینگ رنج 1
input double InpRange1_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 1
input double InpRange1_PartialClosePercent = 60.0; // درصد بستن پله‌ای رنج 1
input int InpRange1_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج 1 (0-24)
input color InpRange1_Color = clrBlue; // رنگ مستطیل رنج 1

// تنظیمات رنج ۲
input group "تنظیمات رنج 2"
input bool InpRange2_Enabled = true; // فعال کردن رنج 2
input ENUM_TIMEFRAMES InpRange2_Execution_Timeframe = PERIOD_M15; // تایم‌فریم اجرا رنج 2
input ENUM_TIMEFRAMES InpRange2_TrendFilter_Timeframe = PERIOD_M15; // تایم‌فریم فیلتر روند رنج 2 (جدید)
input int InpRange2_Start_Hour = 5; // ساعت شروع رنج 2 (0-23)
input int InpRange2_Start_Minute = 0; // دقیقه شروع رنج 2 (0-59)
input int InpRange2_End_Hour = 13; // ساعت پایان رنج 2 (0-23)
input int InpRange2_End_Minute = 0; // دقیقه پایان رنج 2 (0-59)
input int InpRange2_MinRangePoints = 200; // حداقل ارتفاع رنج 2 به پوینت
input int InpRange2_MaxRangePoints = 3500; // حداکثر ارتفاع رنج 2 به پوینت
input ENUM_PLACEMENT_MODE InpRange2_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 2
input int InpRange2_ATR_Period = 14; // دوره ATR برای ثبت سفارش رنج 2
input double InpRange2_ATR_Multiplier = 1.2; // ضریب ATR برای ثبت سفارش رنج 2
input ENUM_SL_MODE InpRange2_SL_Mode = SL_ATR; // حالت استاپ لاس رنج 2
input int InpRange2_SL_ATR_Period = 14; // دوره ATR برای استاپ لاس رنج 2
input double InpRange2_SL_ATR_Multiplier = 1.5; // ضریب ATR برای استاپ لاس رنج 2
input ENUM_TRAILING_MODE InpRange2_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 2
input int InpRange2_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج 2
input double InpRange2_Trailing_ATR_Multiplier = 1.0; // ضریب ATR برای تریلینگ رنج 2
input double InpRange2_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 2
input double InpRange2_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج 2
input int InpRange2_Cleanup_Hours = 4; // ساعت‌های پاکسازی رنج 2 (0-24)
input color InpRange2_Color = clrRed; // رنگ مستطیل رنج 2

// تنظیمات رنج ۳
input group "تنظیمات رنج 3"
input bool InpRange3_Enabled = false; // فعال کردن رنج 3
input ENUM_TIMEFRAMES InpRange3_Execution_Timeframe = PERIOD_M5; // تایم‌فریم اجرا رنج 3
input ENUM_TIMEFRAMES InpRange3_TrendFilter_Timeframe = PERIOD_M30; // تایم‌فریم فیلتر روند رنج 3 (جدید)
input int InpRange3_Start_Hour = 15; // ساعت شروع رنج 3 (0-23)
input int InpRange3_Start_Minute = 0; // دقیقه شروع رنج 3 (0-59)
input int InpRange3_End_Hour = 18; // ساعت پایان رنج 3 (0-23)
input int InpRange3_End_Minute = 0; // دقیقه پایان رنج 3 (0-59)
input int InpRange3_MinRangePoints = 100; // حداقل ارتفاع رنج 3 به پوینت
input int InpRange3_MaxRangePoints = 2110; // حداکثر ارتفاع رنج 3 به پوینت
input ENUM_PLACEMENT_MODE InpRange3_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 3
input int InpRange3_ATR_Period = 14; // دوره ATR برای ثبت سفارش رنج 3
input double InpRange3_ATR_Multiplier = 1.2; // ضریب ATR برای ثبت سفارش رنج 3
input ENUM_SL_MODE InpRange3_SL_Mode = SL_ATR; // حالت استاپ لاس رنج 3
input int InpRange3_SL_ATR_Period = 14; // دوره ATR برای استاپ لاس رنج 3
input double InpRange3_SL_ATR_Multiplier = 1.5; // ضریب ATR برای استاپ لاس رنج 3
input ENUM_TRAILING_MODE InpRange3_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 3
input int InpRange3_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج 3
input double InpRange3_Trailing_ATR_Multiplier = 1.0; // ضریب ATR برای تریلینگ رنج 3
input double InpRange3_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 3
input double InpRange3_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج 3
input int InpRange3_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج 3 (0-24)
input color InpRange3_Color = clrGreen; // رنگ مستطیل رنج 3

// تنظیمات رنج ۴
input group "غیر فعال تنظیمات رنج 4"
input bool InpRange4_Enabled = false; // فعال کردن رنج 4
input ENUM_TIMEFRAMES InpRange4_Execution_Timeframe = PERIOD_CURRENT; // تایم‌فریم اجرا رنج 4
input ENUM_TIMEFRAMES InpRange4_TrendFilter_Timeframe = PERIOD_CURRENT; // تایم‌فریم فیلتر روند رنج 4 (جدید)
input int InpRange4_Start_Hour = 0; // ساعت شروع رنج 4 (0-23)
input int InpRange4_Start_Minute = 0; // دقیقه شروع رنج 4 (0-59)
input int InpRange4_End_Hour = 0; // ساعت پایان رنج 4 (0-23)
input int InpRange4_End_Minute = 0; // دقیقه پایان رنج 4 (0-59)
input int InpRange4_MinRangePoints = 50; // حداقل ارتفاع رنج 4 به پوینت
input int InpRange4_MaxRangePoints = 500; // حداکثر ارتفاع رنج 4 به پوینت
input ENUM_PLACEMENT_MODE InpRange4_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 4
input int InpRange4_ATR_Period = 14; // دوره ATR برای ثبت سفارش رنج 4
input double InpRange4_ATR_Multiplier = 1.2; // ضریب ATR برای ثبت سفارش رنج 4
input ENUM_SL_MODE InpRange4_SL_Mode = SL_ATR; // حالت استاپ لاس رنج 4
input int InpRange4_SL_ATR_Period = 14; // دوره ATR برای استاپ لاس رنج 4
input double InpRange4_SL_ATR_Multiplier = 1.5; // ضریب ATR برای استاپ لاس رنج 4
input ENUM_TRAILING_MODE InpRange4_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 4
input int InpRange4_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج 4
input double InpRange4_Trailing_ATR_Multiplier = 1.0; // ضریب ATR برای تریلینگ رنج 4
input double InpRange4_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 4
input double InpRange4_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج 4
input int InpRange4_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج 4 (0-24)
input color InpRange4_Color = clrYellow; // رنگ مستطیل رنج 4

#endif

//end file1
```

```mq5

//+------------------------------------------------------------------+
//|                            Elemento.mq5                          |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این فایل اصلی اکسپرت Elemento است که نقش "رهبر ارکستر" را ایفا می‌کند. این اکسپرت بر اساس استراتژی شکست رنج‌های زمانی (Time-Range Breakout) کار می‌کند و می‌تواند تا ۴ رنج زمانی مستقل را مدیریت کند. هر رنج یک بازه زمانی مشخص دارد (مانند ۲۳:۰۰ تا ۴:۰۰) که در آن سقف و کف قیمت را شناسایی می‌کند، سفارش‌های پندینگ قرار می‌دهد، معاملات را مدیریت می‌کند (با خروج پله‌ای و تریلینگ استاپ)، و در پایان زمان یا تعطیلات پاکسازی می‌کند.
// در نسخه 1.5، فیلتر روند ایچیموکو اضافه شده تا فقط معاملات هم‌جهت با روند ثبت شوند، و نمایشگر وضعیت روند روی چارت اضافه شده.
// وظایف اصلی:
// 1. مقداردهی اولیه ۴ رنج با کلاس CRange (فقط رنج‌های فعال با InpRangeX_Enabled = true).
// 2. در OnTick، تشخیص کندل جدید در تایم‌فریم هر رنج و فراخوانی UpdateOnNewBar، و به‌روزرسانی نمایش وضعیت روند.
// 3. در OnTradeTransaction، مدیریت OCO (لغو سفارش مخالف وقتی معامله باز می‌شود).
// 4. مدیریت بهینه منابع: هندل‌های ATR shared، کش SymbolInfo، آزادسازی در OnDeinit.
// 5. چک tester mode برای جلوگیری از مشکل تعطیلات در بک‌تست.
// الگوریتم کلی:
// - OnInit: کش اطلاعات سیمبل، ولیدیشن ورودی‌ها، ایجاد هندل ATR، مقداردهی رنج‌های فعال، مقداردهی فیلتر روند و مدیر نمایش.
// - OnTick: برای هر رنج فعال، چک کندل جدید با iTime و آپدیت اگر جدید باشد، و به‌روزرسانی نمایش روند.
// - OnTradeTransaction: اگر معامله جدید (DEAL_ENTRY_IN)، سفارش مخالف لغو شود.
// - OnDeinit: آزادسازی هندل‌ها و پاکسازی گرافیک‌ها، دفع فیلتر و مدیر نمایش.
// بهینه‌سازی‌ها: لاگ conditional با InpDebugMode، کش ATR در CRange، normalize دقیق حجم/قیمت.
// اصلاحات: اضافه enabled برای رنج‌ها، چک tester برای IsMarketClosed، لاگ بدون تکرار، ادغام فیلتر روند و نمایش.
// این کامنت بخشی از سند کلی نسخه 1.5 است: با کامنت‌های دیگر فایل‌ها، معماری کامل (ساختار فایل‌ها، کلاس‌ها، توابع مدیریت معاملات، ریسک، زمان، فیلتر روند، نمایش) را توصیف می‌کند. پروژه ماژولار است برای نگهداری آسان.

#property copyright "Copyright 2025, Hipoalgorithm Team"
#property link      "https://hipoalgorithm.com"
#property version   "1.50"
#property strict

// شامل کردن کتابخانه‌ها
#include "Settings.mqh"
#include "CRange.mqh"
#include "TrendFilter.mqh"
#include "VisualManager.mqh"
#include "TestCustomAlgo.mqh"
// آرایه برای ذخیره ۴ رنج
CRange g_ranges[4];

// آرایه برای ذخیره زمان آخرین کندل هر تایم‌فریم
datetime g_lastBarTime[4];

// آرایه برای هندل‌های ATR shared (برای جلوگیری از تکرار)
int g_atrHandles[4];

// متغیرهای کش‌شده برای بهینه‌سازی
double g_tickValue;
double g_tickSize;
double g_volumeStep;
double g_volumeMin;
double g_volumeMax;

// فلگ برای تشخیص حالت tester (برای skip چک تعطیلات در بک‌تست)
bool g_isTester = false;

// فیلتر روند جهانی (برای نمایش کلی)
CTrendFilter g_trendFilter;

// مدیر نمایش جهانی
CVisualManager g_visualManager;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   // تشخیص حالت tester برای مدیریت تعطیلات
   g_isTester = MQLInfoInteger(MQL_TESTER);

   // لاگ‌گذاری شروع مقداردهی (اگر دیباگ فعال باشد)
   if(InpDebugMode) Print("شروع مقداردهی اکسپرت Elemento...");

   // کش اطلاعات سیمبل برای بهینه‌سازی
   g_tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   g_tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   g_volumeStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   g_volumeMin = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   g_volumeMax = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

   if(g_tickValue == 0 || g_tickSize == 0 || g_volumeStep == 0)
   {
      Print("خطا در گرفتن اطلاعات سیمبل.");
      return(INIT_FAILED);
   }

   // ولیدیشن ورودی‌های عمومی
   if(InpRiskPercent <= 0 || InpRiskPercent > 5.0)
   {
      Print("خطا: RiskPercent باید بین 0.1 تا 5.0 باشد.");
      return(INIT_PARAMETERS_INCORRECT);
   }

   // مقداردهی ۴ رنج با تنظیمات مربوطه (فقط اگر فعال باشند)
   for(int i = 0; i < 4; i++)
   {
      // چک فعال بودن رنج
      bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;
      if(!enabled)
      {
         if(InpDebugMode) Print("رنج ", i + 1, " غیرفعال است. رد می‌شود.");
         continue;
      }

      // تخصیص مجیک نامبر منحصربه‌فرد برای هر رنج
      long magic = InpBaseMagicNumber + i;
      
      // ولیدیشن ساعات (0-23 برای ساعت، 0-59 برای دقیقه)
      int startHour = i == 0 ? InpRange1_Start_Hour : i == 1 ? InpRange2_Start_Hour : i == 2 ? InpRange3_Start_Hour : InpRange4_Start_Hour;
      int startMinute = i == 0 ? InpRange1_Start_Minute : i == 1 ? InpRange2_Start_Minute : i == 2 ? InpRange3_Start_Minute : InpRange4_Start_Minute;
      int endHour = i == 0 ? InpRange1_End_Hour : i == 1 ? InpRange2_End_Hour : i == 2 ? InpRange3_End_Hour : InpRange4_End_Hour;
      int endMinute = i == 0 ? InpRange1_End_Minute : i == 1 ? InpRange2_End_Minute : i == 2 ? InpRange3_End_Minute : InpRange4_End_Minute;
      
      if(startHour < 0 || startHour > 23 || startMinute < 0 || startMinute > 59 ||
         endHour < 0 || endHour > 23 || endMinute < 0 || endMinute > 59)
      {
         Print("خطا: ساعات یا دقیقه‌های رنج ", i + 1, " نامعتبر است.");
         return(INIT_PARAMETERS_INCORRECT);
      }

      // ایجاد هندل ATR shared
      ENUM_TIMEFRAMES timeframe = i == 0 ? InpRange1_Execution_Timeframe : i == 1 ? InpRange2_Execution_Timeframe : i == 2 ? InpRange3_Execution_Timeframe : InpRange4_Execution_Timeframe;
      int atrPeriod = i == 0 ? InpRange1_ATR_Period : i == 1 ? InpRange2_ATR_Period : i == 2 ? InpRange3_ATR_Period : InpRange4_ATR_Period;
      g_atrHandles[i] = iATR(_Symbol, timeframe, atrPeriod);
      if(g_atrHandles[i] == INVALID_HANDLE)
      {
         Print("خطا در ایجاد هندل ATR برای رنج ", i + 1);
         return(INIT_FAILED);
      }

      // بررسی عدم تکرار مجیک نامبر (با +i، منحصربه‌فرد است)
      if(!g_ranges[i].Init(
         i + 1, // شماره رنج (1 تا 4)
         magic,
         timeframe,
         startHour,
         startMinute,
         endHour,
         endMinute,
         i == 0 ? InpRange1_MinRangePoints : i == 1 ? InpRange2_MinRangePoints : i == 2 ? InpRange3_MinRangePoints : InpRange4_MinRangePoints,
         i == 0 ? InpRange1_MaxRangePoints : i == 1 ? InpRange2_MaxRangePoints : i == 2 ? InpRange3_MaxRangePoints : InpRange4_MaxRangePoints,
         i == 0 ? InpRange1_Placement_Mode : i == 1 ? InpRange2_Placement_Mode : i == 2 ? InpRange3_Placement_Mode : InpRange4_Placement_Mode,
         atrPeriod,
         i == 0 ? InpRange1_ATR_Multiplier : i == 1 ? InpRange2_ATR_Multiplier : i == 2 ? InpRange3_ATR_Multiplier : InpRange4_ATR_Multiplier,
         i == 0 ? InpRange1_SL_Mode : i == 1 ? InpRange2_SL_Mode : i == 2 ? InpRange3_SL_Mode : InpRange4_SL_Mode,
         i == 0 ? InpRange1_SL_ATR_Period : i == 1 ? InpRange2_SL_ATR_Period : i == 2 ? InpRange3_SL_ATR_Period : InpRange4_SL_ATR_Period,
         i == 0 ? InpRange1_SL_ATR_Multiplier : i == 1 ? InpRange2_SL_ATR_Multiplier : i == 2 ? InpRange3_SL_ATR_Multiplier : InpRange4_SL_ATR_Multiplier,
         i == 0 ? InpRange1_Trailing_Mode : i == 1 ? InpRange2_Trailing_Mode : i == 2 ? InpRange3_Trailing_Mode : InpRange4_Trailing_Mode,
         i == 0 ? InpRange1_Trailing_ATR_Period : i == 1 ? InpRange2_Trailing_ATR_Period : i == 2 ? InpRange3_Trailing_ATR_Period : InpRange4_Trailing_ATR_Period,
         i == 0 ? InpRange1_Trailing_ATR_Multiplier : i == 1 ? InpRange2_Trailing_ATR_Multiplier : i == 2 ? InpRange3_Trailing_ATR_Multiplier : InpRange4_Trailing_ATR_Multiplier,
         i == 0 ? InpRange1_RR_Ratio : i == 1 ? InpRange2_RR_Ratio : i == 2 ? InpRange3_RR_Ratio : InpRange4_RR_Ratio,
         i == 0 ? InpRange1_PartialClosePercent : i == 1 ? InpRange2_PartialClosePercent : i == 2 ? InpRange3_PartialClosePercent : InpRange4_PartialClosePercent,
         i == 0 ? InpRange1_Cleanup_Hours : i == 1 ? InpRange2_Cleanup_Hours : i == 2 ? InpRange3_Cleanup_Hours : InpRange4_Cleanup_Hours,
         i == 0 ? InpRange1_Color : i == 1 ? InpRange2_Color : i == 2 ? InpRange3_Color : InpRange4_Color,
         i == 0 ? InpRange1_TrendFilter_Timeframe : i == 1 ? InpRange2_TrendFilter_Timeframe : i == 2 ? InpRange3_TrendFilter_Timeframe : InpRange4_TrendFilter_Timeframe,
         g_atrHandles[i] // هندل ATR shared
      ))
      {
         Print("خطا در مقداردهی رنج ", i + 1, ": ", GetLastError());
         return(INIT_PARAMETERS_INCORRECT);
      }
   }

   // مقداردهی فیلتر روند و مدیر نمایش
   if(!g_trendFilter.Init())
   {
      Print("خطا در مقداردهی فیلتر روند.");
      return(INIT_FAILED);
   }
   if(!g_visualManager.Init())
   {
      Print("خطا در مقداردهی مدیر نمایش.");
      return(INIT_FAILED);
   }

   // مقداردهی اولیه زمان آخرین کندل‌ها
   for(int i = 0; i < 4; i++)
   {
      g_lastBarTime[i] = 0;
   }

   Print("مقداردهی اکسپرت Elemento با موفقیت انجام شد.");
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   // لاگ‌گذاری دفع مقداردهی (اگر دیباگ فعال باشد)
   if(InpDebugMode) Print("دفع مقداردهی اکسپرت Elemento. دلیل: ", reason);

   // آزادسازی منابع هر رنج
   for(int i = 0; i < 4; i++)
   {
      g_ranges[i].Deinit();
   }

   // آزادسازی هندل‌های ATR
   for(int i = 0; i < 4; i++)
   {
      if(g_atrHandles[i] != INVALID_HANDLE)
      {
         IndicatorRelease(g_atrHandles[i]);
      }
   }

   // دفع فیلتر روند و مدیر نمایش
   g_trendFilter.Deinit();
   g_visualManager.Deinit();

   // پاکسازی اشیاء گرافیکی
   ObjectsDeleteAll(0, "Range_");
   Print("تمامی اشیاء گرافیکی پاکسازی شدند.");
}

//+------------------------------------------------------------------+
//| Expert tick function                                              |
//+------------------------------------------------------------------+
void OnTick()
{
   // بررسی کندل جدید برای هر رنج
   for(int i = 0; i < 4; i++)
   {
      // چک فعال بودن رنج
      bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;
      if(!enabled) continue;

      ENUM_TIMEFRAMES timeframe = g_ranges[i].GetTimeframe();
      datetime currentBarTime = iTime(_Symbol, timeframe, 0);
      
      // اگر کندل جدید باشد
      if(currentBarTime > g_lastBarTime[i])
      {
         if(InpDebugMode) Print("کندل جدید برای رنج ", i + 1, " در تایم‌فریم ", EnumToString(timeframe));
         g_ranges[i].UpdateOnNewBar();
         g_lastBarTime[i] = currentBarTime;
      }
   }

   // به‌روزرسانی نمایش وضعیت روند (برای یکی از تایم‌فریم‌ها، مثلاً رنج اول)
   if(InpRange1_Enabled)
   {
      ENUM_TREND_DIRECTION globalTrend = g_trendFilter.GetTrendDirection(g_ranges[0].GetTrendFilterTimeframe());
      string trendText;
      color trendColor;
      switch(globalTrend)
      {
         case TREND_BUY: trendText = "TREND BUY"; trendColor = Inp_Visual_FontColor_Buy; break;
         case TREND_SELL: trendText = "TREND SELL"; trendColor = Inp_Visual_FontColor_Sell; break;
         default: trendText = "TREND NEUTRAL"; trendColor = Inp_Visual_FontColor_Neutral; break;
      }
      g_visualManager.UpdateTrendStatus(trendText, trendColor);
   }
}

//+------------------------------------------------------------------+
//| Trade transaction function                                       |
//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction& trans, const MqlTradeRequest& request, const MqlTradeResult& result)
{
   if(trans.type == TRADE_TRANSACTION_DEAL_ADD && trans.deal== DEAL_ENTRY_IN)
   {
      if(HistoryDealSelect(trans.deal))
      {
         long magic = HistoryDealGetInteger(trans.deal, DEAL_MAGIC);
         for(int i = 0; i < 4; i++)
         {
            bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;
            if(enabled && magic == g_ranges[i].GetMagicNumber())
            {
               Print("معامله جدید برای رنج ", i + 1, " باز شد. لغو سفارش مخالف...");
               g_ranges[i].CancelOppositeOrder();
               break;
            }
         }
      }
   }
}

//end file 2

```

```mqh

//+------------------------------------------------------------------+
//|                            CRange.mqh                            |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این فایل کلاس CRange را تعریف می‌کند که قلب تپنده اکسپرت Elemento است. هر نمونه از این کلاس یک رنج زمانی مستقل را مدیریت می‌کند.
// در نسخه 1.5، فیلتر روند اضافه شده تا جهت سفارش‌ها بر اساس روند قفل‌شده (lockedTrendDirection) تعیین شود.
// وظایف اصلی:
// 1. شناسایی و اعتبارسنجی رنج (سقف و کف، کیفیت با Min/Max Points)، و استعلام یک‌بار فیلتر روند.
// 2. ثبت سفارش‌های پندینگ (Buy Stop و Sell Stop با offset بر اساس ATR یا درصد، فقط هم‌جهت با روند).
// 3. مدیریت معاملات باز (خروج پله‌ای با RR_Ratio، ریسک‌فری، تریلینگ استاپ).
// 4. پاکسازی در پایان زمان (Cleanup_Hours) یا تعطیلات.
// الگوریتم کلی:
// - حالت‌ها: WAITING (منتظر پایان رنج)، IDENTIFIED (رنج معتبر، مستطیل رسم شود)، ORDERS_PLACED (سفارش‌ها ثبت شوند)، TRADE_ACTIVE (مدیریت معامله)، EXPIRED (پاکسازی).
// - UpdateOnNewBar: بر اساس حالت، Identify/Place/Manage/Cleanup فراخوانی می‌شود.
// - CancelOppositeOrder: لغو سفارش مخالف با چک slippage.
// - کش ATR برای بهینه‌سازی CopyBuffer.
// - چک تعطیلات با IsMarketClosed (skip در tester).
// این کلاس از کتابخانه‌های TradeManager (برای معاملات)، RiskManager (برای حجم)، TimeHelper (برای زمان)، TrendFilter (برای فیلتر روند) استفاده می‌کند.
// بهینه‌سازی‌ها: هندل ATR shared، normalize دقیق، لاگ conditional.
// اصلاحات: کش ATR، چک sl == 0 در تریلینگ، checker tester، ادغام فیلتر روند با قفل جهت.
// این کامنت بخشی از سند کلی نسخه 1.5 است: توصیف کلاس اصلی، حالت‌ها، متدها، و ادغام با دیگر کتابخانه‌ها برای مدیریت کامل رنج.

#ifndef CRANGE_MQH
#define CRANGE_MQH

#include "TradeManager.mqh"
#include "RiskManager.mqh"
#include "TimeHelper.mqh"
#include "TrendFilter.mqh"
#include <Trade\Trade.mqh>

// تعریف حالت‌های رنج
enum ENUM_RANGE_STATE
{
   RANGE_WAITING,      // منتظر تشکیل رنج
   RANGE_IDENTIFIED,   // رنج شناسایی و معتبر است
   ORDERS_PLACED,      // سفارش‌های پندینگ ثبت شده‌اند
   TRADE_ACTIVE,       // معامله باز است
   RANGE_EXPIRED       // رنج منقضی شده
};

class CRange
{
private:
   // متغیرهای تنظیمات
   int m_rangeIndex;                    // شماره رنج (1 تا 4)
   long m_magicNumber;                  // مجیک نامبر اختصاصی
   ENUM_TIMEFRAMES m_timeframe;         // تایم‌فریم اجرا
   int m_startHour, m_startMinute;      // ساعت و دقیقه شروع رنج
   int m_endHour, m_endMinute;          // ساعت و دقیقه پایان رنج
   int m_minRangePoints, m_maxRangePoints; // حداقل و حداکثر ارتفاع رنج
   ENUM_PLACEMENT_MODE m_placementMode; // حالت ثبت سفارش
   int m_atrPeriod;                     // دوره ATR برای سفارش
   double m_atrMultiplier;              // ضریب ATR برای سفارش
   ENUM_SL_MODE m_slMode;               // حالت استاپ لاس
   int m_slAtrPeriod;                   // دوره ATR برای استاپ لاس
   double m_slAtrMultiplier;            // ضریب ATR برای استاپ لاس
   ENUM_TRAILING_MODE m_trailingMode;   // حالت تریلینگ استاپ
   int m_trailingAtrPeriod;             // دوره ATR برای تریلینگ
   double m_trailingAtrMultiplier;      // ضریب ATR برای تریلینگ
   double m_rrRatio;                    // نسبت سود به ضرر برای خروج پله‌ای
   double m_partialClosePercent;        // درصد بستن معامله
   int m_cleanupHours;                  // ساعت‌های پاکسازی
   color m_color;                       // رنگ مستطیل گرافیکی

   // متغیرهای داخلی
   double m_rangeHigh, m_rangeLow;      // سقف و کف رنج
   datetime m_cleanupTime;              // زمان انقضای رنج
   string m_rangeObjectName;            // نام مستطیل گرافیکی
   ENUM_RANGE_STATE m_currentState;     // حالت فعلی رنج
   int m_atrHandle;                     // هندل اندیکاتور ATR (shared از اصلی)
   bool m_trailingActivated;            // فلگ فعال‌سازی تریلینگ
   ulong m_activeTicket;                // تیکت معامله فعال
   double m_cachedATR;                  // کش ATR برای بهینه‌سازی
   ENUM_TREND_DIRECTION m_lockedTrendDirection;  // جهت قفل‌شده روند برای این رنج
   ENUM_TIMEFRAMES m_trendFilterTimeframe;  // تایم‌فریم فیلتر روند (از ورودی)

public:
   // سازنده پیش‌فرض
   CRange() : m_rangeIndex(0), m_magicNumber(0), m_timeframe(PERIOD_H1),
              m_startHour(0), m_startMinute(0), m_endHour(0), m_endMinute(0),
              m_minRangePoints(0), m_maxRangePoints(0), m_placementMode(PLACEMENT_ATR),
              m_atrPeriod(14), m_atrMultiplier(1.2), m_slMode(SL_ATR),
              m_slAtrPeriod(14), m_slAtrMultiplier(1.5), m_trailingMode(TRAILING_ATR),
              m_trailingAtrPeriod(14), m_trailingAtrMultiplier(1.0),
              m_rrRatio(1.5), m_partialClosePercent(50.0), m_cleanupHours(5),
              m_color(clrBlue), m_rangeHigh(0), m_rangeLow(0), m_cleanupTime(0),
              m_currentState(RANGE_WAITING), m_atrHandle(INVALID_HANDLE),
              m_trailingActivated(false), m_activeTicket(0), m_cachedATR(0),
              m_lockedTrendDirection(TREND_NEUTRAL), m_trendFilterTimeframe(PERIOD_H4) {}

   // مقداردهی اولیه (با پارامتر اضافی برای هندل ATR shared و تایم‌فریم فیلتر روند)
   bool Init(
      int rangeIndex,
      long magicNumber,
      ENUM_TIMEFRAMES timeframe,
      int startHour,
      int startMinute,
      int endHour,
      int endMinute,
      int minRangePoints,
      int maxRangePoints,
      ENUM_PLACEMENT_MODE placementMode,
      int atrPeriod,
      double atrMultiplier,
      ENUM_SL_MODE slMode,
      int slAtrPeriod,
      double slAtrMultiplier,
      ENUM_TRAILING_MODE trailingMode,
      int trailingAtrPeriod,
      double trailingAtrMultiplier,
      double rrRatio,
      double partialClosePercent,
      int cleanupHours,
      color rangeColor,
      ENUM_TIMEFRAMES trendFilterTimeframe,
      int atrHandle)
   {
      if(InpDebugMode) Print("مقداردهی رنج ", rangeIndex, "...");
      
      // ذخیره تنظیمات
      m_rangeIndex = rangeIndex;
      m_magicNumber = magicNumber;
      m_timeframe = timeframe;
      m_startHour = startHour;
      m_startMinute = startMinute;
      m_endHour = endHour;
      m_endMinute = endMinute;
      m_minRangePoints = minRangePoints;
      m_maxRangePoints = maxRangePoints;
      m_placementMode = placementMode;
      m_atrPeriod = atrPeriod;
      m_atrMultiplier = atrMultiplier;
      m_slMode = slMode;
      m_slAtrPeriod = slAtrPeriod;
      m_slAtrMultiplier = slAtrMultiplier;
      m_trailingMode = trailingMode;
      m_trailingAtrPeriod = trailingAtrPeriod;
      m_trailingAtrMultiplier = trailingAtrMultiplier;
      m_rrRatio = rrRatio;
      m_partialClosePercent = partialClosePercent;
      m_cleanupHours = cleanupHours;
      m_color = rangeColor;
      m_trendFilterTimeframe = trendFilterTimeframe;
      m_lockedTrendDirection = TREND_NEUTRAL;
      m_atrHandle = atrHandle;

      if(m_atrHandle == INVALID_HANDLE)
      {
         Print("خطا در هندل ATR برای رنج ", rangeIndex);
         return false;
      }

      // تنظیم نام مستطیل گرافیکی
      m_rangeObjectName = "Range_" + IntegerToString(rangeIndex) + "_" + TimeToString(TimeCurrent(), TIME_DATE|TIME_MINUTES);
      if(InpDebugMode) Print("رنج ", rangeIndex, " با موفقیت مقداردهی شد.");
      return true;
   }

   // دفع مقداردهی (آزادسازی در اصلی انجام می‌شود)
   void Deinit()
   {
      // حذف مستطیل گرافیکی
      ObjectDelete(0, m_rangeObjectName);
      if(InpDebugMode) Print("مستطیل رنج ", m_rangeIndex, " حذف شد.");
   }

   // متد اصلی برای به‌روزرسانی در هر کندل جدید
   void UpdateOnNewBar()
   {
      if(InpDebugMode) Print("به‌روزرسانی رنج ", m_rangeIndex, " در حالت ", EnumToString(m_currentState));

      // بررسی تعطیلات بازار دقیق‌تر (skip در tester)
      if(!g_isTester && IsMarketClosed())
      {
         Cleanup();
         return;
      }

      // بررسی بر اساس حالت فعلی
      switch(m_currentState)
      {
         case RANGE_WAITING:
            IdentifyAndValidateRange();
            break;
         case RANGE_IDENTIFIED:
            PlacePendingOrders();
            break;
         case ORDERS_PLACED:
         case TRADE_ACTIVE:
            ManageActiveTrade();
            break;
         case RANGE_EXPIRED:
            Cleanup();
            break;
      }

      // بررسی زمان پاکسازی
      if(TimeCurrent() >= m_cleanupTime && m_cleanupTime != 0)
      {
         Cleanup();
      }
   }

   // لغو سفارش پندینگ مخالف (OCO) با چک slippage
   void CancelOppositeOrder()
   {
      CTrade trade;
      for(int i = OrdersTotal() - 1; i >= 0; i--)
      {
         ulong ticket = OrderGetTicket(i);
         if(OrderSelect(ticket) && OrderGetInteger(ORDER_MAGIC) == m_magicNumber)
         {
            if(trade.OrderDelete(ticket))
            {
               if(InpDebugMode) Print("سفارش پندینگ با تیکت ", ticket, " برای رنج ", m_rangeIndex, " لغو شد.");
            }
            else
            {
               Print("خطا در لغو سفارش پندینگ با تیکت ", ticket, ": ", GetLastError());
            }
         }
      }

      // چک اضافی برای جلوگیری از دو پوزیشن (در صورت slippage)
      int openPositions = 0;
      for(int j = PositionsTotal() - 1; j >= 0; j--)
      {
         ulong posTicket = PositionGetTicket(j);
         if(PositionGetInteger(POSITION_MAGIC) == m_magicNumber)
         {
            openPositions++;
            if(openPositions > 1)
            {
               Print("هشدار: بیش از یک پوزیشن باز برای رنج ", m_rangeIndex, ". بستن اضافی.");
               CTradeManager::ClosePosition(posTicket);
            }
         }
      }
   }

   // گرفتن مجیک نامبر
   long GetMagicNumber() { return m_magicNumber; }

   // گرفتن تایم‌فریم
   ENUM_TIMEFRAMES GetTimeframe() { return m_timeframe; }

   // گرفتن تایم‌فریم فیلتر روند
   ENUM_TIMEFRAMES GetTrendFilterTimeframe() { return m_trendFilterTimeframe; }

private:
   // شناسایی و اعتبارسنجی رنج
   void IdentifyAndValidateRange()
   {
      if(InpDebugMode) Print("شناسایی رنج ", m_rangeIndex, "...");

      // محاسبه زمان شروع و پایان رنج
      datetime startTime, endTime;
      if(!CTimeHelper::CalculateRangeTimes(m_startHour, m_startMinute, m_endHour, m_endMinute, startTime, endTime))
      {
         Print("خطا در محاسبه زمان رنج ", m_rangeIndex);
         m_currentState = RANGE_EXPIRED;
         return;
      }

      // بررسی پایان بازه رنج
      if(TimeCurrent() < endTime)
      {
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " هنوز تمام نشده است.");
         return;
      }

      // گرفتن سقف و کف رنج با چک بارها
      int startShift = iBarShift(_Symbol, m_timeframe, startTime);
      int endShift = iBarShift(_Symbol, m_timeframe, endTime);
      int bars = startShift - endShift + 1;
      if(bars <= 0)
      {
         Print("خطا: تعداد بارها نامعتبر برای رنج ", m_rangeIndex);
         m_currentState = RANGE_EXPIRED;
         return;
      }

      int highestIdx = iHighest(_Symbol, m_timeframe, MODE_HIGH, bars, endShift);
      int lowestIdx = iLowest(_Symbol, m_timeframe, MODE_LOW, bars, endShift);
      
      m_rangeHigh = iHigh(_Symbol, m_timeframe, highestIdx);
      m_rangeLow = iLow(_Symbol, m_timeframe, lowestIdx);

      // محاسبه ارتفاع رنج به پوینت
      double rangeHeight = (m_rangeHigh - m_rangeLow) / _Point;
      if(InpDebugMode) Print("رنج ", m_rangeIndex, ": سقف=", m_rangeHigh, ", کف=", m_rangeLow, ", ارتفاع=", rangeHeight, " پوینت");

      // اعتبارسنجی کیفیت رنج
      if(rangeHeight < m_minRangePoints || rangeHeight > m_maxRangePoints)
      {
         Print("رنج ", m_rangeIndex, " بی‌کیفیت است. ارتفاع خارج از محدوده مجاز.");
         m_currentState = RANGE_EXPIRED;
         return;
      }

      // رسم مستطیل گرافیکی
      if(!ObjectCreate(0, m_rangeObjectName, OBJ_RECTANGLE, 0, startTime, m_rangeHigh, endTime, m_rangeLow))
      {
         Print("خطا در رسم مستطیل رنج ", m_rangeIndex, ": ", GetLastError());
      }
      else
      {
         ObjectSetInteger(0, m_rangeObjectName, OBJPROP_COLOR, m_color);
         ObjectSetInteger(0, m_rangeObjectName, OBJPROP_STYLE, STYLE_SOLID);
         ObjectSetInteger(0, m_rangeObjectName, OBJPROP_WIDTH, 1);
         if(InpDebugMode) Print("مستطیل رنج ", m_rangeIndex, " رسم شد.");
      }

      // استعلام یک‌بار فیلتر روند و قفل کردن آن
      CTrendFilter trendFilter;
      trendFilter.Init();
      m_lockedTrendDirection = trendFilter.GetTrendDirection(m_trendFilterTimeframe);
      trendFilter.Deinit();
      if(InpDebugMode) Print("جهت روند قفل‌شده برای رنج ", m_rangeIndex, ": ", EnumToString(m_lockedTrendDirection));

      m_currentState = RANGE_IDENTIFIED;
      if(InpDebugMode) Print("رنج ", m_rangeIndex, " معتبر است. تغییر حالت به IDENTIFIED.");
   }

   // ثبت سفارش‌های پندینگ
   void PlacePendingOrders()
   {
      if(InpDebugMode) Print("ثبت سفارش‌های پندینگ برای رنج ", m_rangeIndex, "...");

      // محاسبه فاصله سفارش
      double offset;
      if(m_placementMode == PLACEMENT_ATR)
      {
         offset = GetCachedATR() * m_atrMultiplier;
      }
      else // PLACEMENT_PERCENT
      {
         offset = (m_rangeHigh - m_rangeLow) * m_atrMultiplier / 100.0;
      }

      // محاسبه استاپ لاس
      double slDistance;
      if(m_slMode == SL_ATR)
      {
         slDistance = GetCachedATR() * m_slAtrMultiplier;
      }
      else // SL_PERCENT
      {
         slDistance = (m_rangeHigh - m_rangeLow) * m_slAtrMultiplier / 100.0;
      }

      // محاسبه قیمت‌های سفارش
      double buyStopPrice = NormalizeDouble(m_rangeHigh + offset, _Digits);
      double sellStopPrice = NormalizeDouble(m_rangeLow - offset, _Digits);
      double buySL = NormalizeDouble(buyStopPrice - slDistance, _Digits);
      double sellSL = NormalizeDouble(sellStopPrice + slDistance, _Digits);

      // محاسبه حجم معامله با کش
      double lotSize = CRiskManager::CalculateLotSize(InpRiskPercent, slDistance / _Point); // به پوینت
      if(lotSize == 0)
      {
         Print("خطا در محاسبه حجم برای رنج ", m_rangeIndex);
         m_currentState = RANGE_EXPIRED;
         return;
      }

      // محاسبه زمان انقضا
      m_cleanupTime = CTimeHelper::CalculateCleanupTime(m_endHour, m_endMinute, m_cleanupHours);

      // تصمیم‌گیری بر اساس جهت قفل‌شده
      bool placeBuy = (m_lockedTrendDirection == TREND_BUY || m_lockedTrendDirection == TREND_NEUTRAL);
      bool placeSell = (m_lockedTrendDirection == TREND_SELL || m_lockedTrendDirection == TREND_NEUTRAL);

      CTrade trade;
      MqlTradeRequest request;
      MqlTradeResult result;

      if(placeBuy)
      {
         ZeroMemory(request);
         request.action = TRADE_ACTION_PENDING;
         request.symbol = _Symbol;
         request.volume = lotSize;
         request.type = ORDER_TYPE_BUY_STOP;
         request.price = buyStopPrice;
         request.sl = buySL;
         request.tp = 0;
         request.magic = m_magicNumber;
         request.expiration = m_cleanupTime;
         request.type_time = ORDER_TIME_SPECIFIED;
         request.comment = "Buy Stop Range " + IntegerToString(m_rangeIndex);
         if(!trade.OrderSend(request, result))
         {
            Print("خطا در ثبت Buy Stop برای رنج ", m_rangeIndex, ": ", result.retcode);
            m_currentState = RANGE_EXPIRED;
            return;
         }
         if(InpDebugMode) Print("Buy Stop برای رنج ", m_rangeIndex, " ثبت شد. قیمت=", buyStopPrice, ", SL=", buySL);
      }

      if(placeSell)
      {
         ZeroMemory(request);
         request.action = TRADE_ACTION_PENDING;
         request.symbol = _Symbol;
         request.volume = lotSize;
         request.type = ORDER_TYPE_SELL_STOP;
         request.price = sellStopPrice;
         request.sl = sellSL;
         request.tp = 0;
         request.magic = m_magicNumber;
         request.expiration = m_cleanupTime;
         request.type_time = ORDER_TIME_SPECIFIED;
         request.comment = "Sell Stop Range " + IntegerToString(m_rangeIndex);
         if(!trade.OrderSend(request, result))
         {
            Print("خطا در ثبت Sell Stop برای رنج ", m_rangeIndex, ": ", result.retcode);
            m_currentState = RANGE_EXPIRED;
            return;
         }
         if(InpDebugMode) Print("Sell Stop برای رنج ", m_rangeIndex, " ثبت شد. قیمت=", sellStopPrice, ", SL=", sellSL);
      }

      m_currentState = ORDERS_PLACED;
      if(InpDebugMode) Print("سفارش‌های پندینگ برای رنج ", m_rangeIndex, " ثبت شدند. تغییر حالت به ORDERS_PLACED.");
   }

   // مدیریت معامله فعال
   void ManageActiveTrade()
   {
      if(InpDebugMode) Print("مدیریت معامله برای رنج ", m_rangeIndex, "...");

      // پیدا کردن پوزیشن فعال
      if(m_activeTicket == 0 || !PositionSelectByTicket(m_activeTicket) || PositionGetInteger(POSITION_MAGIC) != m_magicNumber)
      {
         m_activeTicket = 0;
         for(int i = PositionsTotal() - 1; i >= 0; i--)
         {
            ulong ticket = PositionGetTicket(i);
            if(PositionSelectByTicket(ticket) && PositionGetInteger(POSITION_MAGIC) == m_magicNumber)
            {
               m_activeTicket = ticket;
               break;
            }
         }
      }

      if(m_activeTicket == 0)
      {
         if(InpDebugMode) Print("هیچ معامله فعالی برای رنج ", m_rangeIndex, " یافت نشد.");
         return;
      }

      // گرفتن اطلاعات پوزیشن
      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      double currentPrice = posType == POSITION_TYPE_BUY ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double sl = PositionGetDouble(POSITION_SL);
      double volume = PositionGetDouble(POSITION_VOLUME);
      double slDistance = MathAbs(openPrice - sl); // در قیمت

      // محاسبه سود فعلی در فاصله
      double currentProfit = MathAbs(currentPrice - openPrice);

      // بررسی خروج پله‌ای
      if(!m_trailingActivated)
      {
         double targetDistance = slDistance * m_rrRatio;
         if(currentProfit >= targetDistance)
         {
            double partialVolume = volume * m_partialClosePercent / 100.0;
            double closeVolume = MathRound(partialVolume / g_volumeStep) * g_volumeStep;
            double remainingVolume = volume - closeVolume;

            // بررسی حداقل حجم
            if(remainingVolume < g_volumeMin && remainingVolume > 0)
            {
               closeVolume = volume; // بستن کل اگر باقی‌مانده کمتر از min
            }

            if(closeVolume >= g_volumeMin && closeVolume <= g_volumeMax)
            {
               if(CTradeManager::PartialClose(m_activeTicket, closeVolume))
               {
                  if(InpDebugMode) Print("بخشی از معامله رنج ", m_rangeIndex, " بسته شد. حجم بسته شده=", closeVolume);
                  // انتقال استاپ لاس به نقطه ورود
                  if(CTradeManager::MoveSLToBreakEven(m_activeTicket, openPrice))
                  {
                     if(InpDebugMode) Print("استاپ لاس رنج ", m_rangeIndex, " به نقطه ورود منتقل شد.");
                     m_trailingActivated = true;
                  }
               }
            }
            else
            {
               Print("حجم بستن نامعتبر برای رنج ", m_rangeIndex, " (کمتر از min یا بیشتر از max).");
            }
         }
      }

      // اعمال تریلینگ استاپ
      if(m_trailingActivated)
      {
         if(!CTradeManager::TrailingStop(m_activeTicket, m_trailingMode, m_trailingAtrPeriod, m_trailingAtrMultiplier, m_timeframe, m_atrHandle))
         {
            Print("خطا در اعمال تریلینگ استاپ برای رنج ", m_rangeIndex);
         }
      }

      m_currentState = TRADE_ACTIVE;
      if(InpDebugMode) Print("معامله رنج ", m_rangeIndex, " در حالت TRADE_ACTIVE.");
   }

   // پاکسازی رنج
   void Cleanup()
   {
      if(InpDebugMode) Print("پاکسازی رنج ", m_rangeIndex, "...");

      // بستن پوزیشن‌های باز
      for(int i = PositionsTotal() - 1; i >= 0; i--)
      {
         ulong ticket = PositionGetTicket(i);
         if(PositionSelectByTicket(ticket) && PositionGetInteger(POSITION_MAGIC) == m_magicNumber)
         {
            if(CTradeManager::ClosePosition(ticket))
            {
               if(InpDebugMode) Print("پوزیشن با تیکت ", ticket, " برای رنج ", m_rangeIndex, " بسته شد.");
            }
         }
      }

      // حذف سفارش‌های پندینگ
      for(int i = OrdersTotal() - 1; i >= 0; i--)
      {
         ulong ticket = OrderGetTicket(i);
         if(OrderSelect(ticket) && OrderGetInteger(ORDER_MAGIC) == m_magicNumber)
         {
            CTrade trade;
            if(trade.OrderDelete(ticket))
            {
               if(InpDebugMode) Print("سفارش پندینگ با تیکت ", ticket, " برای رنج ", m_rangeIndex, " حذف شد.");
            }
         }
      }

      // حذف مستطیل گرافیکی
      ObjectDelete(0, m_rangeObjectName);
      if(InpDebugMode) Print("مستطیل رنج ", m_rangeIndex, " حذف شد.");

      // ریست حالت
      m_currentState = RANGE_WAITING;
      m_rangeHigh = 0;
      m_rangeLow = 0;
      m_cleanupTime = 0;
      m_trailingActivated = false;
      m_activeTicket = 0;
      m_cachedATR = 0; // ریست کش ATR
      m_lockedTrendDirection = TREND_NEUTRAL;
      if(InpDebugMode) Print("رنج ", m_rangeIndex, " برای روز بعد ریست شد. تغییر حالت به WAITING.");
   }

   // بررسی تعطیلی بازار دقیق‌تر
   bool IsMarketClosed()
   {
      datetime from = 0, to = 0;
      MqlDateTime dt;
      TimeToStruct(TimeTradeServer(), dt);
      ENUM_DAY_OF_WEEK day = (ENUM_DAY_OF_WEEK)dt.day_of_week;
      if(!SymbolInfoSessionTrade(_Symbol, day, 0, from, to))
      {
         int err = GetLastError();
         if(InpDebugMode) Print("خطا در SymbolInfoSessionTrade برای رنج ", m_rangeIndex, ": ", err);
         return true;
      }
      if(TimeTradeServer() < from || TimeTradeServer() > to)
      {
         return true;
      }

      // چک weekend ساده
      MqlDateTime serverTime;
      TimeToStruct(TimeTradeServer(), serverTime);
      if(serverTime.day_of_week == 6 || serverTime.day_of_week == 0) // شنبه یا یکشنبه
      {
         if(InpDebugMode) Print("بازار تعطیل است برای رنج ", m_rangeIndex);
         return true;
      }
      return false;
   }

   // گرفتن ATR کش‌شده
   double GetCachedATR()
   {
      if(m_cachedATR <= 0)
      {
         double atr[];
         ArraySetAsSeries(atr, true);
         if(CopyBuffer(m_atrHandle, 0, 0, 1, atr) <= 0)
         {
            Print("خطا در گرفتن ATR برای رنج ", m_rangeIndex, ": ", GetLastError());
            return 0;
         }
         m_cachedATR = atr[0];
      }
      return m_cachedATR;
   }
};

#endif


//end file 3

```


```mqh
//+------------------------------------------------------------------+
//|                        TradeManager.mqh                          |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این کتابخانه شامل توابع مدیریت معاملات است. وظایف اصلی:
// 1. PartialClose: بستن بخشی از پوزیشن با نرمالایز حجم و چک min/max.
// 2. MoveSLToBreakEven: انتقال استاپ لاس به نقطه ورود (ریسک‌فری).
// 3. TrailingStop: اعمال تریلینگ استاپ با حالت ATR یا ساده، با چک sl != 0.
// 4. ClosePosition: بستن کامل پوزیشن.
// توابع با تیکت پوزیشن کار می‌کنند تا از تداخل جلوگیری شود.
// تمام عملیات با نرمال‌سازی و بررسی خطا انجام می‌شوند.
// بهینه‌سازی: استفاده از CTrade، لاگ conditional با InpDebugMode.
// اصلاحات: چک حجم در PartialClose، چک sl در TrailingStop.
// این کامنت بخشی از سند کلی نسخه 1.5 است: توصیف توابع مدیریت معاملات برای ادغام با CRange (بدون تغییر در این نسخه).

#ifndef TRADE_MANAGER_MQH
#define TRADE_MANAGER_MQH

#include <Trade\Trade.mqh>

extern double g_tickSize; // از اصلی

class CTradeManager
{
public:
   // بستن بخشی از پوزیشن
   static bool PartialClose(ulong ticket, double volume)
   {
      if(InpDebugMode) Print("تلاش برای بستن بخشی از پوزیشن با تیکت ", ticket, ", حجم=", volume);

      if(!PositionSelectByTicket(ticket))
      {
         Print("خطا: پوزیشن با تیکت ", ticket, " یافت نشد.");
         return false;
      }

      CTrade trade;
      if(trade.PositionClosePartial(ticket, volume))
      {
         if(InpDebugMode) Print("بخشی از پوزیشن با تیکت ", ticket, " بسته شد.");
         return true;
      }
      else
      {
         Print("خطا در بستن بخشی از پوزیشن با تیکت ", ticket, ": ", trade.ResultRetcode());
         return false;
      }
   }

   // انتقال استاپ لاس به نقطه ورود
   static bool MoveSLToBreakEven(ulong ticket, double breakEvenPrice)
   {
      if(InpDebugMode) Print("تلاش برای انتقال استاپ لاس پوزیشن ", ticket, " به نقطه ورود=", breakEvenPrice);

      if(!PositionSelectByTicket(ticket))
      {
         Print("خطا: پوزیشن با تیکت ", ticket, " یافت نشد.");
         return false;
      }

      CTrade trade;
      breakEvenPrice = NormalizeDouble(breakEvenPrice, _Digits);
      if(trade.PositionModify(ticket, breakEvenPrice, PositionGetDouble(POSITION_TP)))
      {
         if(InpDebugMode) Print("استاپ لاس پوزیشن ", ticket, " به نقطه ورود منتقل شد.");
         return true;
      }
      else
      {
         Print("خطا در انتقال استاپ لاس پوزیشن ", ticket, ": ", trade.ResultRetcode());
         return false;
      }
   }

   // اعمال تریلینگ استاپ (با هندل ATR shared)
   static bool TrailingStop(ulong ticket, ENUM_TRAILING_MODE mode, int atrPeriod, double atrMultiplier, ENUM_TIMEFRAMES timeframe, int atrHandle)
   {
      if(InpDebugMode) Print("اعمال تریلینگ استاپ برای پوزیشن ", ticket, "...");

      if(!PositionSelectByTicket(ticket))
      {
         Print("خطا: پوزیشن با تیکت ", ticket, " یافت نشد.");
         return false;
      }

      double sl = PositionGetDouble(POSITION_SL);
      if(sl == 0)
      {
         Print("هشدار: SL اولیه صفر است برای پوزیشن ", ticket, ". تریلینگ skip شد.");
         return false;
      }

      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      double currentPrice = posType == POSITION_TYPE_BUY ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);

      double trailingDistance;
      if(mode == TRAILING_ATR)
      {
         double atr[];
         ArraySetAsSeries(atr, true);
         if(CopyBuffer(atrHandle, 0, 0, 1, atr) <= 0)
         {
            Print("خطا در گرفتن ATR برای تریلینگ: ", GetLastError());
            return false;
         }
         trailingDistance = atr[0] * atrMultiplier;
      }
      else // TRAILING_SIMPLE
      {
         trailingDistance = atrMultiplier * _Point; // فاصله ثابت با tickSize
      }

      double newSL;
      if(posType == POSITION_TYPE_BUY)
      {
         newSL = NormalizeDouble(currentPrice - trailingDistance, _Digits);
         if(newSL > sl)
         {
            CTrade trade;
            if(trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP)))
            {
               if(InpDebugMode) Print("تریلینگ استاپ برای پوزیشن ", ticket, " به‌روزرسانی شد. SL جدید=", newSL);
               return true;
            }
            else
            {
               Print("خطا در به‌روزرسانی تریلینگ استاپ برای پوزیشن ", ticket, ": ", trade.ResultRetcode());
               return false;
            }
         }
      }
      else // POSITION_TYPE_SELL
      {
         newSL = NormalizeDouble(currentPrice + trailingDistance, _Digits);
         if(newSL < sl)
         {
            CTrade trade;
            if(trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP)))
            {
               if(InpDebugMode) Print("تریلینگ استاپ برای پوزیشن ", ticket, " به‌روزرسانی شد. SL جدید=", newSL);
               return true;
            }
            else
            {
               Print("خطا در به‌روزرسانی تریلینگ استاپ برای پوزیشن ", ticket, ": ", trade.ResultRetcode());
               return false;
            }
         }
      }

      return true; // اگر نیازی به تغییر نبود
   }

   // بستن کامل پوزیشن
   static bool ClosePosition(ulong ticket)
   {
      if(InpDebugMode) Print("تلاش برای بستن کامل پوزیشن با تیکت ", ticket);

      if(!PositionSelectByTicket(ticket))
      {
         Print("خطا: پوزیشن با تیکت ", ticket, " یافت نشد.");
         return false;
      }

      CTrade trade;
      if(trade.PositionClose(ticket))
      {
         if(InpDebugMode) Print("پوزیشن با تیکت ", ticket, " بسته شد.");
         return true;
      }
      else
      {
         Print("خطا در بستن پوزیشن با تیکت ", ticket, ": ", trade.ResultRetcode());
         return false;
      }
   }
};

#endif

//end file 4
```
```mqh
//+------------------------------------------------------------------+
//|                        RiskManager.mqh                           |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                 |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این کتابخانه مسئول مدیریت ریسک و محاسبه حجم معاملات است.
// وظیفه اصلی:
// - CalculateLotSize: محاسبه حجم (LotSize) بر اساس درصد ریسک و فاصله استاپ لاس.
// الگوریتم کلی:
// - فرمول: LotSize = (RiskPercent * AccountBalance) / (SL_Distance * TickValue)
// - حجم با MathRound و گام‌بندی نرمالایز می‌شود تا با قوانین بروکر سازگار باشد.
// - چک min/max برای جلوگیری از حجم نامعتبر.
// بهینه‌سازی: استفاده از کش جهانی برای tickValue و غیره.
// اصلاحات: تغییر MathFloor به MathRound برای دقت بهتر.
// این کامنت بخشی از سند کلی نسخه 1.5 است: توصیف مدیریت ریسک برای ادغام با CRange در محاسبه حجم (بدون تغییر در این نسخه).

#ifndef RISK_MANAGER_MQH
#define RISK_MANAGER_MQH

extern double g_tickValue;
extern double g_tickSize;
extern double g_volumeStep;
extern double g_volumeMin;
extern double g_volumeMax;

class CRiskManager
{
public:
   // محاسبه حجم معامله
   static double CalculateLotSize(double riskPercent, double slPoints)
   {
      if(InpDebugMode) Print("محاسبه حجم معامله با ریسک ", riskPercent, "% و فاصله استاپ لاس ", slPoints, " پوینت...");

      // گرفتن اطلاعات حساب
      double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
      
      // تبدیل فاصله به ارزش
      if(g_tickSize == 0)
      {
         Print("خطا: tickSize صفر است.");
         return 0;
      }
      double slValue = slPoints * g_tickValue;
      
      // محاسبه حجم
      double lotSize = (riskPercent / 100.0 * accountBalance) / slValue;
      
      // نرمال‌سازی حجم با MathRound
      lotSize = MathRound(lotSize / g_volumeStep) * g_volumeStep;
      lotSize = MathMax(g_volumeMin, MathMin(g_volumeMax, lotSize));
      
      if(lotSize < g_volumeMin)
      {
         Print("خطا: حجم محاسبه شده کمتر از حداقل است.");
         return 0;
      }
      
      if(InpDebugMode) Print("حجم محاسبه شده برای معامله: ", lotSize);
      return lotSize;
   }
};

#endif

//end file 5
```
```mqh


//end file 6
```


```mqh
//+------------------------------------------------------------------+
//|                        TimeHelper.mqh                            |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این کتابخانه شامل توابع کمکی برای مدیریت زمان است.
// وظایف اصلی:
// 1. CalculateRangeTimes: محاسبه زمان شروع و پایان رنج با مدیریت عبور از نیمه‌شب و skip تعطیلات.
// 2. CalculateCleanupTime: محاسبه زمان انقضا با اضافه ساعت‌ها و skip تعطیلات.
// 3. IsNonTradingDay: چک روز غیرمعاملاتی با day_of_week و SymbolInfoSessionTrade.
// الگوریتم کلی:
// - زمان‌ها به datetime تبدیل می‌شوند.
// - اگر پایان قبل از شروع باشد، روز بعد اضافه می‌شود.
// - برای تعطیلات، زمان به روز معاملاتی قبل/بعد skip می‌شود.
// بهینه‌سازی: مدیریت دقیق weekend و sessionها.
// اصلاحات: استفاده از ENUM_DAY_OF_WEEK درست.
// این کامنت بخشی از سند کلی نسخه 1.5 است: توصیف مدیریت زمان برای ادغام با CRange در شناسایی رنج و پاکسازی (بدون تغییر در این نسخه).

#ifndef TIME_HELPER_MQH
#define TIME_HELPER_MQH


class CTimeHelper
{
public:
   // محاسبه زمان شروع و پایان رنج
   static bool CalculateRangeTimes(int startHour, int startMinute, int endHour, int endMinute, datetime &startTime, datetime &endTime)
   {
      if(InpDebugMode) Print("محاسبه زمان شروع و پایان رنج...");

      // گرفتن زمان سرور
      datetime serverTime = TimeTradeServer();
      MqlDateTime dt;
      TimeToStruct(serverTime, dt);

      // تنظیم زمان شروع
      dt.hour = startHour;
      dt.min = startMinute;
      dt.sec = 0;
      startTime = StructToTime(dt);

      // تنظیم زمان پایان
      dt.hour = endHour;
      dt.min = endMinute;
      dt.sec = 0;
      endTime = StructToTime(dt);

      // اگر پایان قبل از شروع باشد, روز بعد
      if(endTime <= startTime)
      {
         endTime += 86400; // اضافه کردن یک روز
      }

      // اگر زمان شروع در آینده باشد, به روز قبل
      if(startTime > serverTime)
      {
         startTime -= 86400;
         endTime -= 86400;
      }

      // چک و skip تعطیلات (اگر در تعطیلی باشد, به روز معاملاتی قبل)
      while(IsNonTradingDay(startTime))
      {
         startTime -= 86400;
         endTime -= 86400;
      }

      if(InpDebugMode) Print("زمان شروع رنج: ", TimeToString(startTime), ", زمان پایان: ", TimeToString(endTime));
      return true;
   }

   // محاسبه زمان پاکسازی
   static datetime CalculateCleanupTime(int endHour, int endMinute, int cleanupHours)
   {
      if(InpDebugMode) Print("محاسبه زمان پاکسازی...");

      MqlDateTime dt;
      TimeToStruct(TimeTradeServer(), dt);
      dt.hour = endHour;
      dt.min = endMinute;
      dt.sec = 0;
      datetime endTime = StructToTime(dt);

      // اگر پایان قبل از زمان فعلی باشد, روز بعد
      if(endTime < TimeTradeServer())
      {
         endTime += 86400;
      }

      // skip تعطیلات برای endTime
      while(IsNonTradingDay(endTime))
      {
         endTime += 86400;
      }

      // اضافه کردن ساعت‌های پاکسازی
      datetime cleanupTime = endTime + cleanupHours * 3600;
      if(InpDebugMode) Print("زمان پاکسازی: ", TimeToString(cleanupTime));
      return cleanupTime;
   }

private:
   // چک روز غیرمعاملاتی
   static bool IsNonTradingDay(datetime time)
   {
      MqlDateTime dt;
      TimeToStruct(time, dt);
      if(dt.day_of_week == 0 || dt.day_of_week == 6)
      {
         return true;
      }
      // چک session (اگر هیچ session نباشد)
      datetime from = 0, to = 0;
      if(!SymbolInfoSessionTrade(_Symbol, (ENUM_DAY_OF_WEEK)dt.day_of_week, 0, from, to))
      {
         return true;
      }
      return false;
   }
};

#endif

//end file 7
```

```mqh
//+------------------------------------------------------------------+
//|                            TrendFilter.mqh                        |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این کتابخانه مسئولیت تمام منطق‌های مربوط به فیلتر روند را بر عهده دارد. کلاس اصلی CTrendFilter است که با استفاده از اندیکاتور ایچیموکو (ابر آینده یا Future Kumo)، جهت روند بازار را تشخیص می‌دهد. این فیلتر برای جلوگیری از معاملات خلاف جهت روند کلی بازار استفاده می‌شود و فقط معاملات هم‌جهت با روند را مجاز می‌کند.
// وظایف اصلی:
// 1. تشخیص جهت روند: با محاسبه Future Senkou Span A و B از ایچیموکو، یکی از سه حالت TREND_BUY (صعودی)، TREND_SELL (نزولی) یا TREND_NEUTRAL (خنثی) را برمی‌گرداند.
// 2. مدیریت آستانه فلت: اگر فاصله بین Span A و B کمتر از آستانه مشخص (Inp_Ichimoku_FlatThreshold_Points) باشد، حالت خنثی تشخیص داده می‌شود.
// 3. هندل ایچیموکو: در Init، هندل اندیکاتور ایجاد می‌شود و در Deinit آزاد می‌شود.
// الگوریتم کلی:
// - در GetTrendDirection: هندل ایچیموکو برای تایم‌فریم مشخص ایجاد می‌شود (اگر وجود نداشته باشد).
// - مقادیر Tenkan-sen و Kijun-sen از کندل 1 خوانده می‌شود.
// - Future Senkou Span A = (Tenkan + Kijun) / 2
// - Future Senkou Span B = (بالاترین High + پایین‌ترین Low در پریود Senkou B) / 2
// - مقایسه: اگر A > B، TREND_BUY؛ اگر A < B، TREND_SELL؛ اگر نزدیک (کمتر از آستانه)، TREND_NEUTRAL.
// بهینه‌سازی‌ها: هندل ایچیموکو shared، لاگ conditional با InpDebugMode، normalize مقادیر.
// اصلاحات: چک INVALID_HANDLE، مدیریت حالت خنثی برای اجازه هر دو جهت (مانند خاموش بودن فیلتر).
// این کامنت بخشی از سند کلی نسخه 1.5 است: این کتابخانه ماژولار است و می‌توان فیلترهای دیگر (مانند MA) را در آینده اضافه کرد. ادغام با CRange برای قفل کردن جهت در لحظه شناسایی رنج.

#ifndef TREND_FILTER_MQH
#define TREND_FILTER_MQH

#include "Settings.mqh"

// تعریف enum برای جهت روند
enum ENUM_TREND_DIRECTION
{
   TREND_BUY,     // روند صعودی است، فقط مجاز به خرید
   TREND_SELL,    // روند نزولی است، فقط مجاز به فروش
   TREND_NEUTRAL  // روند خنثی یا نامشخص است، هر دو جهت مجاز
};

class CTrendFilter
{
private:
   int m_ichimokuHandle;  // هندل اندیکاتور ایچیموکو (shared)

public:
   // سازنده پیش‌فرض
   CTrendFilter() : m_ichimokuHandle(INVALID_HANDLE) {}

   // مقداردهی اولیه
   bool Init()
   {
      if(InpDebugMode) Print("مقداردهی فیلتر روند ایچیموکو...");
      // هندل ایچیموکو در GetTrendDirection مدیریت می‌شود (برای هر تایم‌فریم جدا)
      return true;
   }

   // دفع مقداردهی
   void Deinit()
   {
      if(m_ichimokuHandle != INVALID_HANDLE)
      {
         IndicatorRelease(m_ichimokuHandle);
         m_ichimokuHandle = INVALID_HANDLE;
         if(InpDebugMode) Print("هندل ایچیموکو آزاد شد.");
      }
   }

   // تابع کلیدی: گرفتن جهت روند بر اساس تایم‌فریم فیلتر
   ENUM_TREND_DIRECTION GetTrendDirection(ENUM_TIMEFRAMES filterTimeframe)
   {
      if(!Inp_IchimokuFilter_Enabled)
      {
         if(InpDebugMode) Print("فیلتر روند خاموش است. بازگشت TREND_NEUTRAL.");
         return TREND_NEUTRAL;
      }

      // ایجاد هندل ایچیموکو اگر لازم باشد (برای تایم‌فریم مشخص)
      int ichimokuHandle = iIchimoku(_Symbol, filterTimeframe, Inp_Ichimoku_Tenkan, Inp_Ichimoku_Kijun, Inp_Ichimoku_SenkouB);
      if(ichimokuHandle == INVALID_HANDLE)
      {
         Print("خطا در ایجاد هندل ایچیموکو برای تایم‌فریم ", EnumToString(filterTimeframe));
         return TREND_NEUTRAL;
      }

      // آرایه‌های بافر برای ایچیموکو
      double tenkan[], kijun[], senkouA[], senkouB[], chikou[];
      ArraySetAsSeries(tenkan, true);
      ArraySetAsSeries(kijun, true);
      ArraySetAsSeries(senkouA, true);
      ArraySetAsSeries(senkouB, true);
      ArraySetAsSeries(chikou, true);

      // کپی بافرها (برای Future Kumo، از شیفت 0 استفاده می‌شود اما برای Future، شیفت مثبت)
      // نکته: در ایچیموکو، Senkou Span A و B برای آینده (شیفت 26 پیش‌فرض) هستند، اما برای محاسبه دستی
      // ما محاسبه دستی Future را انجام می‌دهیم.

      // خواندن Tenkan و Kijun از کندل 1 (آخرین بسته‌شده)
      if(CopyBuffer(ichimokuHandle, 0, 1, 1, tenkan) <= 0 || CopyBuffer(ichimokuHandle, 1, 1, 1, kijun) <= 0)
      {
         Print("خطا در کپی بافرهای ایچیموکو: ", GetLastError());
         IndicatorRelease(ichimokuHandle);
         return TREND_NEUTRAL;
      }

      // محاسبه Future Senkou Span A
      double futureSenkouA = (tenkan[0] + kijun[0]) / 2.0;

      // محاسبه Future Senkou Span B: بالاترین High و پایین‌ترین Low در پریود SenkouB گذشته
      int senkouBPeriod = Inp_Ichimoku_SenkouB;
      int highestShift = iHighest(_Symbol, filterTimeframe, MODE_HIGH, senkouBPeriod, 1);
      int lowestShift = iLowest(_Symbol, filterTimeframe, MODE_LOW, senkouBPeriod, 1);
      double highestHigh = iHigh(_Symbol, filterTimeframe, highestShift);
      double lowestLow = iLow(_Symbol, filterTimeframe, lowestShift);
      double futureSenkouB = (highestHigh + lowestLow) / 2.0;

      // مقایسه و تصمیم‌گیری
      double diff = MathAbs(futureSenkouA - futureSenkouB) / _Point;  // به پوینت
      ENUM_TREND_DIRECTION direction;
      if(diff < Inp_Ichimoku_FlatThreshold_Points)
      {
         direction = TREND_NEUTRAL;
         if(InpDebugMode) Print("ابر ایچیموکو فلت است (تفاوت=", diff, " پوینت). جهت: NEUTRAL");
      }
      else if(futureSenkouA > futureSenkouB)
      {
         direction = TREND_BUY;
         if(InpDebugMode) Print("ابر ایچیموکو صعودی (SenkouA=", futureSenkouA, " > SenkouB=", futureSenkouB, "). جهت: BUY");
      }
      else
      {
         direction = TREND_SELL;
         if(InpDebugMode) Print("ابر ایچیموکو نزولی (SenkouA=", futureSenkouA, " < SenkouB=", futureSenkouB, "). جهت: SELL");
      }

      // آزادسازی هندل (اگر shared نباشد، اما برای هر فراخوانی جدید است)
      IndicatorRelease(ichimokuHandle);
      return direction;
   }
};

#endif

//end file 8
```

```mqh
//+------------------------------------------------------------------+
//|                            VisualManager.mqh                      |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این کتابخانه مسئولیت نمایش هرگونه اطلاعات متنی روی چارت را بر عهده می‌گیرد تا منطق نمایش از منطق معاملاتی جدا باشد. کلاس اصلی CVisualManager است که وضعیت فعلی روند (مانند "TREND BUY") را در گوشه بالا-چپ چارت نمایش می‌دهد.
// وظایف اصلی:
// 1. UpdateTrendStatus: نمایش متن وضعیت روند با رنگ مشخص (بر اساس جهت: سبز برای BUY، قرمز برای SELL، خاکستری برای NEUTRAL).
// 2. مدیریت لیبل: اگر متن خالی باشد، لیبل حذف می‌شود؛ در غیر این صورت، ایجاد یا به‌روزرسانی می‌شود.
// 3. تنظیمات نمایش: فونت، اندازه، رنگ‌ها، فاصله از لبه‌ها از ورودی‌ها (Inp_Visual_*) گرفته می‌شود.
// الگوریتم کلی:
// - در UpdateTrendStatus: چک وجود لیبل، ایجاد اگر نباشد، به‌روزرسانی متن و رنگ.
// - اگر Inp_Visual_ShowTrendStatus خاموش باشد، هیچ عملی انجام نمی‌شود.
// بهینه‌سازی‌ها: لاگ conditional با InpDebugMode، استفاده از ObjectSet برای به‌روزرسانی بدون حذف/ایجاد مکرر.
// اصلاحات: چک ObjectFind برای جلوگیری از تکرار، مدیریت حذف با متن خالی.
// این کامنت بخشی از سند کلی نسخه 1.5 است: این کتابخانه ماژولار است و می‌توان نمایش‌های دیگر (مانند آمار معاملات) را در آینده اضافه کرد. ادغام با Elemento.mq5 برای نمایش در OnTick.

#ifndef VISUAL_MANAGER_MQH
#define VISUAL_MANAGER_MQH

#include "Settings.mqh"

class CVisualManager
{
private:
   string m_labelName;  // نام لیبل وضعیت روند (ثابت: "TrendStatusLabel")

public:
   // سازنده پیش‌فرض
   CVisualManager() : m_labelName("TrendStatusLabel") {}

   // مقداردهی اولیه
   bool Init()
   {
      if(InpDebugMode) Print("مقداردهی مدیر نمایش...");
      return true;
   }

   // دفع مقداردهی (حذف لیبل)
   void Deinit()
   {
      ObjectDelete(0, m_labelName);
      if(InpDebugMode) Print("لیبل وضعیت روند حذف شد.");
   }

   // تابع کلیدی: به‌روزرسانی وضعیت روند روی چارت
   void UpdateTrendStatus(string text, color textColor)
   {
      if(!Inp_Visual_ShowTrendStatus)
      {
         if(InpDebugMode) Print("نمایش وضعیت روند خاموش است.");
         return;
      }

      if(text == "")
      {
         ObjectDelete(0, m_labelName);
         if(InpDebugMode) Print("لیبل وضعیت روند حذف شد (متن خالی).");
         return;
      }

      // چک وجود لیبل
      if(ObjectFind(0, m_labelName) < 0)
      {
         // ایجاد لیبل جدید
         if(!ObjectCreate(0, m_labelName, OBJ_LABEL, 0, 0, 0))
         {
            Print("خطا در ایجاد لیبل وضعیت روند: ", GetLastError());
            return;
         }
         ObjectSetInteger(0, m_labelName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
         ObjectSetInteger(0, m_labelName, OBJPROP_XDISTANCE, Inp_Visual_X_Offset);
         ObjectSetInteger(0, m_labelName, OBJPROP_YDISTANCE, Inp_Visual_Y_Offset);
         ObjectSetInteger(0, m_labelName, OBJPROP_FONTSIZE, Inp_Visual_FontSize);
         if(InpDebugMode) Print("لیبل وضعیت روند ایجاد شد.");
      }

      // به‌روزرسانی متن و رنگ
      ObjectSetString(0, m_labelName, OBJPROP_TEXT, text);
      ObjectSetInteger(0, m_labelName, OBJPROP_COLOR, textColor);
      if(InpDebugMode) Print("لیبل وضعیت روند به‌روزرسانی شد: متن=", text, ", رنگ=", textColor);
   }
};

#endif

//end file 9
```

```mqh
//+------------------------------------------------------------------+
//| tester_v2.mqh                                                    |
//| Copyright 2025, HipoAlgoritm - Quantum Division                  |
//| t.me/hipoalgoritm                                                |
//+------------------------------------------------------------------+
//| نسخه 2.2: بازمهندسی با تمرکز بر پایداری، کیفیت و مقاومت       |
//| در برابر اورفیتینگ، با مقیاس‌بندی متعادل برای اپتیمایزر      
//| یک کتابخانه مستقل که توسط هیپو الکوریتم تولید شده تا برای اپتیمایز ها  سیستم های مختلف استفاده شود 
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, HipoAlgoritm - Quantum Division"
#property link      "t.me/hipoalgoritm"
//+------------------------------------------------------------------+

//--- گروه: تنظیمات بهینه‌سازی سفارشی ---
// این گروه شامل پارامترهای ورودی برای تنظیمات اصلی بهینه‌سازی است.
input group "تنظیمات اصلی بهینه‌سازی";
input int    InpMinTradesPerYear      = 20;  // حداقل تعداد معاملات قابل قبول در یک سال
input double InpMaxAcceptableDrawdown = 30.0; // حداکثر دراوداون قابل قبول به درصد

input group "فیلتر کیفیت معامله (مقابله با اورفیتینگ)";
// این گروه شامل پارامترهای ورودی برای فیلتر کیفیت معاملات جهت جلوگیری از اورفیتینگ است.
input double InpMinimumProfitToCostRatio = 2.0; // حداقل نسبت سود خالص هر معامله به هزینه آن
input double InpEstimatedCostPerTrade    = 1.5; // هزینه تخمینی هر معامله (اسپرد+کمیسیون) به پیپ

//--- ساختارهای کمکی ---
// ساختار برای نگهداری نقاط منحنی اکوییتی (برای محاسبات آماری مانند R-Squared و Sortino Ratio)
struct EquityPoint
{
   datetime time;    // زمان نقطه اکوییتی
   double   balance; // موجودی در آن زمان
};

// ساختار برای نگهداری سودهای ماهانه (برای محاسبه پایداری سود ماهانه)
struct MonthlyProfit
{
   int    year;  // سال
   int    month; // ماه
   double profit; // سود خالص ماه
};

//--- توابع کمکی ریاضی برای محاسبات آماری ---
// محاسبه میانگین یک آرایه (میانگین حسابی عناصر آرایه)
double ArrayMean(const double &arr[])
{
   int size = ArraySize(arr);
   if(size == 0) return 0.0;
   double sum = 0.0;
   for(int i = 0; i < size; i++)
   {
      sum += arr[i];
   }
   return sum / size;
}

// محاسبه انحراف معیار یک آرایه (برای اندازه‌گیری نوسان)
double ArrayStdDev(const double &arr[])
{
   int size = ArraySize(arr);
   if(size < 2) return 0.0;

   double mean = ArrayMean(arr);
   double sum_sq_diff = 0.0;
   for(int i = 0; i < size; i++)
   {
      sum_sq_diff += MathPow(arr[i] - mean, 2);
   }
   return MathSqrt(sum_sq_diff / size);
}

//+------------------------------------------------------------------+
//| [جدید] محاسبه امتیاز پایداری سود ماهانه (Monthly Profit Stability)|
//+------------------------------------------------------------------+
//| هدف: این تابع به شدت استراتژی‌هایی را تشویق می‌کند که سودهای |
//| ماهانه پایدار و قابل اتکایی دارند (مانند یک حقوق ماهانه). |
//| و استراتژی‌های "لاتاری" که با یک معامله بزرگ شانس، کل سود |
//| را کسب می‌کنند، به شدت جریمه می‌کند.                         |
//| ورودی: هیچ (از تاریخچه معاملات استفاده می‌کند)                |
//| خروجی: امتیاز پایداری بین 0 تا 1                              |
//+------------------------------------------------------------------+
double CalculateMonthlyProfitStats()
{
   if(!HistorySelect(0, TimeCurrent())) return 0.0;

   uint total_deals = HistoryDealsTotal();
   if(total_deals < 3) return 0.1; // حداقل 0.1 برای جلوگیری از صفر شدن

   MonthlyProfit monthly_profits[]; // آرایه دینامیک برای نگهداری سودهای ماهانه
   int months_count = 0;

   // حلقه در تمام معاملات برای دسته‌بندی سودها بر اساس ماه
   for(uint i = 0; i < total_deals; i++)
   {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket > 0 && HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
      {
         datetime deal_time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
         MqlDateTime dt;
         TimeToStruct(deal_time, dt);

         int month_idx = -1;
         // جستجو برای یافتن ماه موجود
         for(int j = 0; j < months_count; j++)
         {
            if(monthly_profits[j].year == dt.year && monthly_profits[j].month == dt.mon)
            {
               month_idx = j;
               break;
            }
         }

         double deal_profit = HistoryDealGetDouble(ticket, DEAL_PROFIT) +
                              HistoryDealGetDouble(ticket, DEAL_COMMISSION) +
                              HistoryDealGetDouble(ticket, DEAL_SWAP);

         if(month_idx == -1) // اگر ماه جدید بود
         {
            ArrayResize(monthly_profits, months_count + 1);
            monthly_profits[months_count].year = dt.year;
            monthly_profits[months_count].month = dt.mon;
            monthly_profits[months_count].profit = deal_profit;
            months_count++;
         }
         else // اگر ماه قبلاً وجود داشت
         {
            monthly_profits[month_idx].profit += deal_profit;
         }
      }
   }

   if(months_count <= 1) return 1.0; // اگر فقط یک ماه فعالیت داشته، پایداری کامل است

   // استخراج سودهای ماهانه در یک آرایه double برای محاسبات آماری
   double profits_array[];
   ArrayResize(profits_array, months_count);
   double total_monthly_profit = 0.0;
   for(int i = 0; i < months_count; i++)
   {
      profits_array[i] = monthly_profits[i].profit;
      total_monthly_profit += profits_array[i];
   }

   // اگر میانگین سود ماهانه منفی باشد، امتیاز کم اما غیرصفر
   if(total_monthly_profit / months_count <= 0) return 0.1;

   // محاسبه انحراف معیار سودهای ماهانه
   double std_dev_monthly_profits = ArrayStdDev(profits_array);

   // فرمول امتیاز: هرچه انحراف معیار (نوسان) کمتر باشد، امتیاز به 1 نزدیک‌تر است
   return 1.0 / (1.0 + std_dev_monthly_profits / MathMax(1.0, AccountInfoDouble(ACCOUNT_BALANCE) * 0.01));
}

//+------------------------------------------------------------------+
//| [جدید] محاسبه فاکتور کیفیت معامله (Trade Quality Factor)      |
//+------------------------------------------------------------------+
//| هدف: این تابع یک مکانیسم قدرتمند ضد اورفیتینگ است. با فیلتر کردن |
//| معاملاتی که سودشان به قدری ناچیز است که توسط هزینه‌های |
//| واقعی (اسپرد، کمیسیون) از بین می‌رود، از انتخاب استراتژی‌های |
//| غیرواقعی جلوگیری می‌کند.                                      |
//| ورودی: هیچ (از تاریخچه معاملات استفاده می‌کند)                |
//| خروجی: فاکتور کیفیت بین 0 تا 1                                |
//+------------------------------------------------------------------+
double CalculateTradeQualityFactor()
{
   if(!HistorySelect(0, TimeCurrent())) return 0.1;

   uint total_deals = HistoryDealsTotal();
   if(total_deals == 0) return 0.1;

   int high_quality_trades = 0;
   int closed_trades_count = 0;

   double point_value = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double cost_per_pip = InpEstimatedCostPerTrade * point_value;

   for(uint i = 0; i < total_deals; i++)
   {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket > 0 && HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
      {
         closed_trades_count++;
         double net_profit = HistoryDealGetDouble(ticket, DEAL_PROFIT) +
                             HistoryDealGetDouble(ticket, DEAL_COMMISSION) +
                             HistoryDealGetDouble(ticket, DEAL_SWAP);

         double volume = HistoryDealGetDouble(ticket, DEAL_VOLUME);
         // هزینه تخمینی معامله بر اساس حجم
         double estimated_cost = cost_per_pip * volume / point_value;

         // یک معامله باکیفیت است اگر سود خالص آن حداقل N برابر هزینه تخمینی باشد
         if(net_profit > (estimated_cost * InpMinimumProfitToCostRatio))
         {
            high_quality_trades++;
         }
      }
   }

   if(closed_trades_count == 0) return 0.1;

   // فاکتور کیفیت، درصد معاملات باکیفیت است
   return (double)high_quality_trades / closed_trades_count;
}

//+------------------------------------------------------------------+
//| [جدید] محاسبه نسبت سود به زیان (Profit/Loss Ratio)             |
//+------------------------------------------------------------------+
//| هدف: این معیار، میانگین اندازه سودها را با میانگین اندازه ضررها |
//| مقایسه می‌کند. یک نسبت بالا (مثلاً > 1.5) نشان می‌دهد که |
//| استراتژی دارای یک مزیت (Edge) سالم در مدیریت ریسک به ریوارد |
//| است.                                                            |
//| ورودی: هیچ (از آمار تستر استفاده می‌کند)                      |
//| خروجی: نسبت سود به زیان (عدد مثبت)                             |
//+------------------------------------------------------------------+
double CalculateProfitLossRatio()
{
   double gross_profit = TesterStatistics(STAT_GROSS_PROFIT);
   double profit_trades_count = TesterStatistics(STAT_PROFIT_TRADES);
   double gross_loss = MathAbs(TesterStatistics(STAT_GROSS_LOSS));
   double loss_trades_count = TesterStatistics(STAT_LOSS_TRADES);

   if(profit_trades_count == 0 || loss_trades_count == 0 || gross_loss == 0)
   {
      return 5.0; // مقدار متعادل برای شرایط خاص
   }

   double avg_win = gross_profit / profit_trades_count;
   double avg_loss = gross_loss / loss_trades_count;

   return avg_win / avg_loss;
}

//+------------------------------------------------------------------+
//| [جدید و پیشرفته] محاسبه نسبت سورتینو (Sortino Ratio)          |
//+------------------------------------------------------------------+
//| هدف: سورتینو یک نسخه برتر از نسبت شارپ است. این معیار فقط نوسانات|
//| منفی (ریسک نزولی) را جریمه می‌کند و به نوسانات مثبت (رشدهای |
//| سریع) پاداش می‌دهد. این معیار، ریسک را از دیدگاه یک سرمایه‌گذار|
//| واقعی‌تر می‌سنجد.                                               |
//| نکته: محاسبه این معیار نیازمند پردازش منحنی اکوییتی است و کمی |
//| سنگین‌تر از معیارهای استاندارد تستر است، اما ارزش تحلیلی |
//| بسیار بالایی دارد.                                              |
//| ورودی: آرایه منحنی اکوییتی                                    |
//| خروجی: نسبت سورتینو (عدد مثبت، بالاتر بهتر)                    |
//+------------------------------------------------------------------+
double CalculateSortinoRatio(const EquityPoint &equity_curve[])
{
   int points = ArraySize(equity_curve);
   if(points < 3) return 0.1;

   // 1. محاسبه بازده‌های دوره‌ای از روی منحنی اکوییتی
   double returns[];
   ArrayResize(returns, points - 1);
   for(int i = 1; i < points; i++)
   {
      if(equity_curve[i-1].balance > 0)
      {
         // استفاده از بازده لگاریتمی برای پایداری ریاضی
         returns[i-1] = MathLog(equity_curve[i].balance / equity_curve[i-1].balance);
      }
      else
      {
         returns[i-1] = 0.0;
      }
   }

   // 2. محاسبه میانگین بازده‌ها
   double average_return = ArrayMean(returns);
   if (average_return <= 0) return 0.1;

   // 3. جداسازی بازده‌های منفی برای محاسبه انحراف معیار نزولی
   double downside_returns[];
   int downside_count = 0;
   ArrayResize(downside_returns, ArraySize(returns));
   for(int i = 0; i < ArraySize(returns); i++)
   {
      if(returns[i] < 0)
      {
         downside_returns[downside_count] = returns[i];
         downside_count++;
      }
   }
   if(downside_count < 2) return 5.0;

   ArrayResize(downside_returns, downside_count);

   // 4. محاسبه انحراف معیار نزولی (Downside Deviation)
   double downside_deviation = ArrayStdDev(downside_returns);

   if(downside_deviation == 0) return 5.0;

   // 5. محاسبه نسبت سورتینو
   return average_return / downside_deviation;
}

//+------------------------------------------------------------------+
//| [بهینه‌سازی شده] محاسبه معیارهای پیشرفته مبتنی بر منحنی اکوییتی |
//+------------------------------------------------------------------+
//| این تابع اکنون وظیفه ساخت منحنی اکوییتی و سپس فراخوانی توابع |
//| محاسباتی دیگر (R-Squared و Sortino) را بر عهده دارد تا از |
//| محاسبات تکراری جلوگیری شود.                                    |
//| ورودی: خروجی‌های r_squared و sortino_ratio (به عنوان رفرنس)    |
//| خروجی: هیچ (مقادیر را در ورودی‌ها پر می‌کند)                   |
//+------------------------------------------------------------------+
void ProcessEquityCurve(double &r_squared, double &sortino_ratio)
{
   // مقادیر اولیه
   r_squared = 0.0;
   sortino_ratio = 0.0;

   if(!HistorySelect(0, TimeCurrent())) return;
   uint total_deals = HistoryDealsTotal();
   if(total_deals < 3) return;

   // --- 1. ساخت آرایه منحنی اکوییتی (Equity Curve) ---
   EquityPoint equity_curve[];
   ArrayResize(equity_curve, (int)total_deals + 1);

   double final_balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double net_profit = TesterStatistics(STAT_PROFIT);
   double initial_balance = final_balance - net_profit;
   
   equity_curve[0].time = (total_deals > 0) ? (datetime)HistoryDealGetInteger(0, DEAL_TIME) - 1 : 0;
   equity_curve[0].balance = initial_balance;

   int equity_points = 1;
   for(uint i = 0; i < total_deals; i++)
   {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket > 0 && HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
      {
         equity_curve[equity_points].time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
         equity_curve[equity_points].balance = equity_curve[equity_points-1].balance +
                                               HistoryDealGetDouble(ticket, DEAL_PROFIT) +
                                               HistoryDealGetDouble(ticket, DEAL_COMMISSION) +
                                               HistoryDealGetDouble(ticket, DEAL_SWAP);
         equity_points++;
      }
   }
   ArrayResize(equity_curve, equity_points);
   if(equity_points < 2) return;

   // --- 2. محاسبه R-Squared (خطی بودن منحنی) ---
   double sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0, sum_y2 = 0;
   for(int i = 0; i < equity_points; i++)
   {
      double x = i + 1.0;
      double y = equity_curve[i].balance;
      sum_x += x; sum_y += y; sum_xy += x * y; sum_x2 += x*x; sum_y2 += y*y;
   }
   double n = equity_points;
   double den_part1 = (n * sum_x2) - (sum_x * sum_x);
   double den_part2 = (n * sum_y2) - (sum_y * sum_y);
   if(den_part1 > 0 && den_part2 > 0)
   {
      double r = ((n * sum_xy) - (sum_x * sum_y)) / MathSqrt(den_part1 * den_part2);
      r_squared = r * r;
   }

   // --- 3. محاسبه نسبت سورتینو با استفاده از منحنی اکوییتی ساخته شده ---
   sortino_ratio = CalculateSortinoRatio(equity_curve);
}

//+------------------------------------------------------------------+
//| [بدون تغییر] محاسبه ضریب مجازات دراوداون با منحنی کسینوسی   |
//+------------------------------------------------------------------+
//| هدف: محاسبه یک ضریب جریمه برای دراوداون بر اساس یک منحنی کسینوسی.|
//| هرچه دراوداون بیشتر، جریمه بیشتر (نزدیک به صفر).             |
//| ورودی: درصد حداکثر دراوداون                                    |
//| خروجی: ضریب جریمه بین 0 تا 1                                  |
//+------------------------------------------------------------------+
double CalculateDrawdownPenalty(double max_drawdown_percent)
{
   double penalty_factor = 0.0;
   if (max_drawdown_percent < InpMaxAcceptableDrawdown && InpMaxAcceptableDrawdown > 0)
   {
      // تبدیل درصد دراوداون به یک زاویه بین 0 تا 90 درجه (π/2 رادیان)
      double angle = (max_drawdown_percent / InpMaxAcceptableDrawdown) * (M_PI / 2.0);
      // ضریب مجازات، کسینوس آن زاویه است. هرچه زاویه (دراوداون) بیشتر، کسینوس (امتیاز) کمتر
      penalty_factor = MathCos(angle);
   }
   return penalty_factor;
}

//+------------------------------------------------------------------+
//| تابع اصلی رویداد تستر (OnTester) - نسخه 2.2                    |
//| معماری جدید با فرمول امتیازدهی یکپارچه و چندعاملی             |
//+------------------------------------------------------------------+
//| هدف: محاسبه امتیاز نهایی برای بهینه‌سازی استراتژی بر اساس معیارهای |
//| پیشرفته مانند پایداری، کیفیت معاملات، سورتینو و غیره.        |
//| ورودی: هیچ                                                       |
//| خروجی: امتیاز نهایی (عدد صحیح مثبت، بالاتر بهتر)              |
//+------------------------------------------------------------------+
double OnTester()
{
   // --- مرحله 1: دریافت آمارهای استاندارد و اولیه ---
   double total_trades = TesterStatistics(STAT_TRADES);
   double net_profit = TesterStatistics(STAT_PROFIT);
   double profit_factor = TesterStatistics(STAT_PROFIT_FACTOR);
   double recovery_factor = TesterStatistics(STAT_RECOVERY_FACTOR);
   double profit_trades = TesterStatistics(STAT_PROFIT_TRADES);
   double win_rate_factor = (total_trades > 0) ? (profit_trades / total_trades) : 0.1;
   double max_dd_percent = TesterStatistics(STAT_BALANCE_DDREL_PERCENT);

   // --- مرحله 2: فیلترهای اولیه برای رد کردن پاس‌های ضعیف ---
   datetime startDate = 0, endDate = 0;
   if(HistoryDealsTotal() > 0)
   {
      startDate = (datetime)HistoryDealGetInteger(0, DEAL_TIME);
      endDate   = (datetime)HistoryDealGetInteger(HistoryDealsTotal() - 1, DEAL_TIME);
   }
   double duration_days = (endDate > startDate) ? double(endDate - startDate) / (24.0 * 3600.0) : 1.0;
   double required_min_trades = MathFloor((duration_days / 365.0) * InpMinTradesPerYear);
   if(required_min_trades < 5) required_min_trades = 5;

   if(total_trades < required_min_trades ||
      profit_factor < 1.0 ||
      net_profit <= 0 ||
      recovery_factor < 0.3)
   {
      Print("رد شده در فیلتر اولیه: معاملات=", total_trades, ", PF=", profit_factor, ", سود=", net_profit, ", RF=", recovery_factor);
      return 1.0; // بازگشت یک امتیاز کوچک به جای صفر
   }

   // --- مرحله 3: محاسبه معیارهای پیشرفته و سفارشی ---
   double r_squared = 0.0, sortino_ratio = 0.0;
   ProcessEquityCurve(r_squared, sortino_ratio);

   double monthly_stability_score = CalculateMonthlyProfitStats();
   double trade_quality_factor = CalculateTradeQualityFactor();
   double profit_loss_ratio = CalculateProfitLossRatio();
   double drawdown_penalty = CalculateDrawdownPenalty(max_dd_percent);

   // --- مرحله 4: فرمول نهایی امتیازدهی یکپارچه (Grand Unified Scoring Formula) ---
   // بخش 1: امتیاز پایه (سود و تعداد معاملات با تعدیل لگاریتمی)
   double base_score = MathLog(1.0 + MathMax(0, net_profit)) * MathLog(1.0 + total_trades);

   // بخش 2: فاکتورهای اصلی عملکرد و ریسک
   double core_performance_factor = recovery_factor * MathMax(0.1, sortino_ratio) * profit_loss_ratio * MathMax(0.1, r_squared);

   // بخش 3: فاکتورهای کیفیت، پایداری و واقع‌گرایی
   double quality_stability_factor = MathMax(0.1, monthly_stability_score) * MathMax(0.1, trade_quality_factor) * MathMax(0.1, win_rate_factor);
   
   // محاسبه امتیاز نهایی و مقیاس‌بندی
   double final_score = base_score * core_performance_factor * quality_stability_factor * MathMax(0.1, drawdown_penalty) * 1000.0;
   final_score = MathRound(final_score); // تبدیل به عدد صحیح

   // --- مرحله 5: چاپ نتیجه برای دیباگ و تحلیل ---
   PrintFormat("نتیجه: سود خالص=%.2f, معاملات=%d -> امتیاز نهایی: %.0f", net_profit, (int)total_trades, final_score);
   PrintFormat("   -> جزئیات: PF=%.2f, RF=%.2f, Sortino=%.2f, R²=%.3f, P/L=%.2f", profit_factor, recovery_factor, sortino_ratio, r_squared, profit_loss_ratio);
   PrintFormat("   -> کیفیت: پایداری ماهانه=%.3f, کیفیت معاملات=%.2f, WinRate=%.2f", monthly_stability_score, trade_quality_factor, win_rate_factor);
   PrintFormat("   -> ریسک: دراوداون=%.2f%%, جریمه=%.3f", max_dd_percent, drawdown_penalty);
   
   return final_score;
}
//+------------------------------------------------------------------+

//end file 10
//libery tester 
```

