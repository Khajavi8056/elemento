//+------------------------------------------------------------------+
//|                            Settings.mqh                          |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این فایل شامل تمام تنظیمات ورودی اکسپرت Elemento نسخه 1.6 است. تنظیمات به‌صورت گروه‌بندی‌شده برای کاربرپسندی تعریف شده‌اند:
// - General Settings: تنظیمات عمومی شامل مجیک نامبر پایه، درصد ریسک، حالت دیباگ، و حداکثر گپ ورود (برای جلوگیری از ورود در نوسانات شدید).
// - Ichimoku Trend Filter Settings: تنظیمات فیلتر روند ایچیموکو، با ورودی برای حداکثر تعداد کندل‌های فرصت تأیید (برای انعطاف در چک دیررس).
// - Visual Display Settings: تنظیمات نمایشگر چارت برای نمایش وضعیت روند.
// - Cleanup Settings: تنظیمات پاکسازی پایان روز (EOD) و فعال/غیرفعال کردن آن.
// - Range X Settings: تنظیمات اختصاصی برای هر رنج (1 تا 4)، شامل فعال/غیرفعال، زمان (GMT-based)، تایم‌فریم، فیلترهای رنج، تنظیمات ATR، و تایم‌فریم فیلتر روند. ورودی‌های مربوط به pending orders حذف شده‌اند، زیرا در نسخه 1.6 سفارشات پندینگ با ورود market دو مرحله‌ای جایگزین شده‌اند.
// ویژگی‌ها:
// - تمام ورودی‌ها با enum یا مقادیر محدود برای جلوگیری از خطای کاربر تعریف شده‌اند.
// - ولیدیشن ورودی‌ها در Elemento.mq5 برای اطمینان از مقادیر معقول (مثل ATR period > 0، RR_Ratio مثبت) انجام می‌شود.
// - این فایل فقط برای تعریف متغیرهای ورودی است و هیچ منطق اجرایی ندارد.
// - کامنت‌ها به فارسی برای وضوح و مستندسازی بهتر.
// تغییرات نسخه 1.6:
// - حذف ورودی‌های مربوط به pending orders و اضافه شدن تنظیمات ورود دو مرحله‌ای.
// - اضافه شدن فیلتر دیررس ایچیموکو با `InpIchimoku_MaxConfirmationCandles`.
// - پاکسازی هوشمند (soft/hard) و مدیریت زمان GMT.
// این کامنت بخشی از سند کلی نسخه 1.6 است: توصیف تمام ورودی‌ها و enumها برای پیکربندی اکسپرت، با تمرکز بر تغییرات جدید مانند ورود دو مرحله‌ای، SL متناسب، فیلتر دیررس، پاکسازی هوشمند، و مدیریت زمان GMT. پروژه ماژولار است برای نگهداری آسان.

#ifndef SETTINGS_MQH
#define SETTINGS_MQH

enum ENUM_TREND_DIRECTION
{
   TREND_BUY,       // روند صعودی
   TREND_SELL,      // روند نزولی
   TREND_NEUTRAL    // روند خنثی
};

enum ENUM_PLACEMENT_MODE
{
   PLACEMENT_ATR,    // استفاده از ATR برای محاسبه افست ورود
   PLACEMENT_PERCENT // استفاده از درصد ارتفاع رنج برای محاسبه افست ورود
};

enum ENUM_SL_MODE
{
   SL_ATR,    // استفاده از ATR برای بافر استاپ لاس
   SL_PERCENT // استفاده از درصد ارتفاع رنج برای بافر استاپ لاس
};

enum ENUM_TRAILING_MODE
{
   TRAILING_ATR,   // استفاده از ATR برای تریلینگ استاپ
   TRAILING_SIMPLE // استفاده از فاصله ثابت برای تریلینگ استاپ
};

// تنظیمات عمومی
input group "تنظیمات عمومی"
input long InpBaseMagicNumber = 123456; // مجیک نامبر پایه (برای تخصیص منحصربه‌فرد به رنج‌ها)
input double InpRiskPercent = 1.0; // درصد ریسک (0.1 تا 5.0 برای محاسبه حجم معامله)
input bool InpDebugMode = true; // حالت دیباگ (فعال برای لاگ‌گذاری بیشتر)
input int InpMaxEntryGap_Points = 50; // حداکثر گپ ورود به پوینت (برای جلوگیری از ورود در گپ‌های بزرگ)

// تنظیمات فیلتر روند ایچیموکو
input group "فیلتر روند ایچیموکو"
input bool Inp_IchimokuFilter_Enabled = true; // فعال کردن فیلتر روند ایچیموکو
input int Inp_Ichimoku_Tenkan = 9; // دوره تنکان-سن (باید مثبت باشد)
input int Inp_Ichimoku_Kijun = 26; // دوره کیجون-سن (باید مثبت باشد)
input int Inp_Ichimoku_SenkouB = 52; // دوره سنکو اسپن B (باید مثبت باشد)
input int Inp_Ichimoku_FlatThreshold_Points = 90; // آستانه تشخیص ابر فلت به پوینت
input int InpIchimoku_MaxConfirmationCandles = 3; // حداکثر تعداد کندل‌های فرصت برای تأیید فیلتر

// تنظیمات نمایشگر چارت
input group "تنظیمات نمایشگر چارت"
input bool Inp_Visual_ShowTrendStatus = true; // فعال کردن نمایش وضعیت روند
input int Inp_Visual_FontSize = 12; // اندازه فونت نمایشگر
input color Inp_Visual_FontColor_Buy = clrGreen; // رنگ متن برای روند BUY
input color Inp_Visual_FontColor_Sell = clrRed; // رنگ متن برای روند SELL
input color Inp_Visual_FontColor_Neutral = clrGray; // رنگ متن برای روند NEUTRAL
input int Inp_Visual_X_Offset = 10; // فاصله افقی از لبه چارت (پیکسل)
input int Inp_Visual_Y_Offset = 10; // فاصله عمودی از لبه چارت (پیکسل)

// تنظیمات پاکسازی پایان روز
input group "تنظیمات پاکسازی پایان روز"
input bool InpEOD_Cleanup_Enabled = true; // فعال کردن پاکسازی پایان روز (EOD)

// تنظیمات رنج ۱
input group "تنظیمات رنج 1"
input bool InpRange1_Enabled = true; // فعال کردن رنج 1
input ENUM_TIMEFRAMES InpRange1_Execution_Timeframe = PERIOD_M5; // تایم‌فریم اجرا رنج 1
input ENUM_TIMEFRAMES InpRange1_TrendFilter_Timeframe = PERIOD_H1; // تایم‌فریم فیلتر روند رنج 1
input int InpRange1_Start_Hour = 22; // ساعت شروع رنج 1 (GMT, 0-23)
input int InpRange1_Start_Minute = 0; // دقیقه شروع رنج 1 (0-59)
input int InpRange1_End_Hour = 9; // ساعت پایان رنج 1 (GMT, 0-23)
input int InpRange1_End_Minute = 30; // دقیقه پایان رنج 1 (0-59)
input int InpRange1_MinRangePoints = 200; // حداقل ارتفاع رنج 1 به پوینت
input int InpRange1_MaxRangePoints = 1500; // حداکثر ارتفاع رنج 1 به پوینت
input ENUM_PLACEMENT_MODE InpRange1_Placement_Mode = PLACEMENT_ATR; // حالت محاسبه افست ورود رنج 1
input int InpRange1_ATR_Period = 14; // دوره ATR برای افست ورود رنج 1 (استاندارد)
input double InpRange1_ATR_Multiplier = 2.0; // ضریب ATR برای افست ورود رنج 1
input ENUM_SL_MODE InpRange1_SL_Mode = SL_ATR; // حالت بافر استاپ لاس رنج 1
input int InpRange1_SL_ATR_Period = 14; // دوره ATR برای بافر استاپ لاس رنج 1
input double InpRange1_SL_ATR_Multiplier = 1.5; // ضریب ATR برای بافر استاپ لاس رنج 1
input ENUM_TRAILING_MODE InpRange1_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 1
input int InpRange1_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج 1
input double InpRange1_Trailing_ATR_Multiplier = 1.2; // ضریب ATR برای تریلینگ رنج 1
input double InpRange1_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 1
input double InpRange1_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج 1 (0-100)
input int InpRange1_Cleanup_Hours = 5; // ساعت‌های پاکسازی نرم رنج 1 (0-24)
input color InpRange1_Color = clrBlue; // رنگ مستطیل رنج 1

// تنظیمات رنج ۲
input group "تنظیمات رنج 2"
input bool InpRange2_Enabled = true; // فعال کردن رنج 2
input ENUM_TIMEFRAMES InpRange2_Execution_Timeframe = PERIOD_M15; // تایم‌فریم اجرا رنج 2
input ENUM_TIMEFRAMES InpRange2_TrendFilter_Timeframe = PERIOD_M15; // تایم‌فریم فیلتر روند رنج 2
input int InpRange2_Start_Hour = 5; // ساعت شروع رنج 2 (GMT, 0-23)
input int InpRange2_Start_Minute = 0; // دقیقه شروع رنج 2 (0-59)
input int InpRange2_End_Hour = 13; // ساعت پایان رنج 2 (GMT, 0-23)
input int InpRange2_End_Minute = 0; // دقیقه پایان رنج 2 (0-59)
input int InpRange2_MinRangePoints = 200; // حداقل ارتفاع رنج 2 به پوینت
input int InpRange2_MaxRangePoints = 3500; // حداکثر ارتفاع رنج 2 به پوینت
input ENUM_PLACEMENT_MODE InpRange2_Placement_Mode = PLACEMENT_ATR; // حالت محاسبه افست ورود رنج 2
input int InpRange2_ATR_Period = 14; // دوره ATR برای افست ورود رنج 2
input double InpRange2_ATR_Multiplier = 2.0; // ضریب ATR برای افست ورود رنج 2
input ENUM_SL_MODE InpRange2_SL_Mode = SL_ATR; // حالت بافر استاپ لاس رنج 2
input int InpRange2_SL_ATR_Period = 14; // دوره ATR برای بافر استاپ لاس رنج 2
input double InpRange2_SL_ATR_Multiplier = 1.5; // ضریب ATR برای بافر استاپ لاس رنج 2
input ENUM_TRAILING_MODE InpRange2_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 2
input int InpRange2_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج 2
input double InpRange2_Trailing_ATR_Multiplier = 1.2; // ضریب ATR برای تریلینگ رنج 2
input double InpRange2_RR_Ratio = 2.0; // نسبت R:R برای خروج پله‌ای رنج 2
input double InpRange2_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج 2 (0-100)
input int InpRange2_Cleanup_Hours = 4; // ساعت‌های پاکسازی نرم رنج 2 (0-24)
input color InpRange2_Color = clrRed; // رنگ مستطیل رنج 2

// تنظیمات رنج ۳
input group "تنظیمات رنج 3"
input bool InpRange3_Enabled = false; // فعال کردن رنج 3
input ENUM_TIMEFRAMES InpRange3_Execution_Timeframe = PERIOD_M5; // تایم‌فریم اجرا رنج 3
input ENUM_TIMEFRAMES InpRange3_TrendFilter_Timeframe = PERIOD_M30; // تایم‌فریم فیلتر روند رنج 3
input int InpRange3_Start_Hour = 15; // ساعت شروع رنج 3 (GMT, 0-23)
input int InpRange3_Start_Minute = 0; // دقیقه شروع رنج 3 (0-59)
input int InpRange3_End_Hour = 18; // ساعت پایان رنج 3 (GMT, 0-23)
input int InpRange3_End_Minute = 0; // دقیقه پایان رنج 3 (0-59)
input int InpRange3_MinRangePoints = 100; // حداقل ارتفاع رنج 3 به پوینت
input int InpRange3_MaxRangePoints = 2110; // حداکثر ارتفاع رنج 3 به پوینت
input ENUM_PLACEMENT_MODE InpRange3_Placement_Mode = PLACEMENT_ATR; // حالت محاسبه افست ورود رنج 3
input int InpRange3_ATR_Period = 14; // دوره ATR برای افست ورود رنج 3
input double InpRange3_ATR_Multiplier = 1.5; // ضریب ATR برای افست ورود رنج 3
input ENUM_SL_MODE InpRange3_SL_Mode = SL_ATR; // حالت بافر استاپ لاس رنج 3
input int InpRange3_SL_ATR_Period = 14; // دوره ATR برای بافر استاپ لاس رنج 3
input double InpRange3_SL_ATR_Multiplier = 1.5; // ضریب ATR برای بافر استاپ لاس رنج 3
input ENUM_TRAILING_MODE InpRange3_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 3
input int InpRange3_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج 3
input double InpRange3_Trailing_ATR_Multiplier = 1.0; // ضریب ATR برای تریلینگ رنج 3
input double InpRange3_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 3
input double InpRange3_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج 3 (0-100)
input int InpRange3_Cleanup_Hours = 5; // ساعت‌های پاکسازی نرم رنج 3 (0-24)
input color InpRange3_Color = clrGreen; // رنگ مستطیل رنج 3

// تنظیمات رنج ۴
input group "تنظیمات رنج 4"
input bool InpRange4_Enabled = false; // فعال کردن رنج 4
input ENUM_TIMEFRAMES InpRange4_Execution_Timeframe = PERIOD_CURRENT; // تایم‌فریم اجرا رنج 4
input ENUM_TIMEFRAMES InpRange4_TrendFilter_Timeframe = PERIOD_CURRENT; // تایم‌فریم فیلتر روند رنج 4
input int InpRange4_Start_Hour = 0; // ساعت شروع رنج 4 (GMT, 0-23)
input int InpRange4_Start_Minute = 0; // دقیقه شروع رنج 4 (0-59)
input int InpRange4_End_Hour = 0; // ساعت پایان رنج 4 (GMT, 0-23)
input int InpRange4_End_Minute = 0; // دقیقه پایان رنج 4 (0-59)
input int InpRange4_MinRangePoints = 50; // حداقل ارتفاع رنج 4 به پوینت
input int InpRange4_MaxRangePoints = 500; // حداکثر ارتفاع رنج 4 به پوینت
input ENUM_PLACEMENT_MODE InpRange4_Placement_Mode = PLACEMENT_ATR; // حالت محاسبه افست ورود رنج 4
input int InpRange4_ATR_Period = 14; // دوره ATR برای افست ورود رنج 4
input double InpRange4_ATR_Multiplier = 1.5; // ضریب ATR برای افست ورود رنج 4
input ENUM_SL_MODE InpRange4_SL_Mode = SL_ATR; // حالت بافر استاپ لاس رنج 4
input int InpRange4_SL_ATR_Period = 14; // دوره ATR برای بافر استاپ لاس رنج 4
input double InpRange4_SL_ATR_Multiplier = 1.5; // ضریب ATR برای بافر استاپ لاس رنج 4
input ENUM_TRAILING_MODE InpRange4_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 4
input int InpRange4_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج 4
input double InpRange4_Trailing_ATR_Multiplier = 1.0; // ضریب ATR برای تریلینگ رنج 4
input double InpRange4_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 4
input double InpRange4_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج 4 (0-100)
input int InpRange4_Cleanup_Hours = 5; // ساعت‌های پاکسازی نرم رنج 4 (0-24)
input color InpRange4_Color = clrYellow; // رنگ مستطیل رنج 4

#endif




//+------------------------------------------------------------------+
//|                            Elemento.mq5                          |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این فایل اصلی اکسپرت Elemento نسخه 1.6 است که نقش "رهبر ارکستر" را ایفا می‌کند. این اکسپرت بر اساس استراتژی شکست رنج‌های زمانی (Time-Range Breakout) کار می‌کند و می‌تواند تا ۴ رنج زمانی مستقل را مدیریت کند. هر رنج یک بازه زمانی مشخص دارد (مانند ۲۲:۰۰ تا ۹:۰۰ GMT) که در آن سقف و کف قیمت را شناسایی می‌کند، سطوح ورود را محاسبه و با خطوط گرافیکی نمایش می‌دهد، ورود دو مرحله‌ای (breaker candle + confirmation) را نظارت می‌کند، معاملات market را باز می‌کند، معاملات را مدیریت می‌کند (با خروج پله‌ای و تریلینگ استاپ)، و پاکسازی هوشمند (soft/hard) انجام می‌دهد.
// تغییرات کلیدی در نسخه 1.6: حذف سفارشات پندینگ برای جلوگیری از ورود عجولانه، ورود market دو مرحله‌ای با چک گپ و فیلتر ایچیموکو دیررس، استاپ لاس متناسب با سطح مخالف + بافر، پاکسازی soft (فقط جلوگیری ورود جدید) و hard (EOD/تعطیلات با بستن همه)، مدیریت زمان GMT خودکار با به‌روزرسانی دوره‌ای.
// وظایف اصلی:
// 1. مقداردهی اولیه ۴ رنج با کلاس CRange (فقط رنج‌های فعال).
// 2. در OnTick، تشخیص کندل جدید در تایم‌فریم هر رنج و فراخوانی UpdateOnNewBar، چک پاکسازی hard (EOD/تعطیلات)، و به‌روزرسانی نمایش وضعیت روند.
// 3. در OnTradeTransaction، مدیریت OCO (ریست سطح مخالف).
// 4. در OnTimer، به‌روزرسانی دوره‌ای g_gmtOffset برای DST.
// 5. مدیریت بهینه منابع: هندل‌های ATR shared، کش SymbolInfo، آزادسازی در OnDeinit، چک tester برای skip تعطیلات.
// الگوریتم کلی:
// - OnInit: کش اطلاعات سیمبل، محاسبه اولیه g_gmtOffset، ولیدیشن ورودی‌ها، ایجاد هندل ATR، مقداردهی رنج‌های فعال، مقداردهی فیلتر روند و مدیر نمایش، تنظیم OnTimer.
// - OnTick: برای هر رنج فعال، چک کندل جدید با iTime و آپدیت اگر جدید باشد، چک hard cleanup با SymbolInfoSessionTrade، و به‌روزرسانی نمایش روند.
// - OnTradeTransaction: اگر DEAL_ENTRY_IN، ریست سطح مخالف با CancelOppositePotential.
// - OnTimer: چک و به‌روزرسانی g_gmtOffset هر 4 ساعت.
// - OnDeinit: آزادسازی هندل‌ها و پاکسازی گرافیک‌ها، دفع فیلتر و مدیر نمایش.
// بهینه‌سازی‌ها: لاگ conditional با InpDebugMode، کش ATR در CRange، normalize دقیق حجم/قیمت، چک‌های امنیتی برای زمان/تعطیلات.
// اصلاحات: مدیریت GMT برای UX بهتر، پاکسازی هوشمند برای حفظ معاملات خوب، ورود دو مرحله‌ای برای فیلتر نوسانات، هماهنگی کامل با MT5 (توابع استاندارد برای همه نسخه‌ها).
// این کامنت بخشی از سند کلی نسخه 1.6 است: با کامنت‌های دیگر فایل‌ها، معماری کامل (ساختار فایل‌ها، کلاس‌ها، توابع مدیریت معاملات، ریسک، زمان، فیلتر روند، نمایش) را توصیف می‌کند. پروژه ماژولار است برای نگهداری آسان.

#property copyright "Copyright 2025, Hipoalgorithm Team"
#property link      "https://hipoalgorithm.com"
#property version   "1.60"
#property strict

// شامل کردن کتابخانه‌ها
#include "Settings.mqh"
#include "CRange.mqh"
#include "TrendFilter.mqh"
#include "VisualManager.mqh"
#include "TradeManager.mqh"
#include "TestCustomAlgo.mqh"

// آرایه برای ذخیره ۴ رنج
CRange g_ranges[4];

// آرایه برای ذخیره زمان آخرین کندل هر تایم‌فریم
datetime g_lastBarTime[4];

// آرایه برای هندل‌های ATR shared (برای جلوگیری از تکرار)
int g_atrHandles[4];

// متغیرهای کش‌شده برای بهینه‌سازی
double g_tickValue;
double g_tickSize;
double g_volumeStep;
double g_volumeMin;
double g_volumeMax;

// فلگ برای تشخیص حالت tester (برای skip چک تعطیلات در بک‌تست)
bool g_isTester = false;

// فیلتر روند جهانی (برای نمایش کلی)
CTrendFilter g_trendFilter;

// مدیر نمایش جهانی
CVisualManager g_visualManager;

// اختلاف زمانی سرور با GMT (برای مدیریت خودکار زمان)
long g_gmtOffset = 0;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   // تشخیص حالت tester برای مدیریت تعطیلات
   g_isTester = MQLInfoInteger(MQL_TESTER);

   // لاگ‌گذاری شروع مقداردهی (اگر دیباگ فعال باشد)
   if(InpDebugMode) Print("شروع مقداردهی اکسپرت Elemento نسخه 1.6...");

   // کش اطلاعات سیمبل برای بهینه‌سازی
   g_tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   g_tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   g_volumeStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   g_volumeMin = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   g_volumeMax = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

   if(g_tickValue == 0 || g_tickSize == 0 || g_volumeStep == 0)
   {
      Print("خطا در گرفتن اطلاعات سیمبل.");
      return(INIT_FAILED);
   }

   // محاسبه اولیه اختلاف GMT
   g_gmtOffset = TimeTradeServer() - TimeGMT();
   if(InpDebugMode) Print("اختلاف GMT اولیه محاسبه شد: ", g_gmtOffset, " ثانیه.");

   // تنظیم تایمر برای به‌روزرسانی دوره‌ای GMT (هر 4 ساعت)
   EventSetTimer(14400); // 4 ساعت = 14400 ثانیه

   // ولیدیشن ورودی‌های عمومی
   if(InpRiskPercent <= 0 || InpRiskPercent > 5.0)
   {
      Print("خطا: RiskPercent باید بین 0.1 تا 5.0 باشد.");
      return(INIT_PARAMETERS_INCORRECT);
   }
   if(InpMaxEntryGap_Points < 0)
   {
      Print("خطا: MaxEntryGap_Points باید مثبت باشد.");
      return(INIT_PARAMETERS_INCORRECT);
   }

   // مقداردهی ۴ رنج با تنظیمات مربوطه (فقط اگر فعال باشند)
   for(int i = 0; i < 4; i++)
   {
      // چک فعال بودن رنج
      bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;
      if(!enabled)
      {
         if(InpDebugMode) Print("رنج ", i + 1, " غیرفعال است. رد می‌شود.");
         continue;
      }

      // تخصیص مجیک نامبر منحصربه‌فرد برای هر رنج
      long magic = InpBaseMagicNumber + i;
      
      // ولیدیشن ساعات (0-23 برای ساعت، 0-59 برای دقیقه)
      int startHour = i == 0 ? InpRange1_Start_Hour : i == 1 ? InpRange2_Start_Hour : i == 2 ? InpRange3_Start_Hour : InpRange4_Start_Hour;
      int startMinute = i == 0 ? InpRange1_Start_Minute : i == 1 ? InpRange2_Start_Minute : i == 2 ? InpRange3_Start_Minute : InpRange4_Start_Minute;
      int endHour = i == 0 ? InpRange1_End_Hour : i == 1 ? InpRange2_End_Hour : i == 2 ? InpRange3_End_Hour : InpRange4_End_Hour;
      int endMinute = i == 0 ? InpRange1_End_Minute : i == 1 ? InpRange2_End_Minute : i == 2 ? InpRange3_End_Minute : InpRange4_End_Minute;
      
      if(startHour < 0 || startHour > 23 || startMinute < 0 || startMinute > 59 ||
         endHour < 0 || endHour > 23 || endMinute < 0 || endMinute > 59)
      {
         Print("خطا: ساعات یا دقیقه‌های رنج ", i + 1, " نامعتبر است.");
         return(INIT_PARAMETERS_INCORRECT);
      }

      // ایجاد هندل ATR shared
      ENUM_TIMEFRAMES timeframe = i == 0 ? InpRange1_Execution_Timeframe : i == 1 ? InpRange2_Execution_Timeframe : i == 2 ? InpRange3_Execution_Timeframe : InpRange4_Execution_Timeframe;
      int atrPeriod = i == 0 ? InpRange1_ATR_Period : i == 1 ? InpRange2_ATR_Period : i == 2 ? InpRange3_ATR_Period : InpRange4_ATR_Period;
      g_atrHandles[i] = iATR(_Symbol, timeframe, atrPeriod);
      if(g_atrHandles[i] == INVALID_HANDLE)
      {
         Print("خطا در ایجاد هندل ATR برای رنج ", i + 1);
         return(INIT_FAILED);
      }

      // مقداردهی رنج
      if(!g_ranges[i].Init(
         i + 1, // شماره رنج (1 تا 4)
         magic,
         timeframe,
         startHour,
         startMinute,
         endHour,
         endMinute,
         i == 0 ? InpRange1_MinRangePoints : i == 1 ? InpRange2_MinRangePoints : i == 2 ? InpRange3_MinRangePoints : InpRange4_MinRangePoints,
         i == 0 ? InpRange1_MaxRangePoints : i == 1 ? InpRange2_MaxRangePoints : i == 2 ? InpRange3_MaxRangePoints : InpRange4_MaxRangePoints,
         i == 0 ? InpRange1_Placement_Mode : i == 1 ? InpRange2_Placement_Mode : i == 2 ? InpRange3_Placement_Mode : InpRange4_Placement_Mode,
         atrPeriod,
         i == 0 ? InpRange1_ATR_Multiplier : i == 1 ? InpRange2_ATR_Multiplier : i == 2 ? InpRange3_ATR_Multiplier : InpRange4_ATR_Multiplier,
         i == 0 ? InpRange1_SL_Mode : i == 1 ? InpRange2_SL_Mode : i == 2 ? InpRange3_SL_Mode : InpRange4_SL_Mode,
         i == 0 ? InpRange1_SL_ATR_Period : i == 1 ? InpRange2_SL_ATR_Period : i == 2 ? InpRange3_SL_ATR_Period : InpRange4_SL_ATR_Period,
         i == 0 ? InpRange1_SL_ATR_Multiplier : i == 1 ? InpRange2_SL_ATR_Multiplier : i == 2 ? InpRange3_SL_ATR_Multiplier : InpRange4_SL_ATR_Multiplier,
         i == 0 ? InpRange1_Trailing_Mode : i == 1 ? InpRange2_Trailing_Mode : i == 2 ? InpRange3_Trailing_Mode : InpRange4_Trailing_Mode,
         i == 0 ? InpRange1_Trailing_ATR_Period : i == 1 ? InpRange2_Trailing_ATR_Period : i == 2 ? InpRange3_Trailing_ATR_Period : InpRange4_Trailing_ATR_Period,
         i == 0 ? InpRange1_Trailing_ATR_Multiplier : i == 1 ? InpRange2_Trailing_ATR_Multiplier : i == 2 ? InpRange3_Trailing_ATR_Multiplier : InpRange4_Trailing_ATR_Multiplier,
         i == 0 ? InpRange1_RR_Ratio : i == 1 ? InpRange2_RR_Ratio : i == 2 ? InpRange3_RR_Ratio : InpRange4_RR_Ratio,
         i == 0 ? InpRange1_PartialClosePercent : i == 1 ? InpRange2_PartialClosePercent : i == 2 ? InpRange3_PartialClosePercent : InpRange4_PartialClosePercent,
         i == 0 ? InpRange1_Cleanup_Hours : i == 1 ? InpRange2_Cleanup_Hours : i == 2 ? InpRange3_Cleanup_Hours : InpRange4_Cleanup_Hours,
         i == 0 ? InpRange1_Color : i == 1 ? InpRange2_Color : i == 2 ? InpRange3_Color : InpRange4_Color,
         i == 0 ? InpRange1_TrendFilter_Timeframe : i == 1 ? InpRange2_TrendFilter_Timeframe : i == 2 ? InpRange3_TrendFilter_Timeframe : InpRange4_TrendFilter_Timeframe,
         g_atrHandles[i] // هندل ATR shared
      ))
      {
         Print("خطا در مقداردهی رنج ", i + 1, ": ", GetLastError());
         return(INIT_PARAMETERS_INCORRECT);
      }
   }

   // مقداردهی فیلتر روند و مدیر نمایش
   if(!g_trendFilter.Init())
   {
      Print("خطا در مقداردهی فیلتر روند.");
      return(INIT_FAILED);
   }
   if(!g_visualManager.Init())
   {
      Print("خطا در مقداردهی مدیر نمایش.");
      return(INIT_FAILED);
   }

   // مقداردهی اولیه زمان آخرین کندل‌ها
   for(int i = 0; i < 4; i++)
   {
      g_lastBarTime[i] = 0;
   }

   Print("مقداردهی اکسپرت Elemento نسخه 1.6 با موفقیت انجام شد.");
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   // لاگ‌گذاری دفع مقداردهی (اگر دیباگ فعال باشد)
   if(InpDebugMode) Print("دفع مقداردهی اکسپرت Elemento نسخه 1.6. دلیل: ", reason);

   // آزادسازی منابع هر رنج
   for(int i = 0; i < 4; i++)
   {
      g_ranges[i].Deinit();
   }

   // آزادسازی هندل‌های ATR
   for(int i = 0; i < 4; i++)
   {
      if(g_atrHandles[i] != INVALID_HANDLE)
      {
         IndicatorRelease(g_atrHandles[i]);
      }
   }

   // دفع فیلتر روند و مدیر نمایش
   g_trendFilter.Deinit();
   g_visualManager.Deinit();

   // پاکسازی اشیاء گرافیکی
   ObjectsDeleteAll(0, "Range_");
   ObjectsDeleteAll(0, "BuyLine_");
   ObjectsDeleteAll(0, "SellLine_");
   Print("تمامی اشیاء گرافیکی پاکسازی شدند.");

   // حذف تایمر
   EventKillTimer();
}

//+------------------------------------------------------------------+
//| Timer function for periodic GMT offset update                    |
//+------------------------------------------------------------------+
void OnTimer()
{
   // به‌روزرسانی اختلاف GMT
   long newOffset = TimeTradeServer() - TimeGMT();
   if(newOffset != g_gmtOffset)
   {
      g_gmtOffset = newOffset;
      if(InpDebugMode) Print("اختلاف GMT به‌روزرسانی شد: ", g_gmtOffset, " ثانیه (تغییر DST شناسایی شد).");
   }
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   // چک پاکسازی hard (EOD/تعطیلات/آخر هفته) برای همه رنج‌ها اگر فعال باشد
   if(InpEOD_Cleanup_Enabled)
   {
      datetime currentTime = TimeTradeServer();
      // گرفتن زمان پایان جلسه معاملاتی امروز
      MqlDateTime todayStruct;
      TimeToStruct(currentTime, todayStruct);
      datetime todayStart = StructToTime(todayStruct); // شروع روز
      datetime sessionStart, sessionEnd;
      uint sessionIndex = 0;
      while(SymbolInfoSessionTrade(_Symbol, (ENUM_DAY_OF_WEEK)todayStruct.day_of_week, sessionIndex, sessionStart, sessionEnd))
      {
         sessionIndex++;
      }
      if(sessionIndex > 0)
      {
         SymbolInfoSessionTrade(_Symbol, (ENUM_DAY_OF_WEEK)todayStruct.day_of_week, sessionIndex - 1, sessionStart, sessionEnd);
         datetime cleanupTime = sessionEnd - 1800; // نیم ساعت قبل
         if(currentTime >= cleanupTime)
         {
            if(InpDebugMode) Print("پاکسازی hard (EOD) فعال شد.");
            for(int i = 0; i < 4; i++)
            {
               if(g_ranges[i].IsEnabled()) g_ranges[i].CleanupFull();
            }
         }
      }

      // چک آخر هفته یا تعطیلات آینده
      if(TimeHelper::IsNonTradingDay(currentTime + 1800)) // چک 30 دقیقه آینده
      {
         if(InpDebugMode) Print("پاکسازی hard (تعطیلات/آخر هفته) فعال شد.");
         for(int i = 0; i < 4; i++)
         {
            if(g_ranges[i].IsEnabled()) g_ranges[i].CleanupFull();
         }
      }
   }

   // بررسی کندل جدید برای هر رنج
   for(int i = 0; i < 4; i++)
   {
      // چک فعال بودن رنج
      bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;
      if(!enabled) continue;

      ENUM_TIMEFRAMES timeframe = g_ranges[i].GetTimeframe();
      datetime currentBarTime = iTime(_Symbol, timeframe, 0);
      
      // اگر کندل جدید باشد
      if(currentBarTime > g_lastBarTime[i])
      {
         if(InpDebugMode) Print("کندل جدید برای رنج ", i + 1, " در تایم‌فریم ", EnumToString(timeframe));
         g_ranges[i].UpdateOnNewBar();
         g_lastBarTime[i] = currentBarTime;
      }
   }

   // به‌روزرسانی نمایش وضعیت روند (برای یکی از تایم‌فریم‌ها، مثلاً رنج اول)
   if(InpRange1_Enabled)
   {
      ENUM_TREND_DIRECTION globalTrend = g_trendFilter.GetTrendDirection(g_ranges[0].GetTrendFilterTimeframe());
      string trendText;
      color trendColor;
      switch(globalTrend)
      {
         case TREND_BUY: trendText = "TREND BUY"; trendColor = Inp_Visual_FontColor_Buy; break;
         case TREND_SELL: trendText = "TREND SELL"; trendColor = Inp_Visual_FontColor_Sell; break;
         default: trendText = "TREND NEUTRAL"; trendColor = Inp_Visual_FontColor_Neutral; break;
      }
      g_visualManager.UpdateTrendStatus(trendText, trendColor);
   }
}

//+------------------------------------------------------------------+
//| Trade transaction function                                       |
//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction &trans,
                        const MqlTradeRequest &request,
                        const MqlTradeResult &result)
{
   // فقط برای معاملات جدید (ورود به پوزیشن)
   if(trans.type == TRADE_TRANSACTION_DEAL_ADD && trans.deal == DEAL_ENTRY_IN)
   { if(HistoryDealSelect(trans.deal))
      {
         long magic = HistoryDealGetInteger(trans.deal, DEAL_MAGIC);
     
      for(int i = 0; i < 4; i++)
      {
         if(g_ranges[i].GetMagicNumber() == magic)
         {
            if(InpDebugMode) Print("OCO فعال شد برای رنج ", i + 1, " پس از ورود معامله.");
            g_ranges[i].CancelOppositePotential();
            break;
         }
      }
   }}
}









//+------------------------------------------------------------------+
//|                            CRange.mqh                            |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این کلاس قلب سیستم Elemento نسخه 1.6 است و هر رنج زمانی مستقل (مثل آسیا یا لندن) را مدیریت می‌کند. وظایف شامل شناسایی رنج، محاسبه سطوح ورود (potential buy/sell)، رسم خطوط گرافیکی، نظارت ورود دو مرحله‌ای (breaker + confirmation با چک گپ و ایچیموکو)، باز کردن معامله market، مدیریت معامله (partial/breakeven/trailing)، و پاکسازی soft/hard است.
// تغییرات کلیدی در نسخه 1.6:
// - حذف pending orders و جایگزینی با ورود market دو مرحله‌ای (MonitorEntry).
// - SL بر اساس سطح مخالف + بافر (ATR یا درصد).
// - فیلتر ایچیموکو دیررس با فرصت N کندل.
// - پاکسازی soft (ریست سطوح/مراحل بدون بستن معاملات یا حذف گرافیک) و hard (EOD/تعطیلات با بستن همه).
// - مدیریت زمان با GMT offset.
// enumها:
// - STATE: WAITING, IDENTIFIED, MONITORING_ENTRY, TRADE_ACTIVE, EXPIRED.
// - ENTRY_STAGE: NONE, BREAKER_DETECTED, CONFIRMATION_WAITING.
// وظایف اصلی:
// - **Init**: ذخیره تنظیمات، چک هندل‌ها.
// - **UpdateOnNewBar**: سوئیچ state، چک تعطیلات (skip در tester)، Identify/Validate، MonitorEntry، Manage، Cleanup soft.
// - **IdentifyAndValidateRange**: محاسبه زمان با GMT sync، پیدا high/low، چک کیفیت، رسم rectangle، تغییر state.
// - **MonitorEntry**: نظارت breaker (close >/< potential)، confirmation (Ask/Bid >/< breaker high/low)، چک گپ، چک ایچیموکو دیررس، ورود market و OCO.
// - **OpenMarketTrade**: محاسبه SL (سطح مخالف + بافر)، lot با ریسک، PositionOpen با retry.
// - **CancelOppositePotential**: ریست سطح مخالف (بدون حذف گرافیکی).
// - **ManageActiveTrade**: partial/breakeven/trailing.
// - **Cleanup (soft)**: ریست سطوح/مراحل.
// - **CleanupFull (hard)**: بستن معاملات + حذف گرافیک.
// بهینه‌سازی‌ها:
// - cached ATR با ریست در ResetInternalVars.
// - normalize قیمت‌ها و حجم.
// - چک اسپرد و retry در OpenMarketTrade.
// - گپ با Ask/Bid جداگانه.
// - لاگ conditional و مدیریت خطاها.
// این کامنت بخشی از سند کلی نسخه 1.6 است: این کلاس هوشمندتر شده با ورود تأییدشده و پاکسازی انعطاف‌پذیر برای عملکرد بهتر در بازارهای پرنوسان.

#ifndef CRANGE_MQH
#define CRANGE_MQH

#include "Settings.mqh"
#include "TradeManager.mqh"
#include "RiskManager.mqh"
#include "TimeHelper.mqh"
#include "TrendFilter.mqh"

extern long g_gmtOffset;
extern CTrendFilter g_trendFilter;
extern double g_tickValue;
extern double g_volumeStep;
extern double g_volumeMin;
extern double g_volumeMax;

enum ENUM_RANGE_STATE
{
   STATE_WAITING,          // منتظر شروع رنج
   STATE_IDENTIFIED,       // رنج شناسایی و معتبر شده
   STATE_MONITORING_ENTRY, // نظارت بر ورود دو مرحله‌ای
   STATE_TRADE_ACTIVE,     // معامله فعال
   STATE_EXPIRED           // رنج منقضی
};

enum ENUM_ENTRY_STAGE
{
   ENTRY_NONE,               // هیچ مرحله‌ای
   ENTRY_BREAKER_DETECTED,    // کندل شکننده
   ENTRY_CONFIRMATION_WAITING // منتظر تأیید
};

class CRange
{
private:
   int m_rangeIndex;
   long m_magicNumber;
   ENUM_TIMEFRAMES m_timeframe;
   int m_startHour;
   int m_startMinute;
   int m_endHour;
   int m_endMinute;
   int m_minRangePoints;
   int m_maxRangePoints;
   ENUM_PLACEMENT_MODE m_placementMode;
   int m_atrPeriod;
   double m_atrMultiplier;
   ENUM_SL_MODE m_slMode;
   int m_slAtrPeriod;
   double m_slAtrMultiplier;
   ENUM_TRAILING_MODE m_trailingMode;
   int m_trailingAtrPeriod;
   double m_trailingAtrMultiplier;
   double m_rrRatio;
   double m_partialClosePercent;
   int m_cleanupHours;
   color m_color;
   ENUM_TIMEFRAMES m_trendFilterTimeframe;
   int m_atrHandle;

   double m_rangeHigh;
   double m_rangeLow;
   datetime m_startTime;
   datetime m_endTime;
   datetime m_cleanupTime;
   string m_objectName;
   ENUM_RANGE_STATE m_state;
   double m_cachedATR;
   ENUM_TREND_DIRECTION m_lockedTrendDirection;
   bool m_isEnabled;

   double m_potentialBuyPrice;
   double m_potentialSellPrice;
   string m_buyLineName;
   string m_sellLineName;
   datetime m_breakerTime;
   double m_breakerHigh;
   double m_breakerLow;
   ENUM_ENTRY_STAGE m_entryStage;
   ENUM_TREND_DIRECTION m_entryDirection;
   int m_confirmationCandleCount;
   bool m_trailingActivated;
   ulong m_activeTicket;

public:
   CRange() : m_state(STATE_WAITING), m_cachedATR(0), m_lockedTrendDirection(TREND_NEUTRAL), m_isEnabled(false),
              m_potentialBuyPrice(0), m_potentialSellPrice(0), m_buyLineName(""), m_sellLineName(""),
              m_breakerTime(0), m_breakerHigh(0), m_breakerLow(0), m_entryStage(ENTRY_NONE),
              m_entryDirection(TREND_NEUTRAL), m_confirmationCandleCount(0),
              m_trailingActivated(false), m_activeTicket(0) {}

   bool Init(int rangeIndex, long magic, ENUM_TIMEFRAMES timeframe,
             int startHour, int startMinute, int endHour, int endMinute,
             int minRangePoints, int maxRangePoints,
             ENUM_PLACEMENT_MODE placementMode, int atrPeriod, double atrMultiplier,
             ENUM_SL_MODE slMode, int slAtrPeriod, double slAtrMultiplier,
             ENUM_TRAILING_MODE trailingMode, int trailingAtrPeriod, double trailingAtrMultiplier,
             double rrRatio, double partialClosePercent, int cleanupHours,
             color col, ENUM_TIMEFRAMES trendFilterTimeframe, int atrHandle)
   {
      m_rangeIndex = rangeIndex;
      m_magicNumber = magic;
      m_timeframe = timeframe;
      m_startHour = startHour;
      m_startMinute = startMinute;
      m_endHour = endHour;
      m_endMinute = endMinute;
      m_minRangePoints = minRangePoints;
      m_maxRangePoints = maxRangePoints;
      m_placementMode = placementMode;
      m_atrPeriod = atrPeriod;
      m_atrMultiplier = atrMultiplier;
      m_slMode = slMode;
      m_slAtrPeriod = slAtrPeriod;
      m_slAtrMultiplier = slAtrMultiplier;
      m_trailingMode = trailingMode;
      m_trailingAtrPeriod = trailingAtrPeriod;
      m_trailingAtrMultiplier = trailingAtrMultiplier;
      m_rrRatio = rrRatio;
      m_partialClosePercent = partialClosePercent;
      m_cleanupHours = cleanupHours;
      m_color = col;
      m_trendFilterTimeframe = trendFilterTimeframe;
      m_atrHandle = atrHandle;

      if(m_atrHandle == INVALID_HANDLE)
      {
         Print("خطا: هندل ATR نامعتبر برای رنج ", m_rangeIndex);
         return false;
      }

      m_objectName = "Range_Rect_" + IntegerToString(m_rangeIndex);
      m_isEnabled = true;
      ResetInternalVars();

      if(InpDebugMode) Print("رنج ", m_rangeIndex, " مقداردهی شد.");
      return true;
   }

   void Deinit()
   {
      CleanupFull();
      if(InpDebugMode) Print("رنج ", m_rangeIndex, " دفع شد.");
   }

   void UpdateOnNewBar()
   {
      if(!g_isTester && IsMarketClosed())
      {
         if(InpDebugMode) Print("بازار بسته است برای رنج ", m_rangeIndex, ". آپدیت رد شد.");
         return;
      }

      if(TimeCurrent() >= m_cleanupTime && m_cleanupTime > 0)
      {
         Cleanup();
      }

      switch(m_state)
      {
         case STATE_WAITING:
            IdentifyAndValidateRange();
            break;
         case STATE_IDENTIFIED:
            CalculatePotentialLevels();
            m_state = STATE_MONITORING_ENTRY;
            break;
         case STATE_MONITORING_ENTRY:
            MonitorEntry();
            break;
         case STATE_TRADE_ACTIVE:
            ManageActiveTrade();
            break;
         default:
            break;
      }
   }

   void IdentifyAndValidateRange()
   {
      TimeHelper::CalculateRangeTimes(m_startTime, m_endTime, m_startHour, m_startMinute, m_endHour, m_endMinute, g_gmtOffset);

      if(TimeCurrent() < m_endTime) return;

      int startBar = iBarShift(_Symbol, m_timeframe, m_startTime);
      int endBar = iBarShift(_Symbol, m_timeframe, m_endTime);
      if(startBar < 0 || endBar < 0)
      {
         if(InpDebugMode) Print("خطا در iBarShift برای رنج ", m_rangeIndex, ": ", GetLastError());
         return;
      }

      m_rangeHigh = iHigh(_Symbol, m_timeframe, iHighest(_Symbol, m_timeframe, MODE_HIGH, startBar - endBar + 1, endBar));
      m_rangeLow = iLow(_Symbol, m_timeframe, iLowest(_Symbol, m_timeframe, MODE_LOW, startBar - endBar + 1, endBar));

      double rangeHeightPoints = (m_rangeHigh - m_rangeLow) / _Point;
      if(rangeHeightPoints < m_minRangePoints || rangeHeightPoints > m_maxRangePoints)
      {
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " نامعتبر: ارتفاع=", rangeHeightPoints, " پوینت.");
         ResetInternalVars();
         return;
      }

      ObjectCreate(0, m_objectName, OBJ_RECTANGLE, 0, m_startTime, m_rangeHigh, m_endTime, m_rangeLow);
      ObjectSetInteger(0, m_objectName, OBJPROP_COLOR, m_color);
      ObjectSetInteger(0, m_objectName, OBJPROP_STYLE, STYLE_SOLID);
      ObjectSetInteger(0, m_objectName, OBJPROP_WIDTH, 1);
      ObjectSetInteger(0, m_objectName, OBJPROP_FILL, false);

      m_cleanupTime = TimeHelper::CalculateCleanupTime(m_endTime, m_cleanupHours, g_gmtOffset);

      m_state = STATE_IDENTIFIED;
      if(InpDebugMode) Print("رنج ", m_rangeIndex, " شناسایی شد: High=", m_rangeHigh, ", Low=", m_rangeLow);
   }

   void CalculatePotentialLevels()
   {
      double offset = 0.0;
      double rangeHeight = m_rangeHigh - m_rangeLow;

      if(m_placementMode == PLACEMENT_ATR)
      {
         offset = GetCachedATR() * m_atrMultiplier;
      }
      else
      {
         offset = rangeHeight * (m_atrMultiplier / 100.0);
      }

      m_potentialBuyPrice = NormalizeDouble(m_rangeHigh + offset, _Digits);
      m_potentialSellPrice = NormalizeDouble(m_rangeLow - offset, _Digits);

      if(m_potentialBuyPrice <= 0 || m_potentialSellPrice <= 0)
      {
         if(InpDebugMode) Print("خطا: سطوح potential نامعتبر برای رنج ", m_rangeIndex);
         ResetInternalVars();
         return;
      }

      string id = IntegerToString(TimeCurrent());
      m_buyLineName = "BuyLine_Range" + IntegerToString(m_rangeIndex) + "_ID" + id;
      ObjectCreate(0, m_buyLineName, OBJ_HLINE, 0, 0, m_potentialBuyPrice);
      ObjectSetInteger(0, m_buyLineName, OBJPROP_COLOR, clrGreen);
      ObjectSetInteger(0, m_buyLineName, OBJPROP_STYLE, STYLE_DOT);
      ObjectSetInteger(0, m_buyLineName, OBJPROP_WIDTH, 2);

      m_sellLineName = "SellLine_Range" + IntegerToString(m_rangeIndex) + "_ID" + id;
      ObjectCreate(0, m_sellLineName, OBJ_HLINE, 0, 0, m_potentialSellPrice);
      ObjectSetInteger(0, m_sellLineName, OBJPROP_COLOR, clrRed);
      ObjectSetInteger(0, m_sellLineName, OBJPROP_STYLE, STYLE_DOT);
      ObjectSetInteger(0, m_sellLineName, OBJPROP_WIDTH, 2);

      if(InpDebugMode) Print("سطوح potential برای رنج ", m_rangeIndex, " محاسبه شد: Buy=", m_potentialBuyPrice, ", Sell=", m_potentialSellPrice);
   }

   void MonitorEntry()
   {
      double currentClose = iClose(_Symbol, m_timeframe, 0);
      double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);

      if(m_entryStage == ENTRY_NONE)
      {
         if(currentClose > m_potentialBuyPrice)
         {
            m_breakerHigh = iHigh(_Symbol, m_timeframe, 0);
            m_breakerLow = iLow(_Symbol, m_timeframe, 0);
            m_breakerTime = iTime(_Symbol, m_timeframe, 0);
            m_entryDirection = TREND_BUY;
            m_entryStage = ENTRY_BREAKER_DETECTED;
            m_confirmationCandleCount = 0;
            if(InpDebugMode) Print("کندل breaker BUY شناسایی شد برای رنج ", m_rangeIndex);
         }
         else if(currentClose < m_potentialSellPrice)
         {
            m_breakerHigh = iHigh(_Symbol, m_timeframe, 0);
            m_breakerLow = iLow(_Symbol, m_timeframe, 0);
            m_breakerTime = iTime(_Symbol, m_timeframe, 0);
            m_entryDirection = TREND_SELL;
            m_entryStage = ENTRY_BREAKER_DETECTED;
            m_confirmationCandleCount = 0;
            if(InpDebugMode) Print("کندل breaker SELL شناسایی شد برای رنج ", m_rangeIndex);
         }
      }
      else if(m_entryStage == ENTRY_BREAKER_DETECTED)
      {
         if(iTime(_Symbol, m_timeframe, 0) > m_breakerTime)
         {
            m_confirmationCandleCount++;
         }

         bool confirmed = false;
         double entryPrice = 0.0;
         if(m_entryDirection == TREND_BUY && ask > m_breakerHigh)
         {
            confirmed = true;
            entryPrice = ask;
         }
         else if(m_entryDirection == TREND_SELL && bid < m_breakerLow)
         {
            confirmed = true;
            entryPrice = bid;
         }

         if(confirmed)
         {
            double gapPoints = 0.0;
            if(m_entryDirection == TREND_BUY)
            {
               gapPoints = (ask - m_breakerHigh) / _Point;
            }
            else
            {
               gapPoints = (m_breakerLow - bid) / _Point;
            }

            if(gapPoints > InpMaxEntryGap_Points)
            {
               if(InpDebugMode) Print("گپ ورود بیش از حد برای رنج ", m_rangeIndex, ": ", gapPoints, " پوینت.");
               ResetEntryVars(m_entryDirection);
               return;
            }

            if(Inp_IchimokuFilter_Enabled)
            {
               ENUM_TREND_DIRECTION trend = GetTrendDirection();
               if(trend != m_entryDirection && trend != TREND_NEUTRAL)
               {
                  if(m_confirmationCandleCount >= InpIchimoku_MaxConfirmationCandles)
                  {
                     if(InpDebugMode) Print("فرصت ایچیموکو تمام شد برای رنج ", m_rangeIndex, ". سمت ", EnumToString(m_entryDirection), " ریست شد.");
                     ResetEntryVars(m_entryDirection);
                     return;
                  }
                  else
                  {
                     if(InpDebugMode) Print("ایچیموکو همسو نیست. منتظر کندل بعدی برای رنج ", m_rangeIndex);
                     return;
                  }
               }
            }

            if(OpenMarketTrade(entryPrice))
            {
               CancelOppositePotential();
               m_state = STATE_TRADE_ACTIVE;
            }
            else
            {
               ResetEntryVars(m_entryDirection);
            }
         }
      }
   }

   bool OpenMarketTrade(double entryPrice)
   {
      double sl = 0.0;
      double buffer = 0.0;
      double rangeHeight = m_rangeHigh - m_rangeLow;

      if(m_slMode == SL_ATR)
      {
         buffer = GetCachedATR(m_slAtrPeriod) * m_slAtrMultiplier;
      }
      else
      {
         buffer = rangeHeight * (m_slAtrMultiplier / 100.0);
      }

      if(m_entryDirection == TREND_BUY)
      {
         sl = NormalizeDouble(m_potentialSellPrice - buffer, _Digits);
      }
      else
      {
         sl = NormalizeDouble(m_potentialBuyPrice + buffer, _Digits);
      }

      if(sl == 0 || (m_entryDirection == TREND_BUY && sl >= entryPrice) || (m_entryDirection == TREND_SELL && sl <= entryPrice))
      {
         if(InpDebugMode) Print("خطا: SL نامعتبر برای رنج ", m_rangeIndex);
         return false;
      }

      double slPoints = MathAbs(entryPrice - sl) / _Point;
      double lot = RiskManager::CalculateLotSize(InpRiskPercent, slPoints, g_tickValue, g_volumeStep, g_volumeMin, g_volumeMax);

      if(lot <= 0)
      {
         if(InpDebugMode) Print("خطا: حجم lot نامعتبر برای رنج ", m_rangeIndex);
         return false;
      }

      ENUM_ORDER_TYPE type = (m_entryDirection == TREND_BUY) ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
      string comment = "Market Entry Range" + IntegerToString(m_rangeIndex);

      // Retry تا ۳ بار
      int retryCount = 0;
      const int maxRetries = 3;
      ulong ticket = 0;
      while(retryCount < maxRetries)
      {
         ticket = TradeManager::PositionOpen(type, lot, sl, 0, m_magicNumber, comment);
         if(ticket > 0)
         {
            m_activeTicket = ticket;
            if(InpDebugMode) Print("معامله market باز شد برای رنج ", m_rangeIndex, ": تیکت=", ticket, ", SL=", sl);
            return true;
         }
         retryCount++;
         if(InpDebugMode) Print("تلاش ", retryCount, " برای باز کردن معامله رنج ", m_rangeIndex, " ناموفق بود: ", GetLastError());
         Sleep(100); // وقفه کوتاه
      }

      Print("خطا: باز کردن معامله برای رنج ", m_rangeIndex, " پس از ", maxRetries, " تلاش ناموفق بود.");
      return false;
   }

   void CancelOppositePotential()
   {
      if(m_entryDirection == TREND_BUY)
      {
         m_potentialSellPrice = 0;
     //    if(m_sellLineName != "") ObjectDelete(0, m_sellLineName);
         m_sellLineName = "";
      }
      else
      {
         m_potentialBuyPrice = 0;
       //  if(m_buyLineName != "") ObjectDelete(0, m_buyLineName);
         m_buyLineName = "";
      }
      ResetEntryVars(TREND_NEUTRAL);
      if(InpDebugMode) Print("سطح مخالف ریست شد برای رنج ", m_rangeIndex);
   }

   void ManageActiveTrade()
   {
      if(m_activeTicket == 0)
      {
         for(int pos = PositionsTotal() - 1; pos >= 0; pos--)
         {
            if(PositionGetTicket(pos) && PositionGetInteger(POSITION_MAGIC) == m_magicNumber)
            {
               m_activeTicket = PositionGetInteger(POSITION_TICKET);
               break;
            }
         }
         if(m_activeTicket == 0) return;
      }

      if(!PositionSelectByTicket(m_activeTicket)) return;

      double currentProfit = PositionGetDouble(POSITION_PROFIT);
      double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double sl = PositionGetDouble(POSITION_SL);
      double slDistance = MathAbs(openPrice - sl) * g_tickValue;

      if(currentProfit > m_rrRatio * slDistance)
      {
         double closeVolume = PositionGetDouble(POSITION_VOLUME) * (m_partialClosePercent / 100.0);
         TradeManager::PartialClose(m_activeTicket, closeVolume);
         TradeManager::MoveSLToBreakEven(m_activeTicket, openPrice);
         m_trailingActivated = true;
      }

      if(m_trailingActivated)
      {
         TradeManager::TrailingStop(m_activeTicket, m_trailingMode, m_trailingAtrPeriod, m_trailingAtrMultiplier, m_atrHandle);
      }
   }

   void Cleanup()
   {
      ResetInternalVars();
      m_state = STATE_EXPIRED;
      if(InpDebugMode) Print("پاکسازی soft انجام شد برای رنج ", m_rangeIndex);
   }

   void CleanupFull()
   {
      if(m_activeTicket > 0)
      {
         TradeManager::ClosePosition(m_activeTicket);
         m_activeTicket = 0;
      }

      ResetInternalVars();

      ObjectDelete(0, m_objectName);
      if(m_buyLineName != "") ObjectDelete(0, m_buyLineName);
      if(m_sellLineName != "") ObjectDelete(0, m_sellLineName);

      m_state = STATE_WAITING;
      if(InpDebugMode) Print("پاکسازی hard انجام شد برای رنج ", m_rangeIndex);
   }

   void ResetInternalVars()
   {
      m_rangeHigh = 0;
      m_rangeLow = 0;
      m_startTime = 0;
      m_endTime = 0;
      m_cleanupTime = 0;
      m_cachedATR = 0; // ریست ATR
      m_lockedTrendDirection = TREND_NEUTRAL;
      m_potentialBuyPrice = 0;
      m_potentialSellPrice = 0;
      m_buyLineName = "";
      m_sellLineName = "";
      m_breakerTime = 0;
      m_breakerHigh = 0;
      m_breakerLow = 0;
      m_entryStage = ENTRY_NONE;
      m_entryDirection = TREND_NEUTRAL;
      m_confirmationCandleCount = 0;
      m_trailingActivated = false;
      m_activeTicket = 0;
   }

   void ResetEntryVars(ENUM_TREND_DIRECTION direction)
   {
      m_entryStage = ENTRY_NONE;
      m_breakerTime = 0;
      m_breakerHigh = 0;
      m_breakerLow = 0;
      m_confirmationCandleCount = 0;

      if(direction == TREND_BUY)
      {
         m_potentialBuyPrice = 0;
         if(m_buyLineName != "") ObjectDelete(0, m_buyLineName);
         m_buyLineName = "";
      }
      else if(direction == TREND_SELL)
      {
         m_potentialSellPrice = 0;
         if(m_sellLineName != "") ObjectDelete(0, m_sellLineName);
         m_sellLineName = "";
      }
   }

   double GetCachedATR(int period = 0)
   {
      if(period == 0) period = m_atrPeriod;
      if(m_cachedATR == 0)
      {
         double atrArray[1];
         if(CopyBuffer(m_atrHandle, 0, 1, 1, atrArray) != 1)
         {
            Print("خطا در CopyBuffer ATR برای رنج ", m_rangeIndex, ": ", GetLastError());
            return 0;
         }
         m_cachedATR = atrArray[0];
      }
      return m_cachedATR;
   }

   bool IsMarketClosed()
   {
      return TimeHelper::IsNonTradingDay(TimeCurrent());
   }

   ENUM_TREND_DIRECTION GetTrendDirection()
   {
      return g_trendFilter.GetTrendDirection(m_trendFilterTimeframe);
   }

   ENUM_TIMEFRAMES GetTimeframe() { return m_timeframe; }
   long GetMagicNumber() { return m_magicNumber; }
   ENUM_TIMEFRAMES GetTrendFilterTimeframe() { return m_trendFilterTimeframe; }
   bool IsEnabled() { return m_isEnabled; }
};

#endif











//+------------------------------------------------------------------+
//|                        TradeManager.mqh                          |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این کلاس عملیات معاملاتی را مدیریت می‌کند: باز کردن position market، partial close، move SL to breakeven، trailing stop، و close position.
// در نسخه 1.6، تابع PositionOpen برای ورود market اضافه شده با چک اسپرد و normalize. تمام توابع با CTrade پیاده‌سازی شده‌اند برای سازگاری با MT5.
// وظایف اصلی:
// - **PositionOpen**: ارسال درخواست market با SL/TP/magic/comment، چک اسپرد برای جلوگیری از ورود در اسپردهای بزرگ.
// - **PartialClose**: بستن بخشی از حجم پوزیشن.
// - **MoveSLToBreakEven**: جابجایی SL به قیمت باز.
// - **TrailingStop**: تریلینگ با ATR یا فاصله ثابت با لاگ دقیق خطاها.
// - **ClosePosition**: بستن کامل پوزیشن.
// بهینه‌سازی‌ها:
// - چک اسپرد قبل از ورود.
// - لاگ conditional با InpDebugMode.
// - normalize برای قیمت‌ها و حجم.
// - مدیریت خطاها با لاگ دقیق.
// این کامنت بخشی از سند کلی نسخه 1.6 است: تمرکز روی ورود market و مدیریت معاملات با دقت بالا برای استراتژی شکست رنج.

#ifndef TRADE_MANAGER_MQH
#define TRADE_MANAGER_MQH

#include <Trade\Trade.mqh>
#include "Settings.mqh"

class TradeManager
{
public:
   static ulong PositionOpen(ENUM_ORDER_TYPE type, double volume, double sl, double tp, long magic, string comment)
   {
      double spread = SymbolInfoDouble(_Symbol, SYMBOL_ASK) - SymbolInfoDouble(_Symbol, SYMBOL_BID);
      double maxSpreadPoints = 30; // حداکثر اسپرد مجاز (قابل تنظیم)
      if(spread / _Point > maxSpreadPoints)
      {
         if(InpDebugMode) Print("اسپرد بیش از حد: ", spread / _Point, " پوینت. معامله باز نشد.");
         return 0;
      }

      CTrade trade;
      trade.SetExpertMagicNumber(magic);
      trade.SetDeviationInPoints(10);

      MqlTradeRequest request = {};
      request.action = TRADE_ACTION_DEAL;
      request.symbol = _Symbol;
      request.volume = NormalizeDouble(volume, 2);
      request.type = type;
      request.sl = NormalizeDouble(sl, _Digits);
      request.tp = NormalizeDouble(tp, _Digits);
      request.deviation = 10;
      request.magic = magic;
      request.comment = comment;

      MqlTradeResult result = {};
      if(!trade.OrderSend(request, result))
      {
         Print("خطا در PositionOpen: ", trade.ResultRetcodeDescription(), ", کد خطا: ", result.retcode);
         return 0;
      }

      if(InpDebugMode) Print("Position باز شد: تیکت=", result.deal, ", حجم=", volume);
      return result.deal;
   }

   static bool PartialClose(ulong ticket, double closeVolume)
   {
      if(!PositionSelectByTicket(ticket)) return false;

      CTrade trade;
      MqlTradeRequest request = {};
      request.action = TRADE_ACTION_DEAL;
      request.position = ticket;
      request.symbol = _Symbol;
      request.volume = NormalizeDouble(closeVolume, 2);
      request.type = (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
      request.deviation = 10;

      MqlTradeResult result = {};
      if(!trade.OrderSend(request, result))
      {
         Print("خطا در PartialClose: ", trade.ResultRetcodeDescription(), ", کد خطا: ", result.retcode);
         return false;
      }

      if(InpDebugMode) Print("Partial close انجام شد برای تیکت ", ticket, ": حجم=", closeVolume);
      return true;
   }

   static bool MoveSLToBreakEven(ulong ticket, double breakEvenPrice)
   {
      if(!PositionSelectByTicket(ticket)) return false;

      CTrade trade;
      MqlTradeRequest request = {};
      request.action = TRADE_ACTION_SLTP;
      request.position = ticket;
      request.symbol = _Symbol;
      request.sl = NormalizeDouble(breakEvenPrice, _Digits);

      MqlTradeResult result = {};
      if(!trade.OrderSend(request, result))
      {
         Print("خطا در MoveSLToBreakEven: ", trade.ResultRetcodeDescription(), ", کد خطا: ", result.retcode);
         return false;
      }

      if(InpDebugMode) Print("SL به breakeven منتقل شد برای تیکت ", ticket);
      return true;
   }

   static bool TrailingStop(ulong ticket, ENUM_TRAILING_MODE mode, int atrPeriod, double multiplier, int atrHandle)
   {
      if(!PositionSelectByTicket(ticket)) return false;
      if(PositionGetDouble(POSITION_SL) == 0) return false;

      double currentSL = PositionGetDouble(POSITION_SL);
      double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);

      double trailingDistance = 0.0;
      if(mode == TRAILING_ATR)
      {
         double atrArray[1];
         if(CopyBuffer(atrHandle, 0, 1, 1, atrArray) != 1)
         {
            Print("خطا در CopyBuffer برای TrailingStop: ", GetLastError());
            return false;
         }
         trailingDistance = atrArray[0] * multiplier;
      }
      else
      {
         trailingDistance = multiplier * _Point;
      }

      double newSL = 0.0;
      if(posType == POSITION_TYPE_BUY)
      {
         newSL = NormalizeDouble(SymbolInfoDouble(_Symbol, SYMBOL_BID) - trailingDistance, _Digits);
         if(newSL <= currentSL) return false;
      }
      else
      {
         newSL = NormalizeDouble(SymbolInfoDouble(_Symbol, SYMBOL_ASK) + trailingDistance, _Digits);
         if(newSL >= currentSL) return false;
      }

      CTrade trade;
      MqlTradeRequest request = {};
      request.action = TRADE_ACTION_SLTP;
      request.position = ticket;
      request.symbol = _Symbol;
      request.sl = newSL;

      MqlTradeResult result = {};
      if(!trade.OrderSend(request, result))
      {
         Print("خطا در TrailingStop: ", trade.ResultRetcodeDescription(), ", کد خطا: ", result.retcode);
         return false;
      }

      if(InpDebugMode) Print("Trailing stop اعمال شد برای تیکت ", ticket, ": جدید SL=", newSL);
      return true;
   }

   static bool ClosePosition(ulong ticket)
   {
      if(!PositionSelectByTicket(ticket)) return false;

      CTrade trade;
      MqlTradeRequest request = {};
      request.action = TRADE_ACTION_DEAL;
      request.position = ticket;
      request.symbol = _Symbol;
      request.volume = PositionGetDouble(POSITION_VOLUME);
      request.type = (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
      request.deviation = 10;

      MqlTradeResult result = {};
      if(!trade.OrderSend(request, result))
      {
         Print("خطا در ClosePosition: ", trade.ResultRetcodeDescription(), ", کد خطا: ", result.retcode);
         return false;
      }

      if(InpDebugMode) Print("Position بسته شد: تیکت=", ticket);
      return true;
   }
};

#endif





//+------------------------------------------------------------------+
//|                        RiskManager.mqh                           |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این کلاس مدیریت ریسک را برای استراتژی شکست رنج زمانی Elemento نسخه 1.6 انجام می‌دهد. وظیفه اصلی آن محاسبه حجم معامله (lot size) بر اساس درصد ریسک، فاصله استاپ لاس (SL)، و ارزش تیک (tick value) است. فرمول محاسبه: 
// lot = (risk% * balance) / (SL_points * tickValue)
// ویژگی‌ها:
// - چک `balance` مثبت برای جلوگیری از تقسیم بر صفر.
// - نرمانایز حجم برای تطابق با `volumeStep`, `volumeMin`, `volumeMax`.
// - لاگ conditional برای دیباگ.
// اصلاحات نسخه 1.6:
// - اضافه شدن چک `balance` مثبت.
// - بهبود لاگ‌گذاری برای خطاهای محاسباتی.
// این کامنت بخشی از سند کلی نسخه 1.6 است: این کلاس با `TradeManager.mqh` همکاری می‌کند تا حجم معاملات را به‌صورت ایمن محاسبه کند، با تمرکز بر مدیریت ریسک دقیق و هماهنگی با ورود market دو مرحله‌ای.

#ifndef RISK_MANAGER_MQH
#define RISK_MANAGER_MQH

#include "Settings.mqh"

class RiskManager
{
public:
   static double CalculateLotSize(double riskPercent, double slPoints, double tickValue, double volumeStep, double volumeMin, double volumeMax)
   {
      double balance = AccountInfoDouble(ACCOUNT_BALANCE);
      if(balance <= 0)
      {
         if(InpDebugMode) Print("خطا: بالانس حساب صفر یا منفی است.");
         return 0.0;
      }

      double riskAmount = balance * (riskPercent / 100.0);
      double lot = riskAmount / (slPoints * tickValue);
      lot = MathMax(volumeMin, MathMin(volumeMax, MathFloor(lot / volumeStep) * volumeStep));

      if(lot < volumeMin)
      {
         if(InpDebugMode) Print("خطا: حجم lot کمتر از حداقل مجاز است: ", lot, " < ", volumeMin);
         return 0.0;
      }

      if(InpDebugMode) Print("محاسبه lot: riskPercent=", riskPercent, ", slPoints=", slPoints, ", lot=", lot);
      return NormalizeDouble(lot, 2);
   }
};

#endif







//+------------------------------------------------------------------+
//|                         TimeHelper.mqh                           |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این کلاس مدیریت زمان را برای استراتژی شکست رنج زمانی Elemento نسخه 1.6 انجام می‌دهد. وظایف شامل محاسبه زمان‌های رنج (start/end) با اعمال GMT offset، محاسبه زمان پاکسازی، و شناسایی روزهای غیرمعاملاتی (تعطیلات/آخر هفته) است.
// ویژگی‌ها:
// - استفاده از `TimeTradeServer` و `TimeGMT` برای محاسبه GMT offset.
// - مدیریت DST (تغییرات ساعت تابستانی) با لاگ تغییرات غیرمنتظره.
// - شناسایی روزهای غیرمعاملاتی با `SymbolInfoSessionTrade`.
// اصلاحات نسخه 1.6:
// - اضافه شدن لاگ برای اختلافات غیرمنتظره GMT offset (مثلاً تغییرات DST غیراستاندارد).
// - بهبود مدیریت خطاها در `SymbolInfoSessionTrade`.
// - رفع هشدارهای تبدیل نوع `long` به `datetime` با cast صریح و چک محدوده `g_gmtOffset`.
// این کامنت بخشی از سند کلی نسخه 1.6 است: این کلاس با `CRange.mqh` همکاری می‌کند تا زمان‌بندی دقیق رنج‌ها و پاکسازی‌ها را تضمین کند، با تمرکز بر خودکارسازی مدیریت زمان GMT.

#ifndef TIME_HELPER_MQH
#define TIME_HELPER_MQH

#include "Settings.mqh"

class TimeHelper
{
public:
   static void CalculateRangeTimes(datetime &startTime, datetime &endTime,
                                  int startHour, int startMinute,
                                  int endHour, int endMinute,
                                  long gmtOffset)
   {
      // چک محدوده g_gmtOffset (حداکثر ±14 ساعت = ±50400 ثانیه)
      if(MathAbs(gmtOffset) > 50400)
      {
         if(InpDebugMode) Print("هشدار: g_gmtOffset خارج از محدوده معقول: ", gmtOffset, " ثانیه");
         gmtOffset = MathMax(-50400, MathMin(50400, gmtOffset)); // محدود کردن به ±14 ساعت
      }

      MqlDateTime todayStruct;
      TimeToStruct(TimeCurrent(), todayStruct);

      todayStruct.hour = startHour;
      todayStruct.min = startMinute;
      todayStruct.sec = 0;
      startTime = StructToTime(todayStruct) + (datetime)gmtOffset; // cast صریح

      todayStruct.hour = endHour;
      todayStruct.min = endMinute;
      todayStruct.sec = 0;
      endTime = StructToTime(todayStruct) + (datetime)gmtOffset; // cast صریح

      if(endTime <= startTime)
      {
         endTime += 86400; // اضافه کردن یک روز
      }

      if(InpDebugMode) Print("محاسبه زمان رنج: Start=", TimeToString(startTime), ", End=", TimeToString(endTime));
   }

   static datetime CalculateCleanupTime(datetime endTime, int cleanupHours, long gmtOffset)
   {
      // چک محدوده g_gmtOffset
      if(MathAbs(gmtOffset) > 50400)
      {
         if(InpDebugMode) Print("هشدار: g_gmtOffset خارج از محدوده معقول: ", gmtOffset, " ثانیه");
         gmtOffset = MathMax(-50400, MathMin(50400, gmtOffset));
      }

      datetime cleanupTime = endTime + (datetime)(cleanupHours * 3600); // cast صریح برای محاسبه
      if(InpDebugMode) Print("محاسبه زمان پاکسازی: ", TimeToString(cleanupTime));
      return cleanupTime;
   }

   static bool IsNonTradingDay(datetime time)
   {
      MqlDateTime timeStruct;
      TimeToStruct(time, timeStruct);

      uint sessionIndex = 0;
      datetime sessionStart, sessionEnd;
      if(!SymbolInfoSessionTrade(_Symbol, (ENUM_DAY_OF_WEEK)timeStruct.day_of_week, sessionIndex, sessionStart, sessionEnd))
      {
         if(InpDebugMode) Print("روز غیرمعاملاتی شناسایی شد: ", TimeToString(time));
         return true;
      }
      return false;
   }
};

#endif





//+------------------------------------------------------------------+
//|                        TrendFilter.mqh                           |
//|                  Copyright 2025, Hipoalgorithm Team              |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این کلاس فیلتر روند ایچیموکو را برای نسخه 1.6 مدیریت می‌کند. وظیفه اصلی آن تشخیص جهت روند (BUY/SELL/NEUTRAL) بر اساس ابر آینده ایچیموکو است.
// در نسخه 1.6، منطق این فیلتر به صورت "دیررس" (Late-stage) عمل می‌کند: چک کردن روند به آخرین لحظه ممکن، یعنی درست قبل از اجرای معامله Market، موکول شده است.
// این کلاس با فرصت N کندل برای تأیید، به سیستم انعطاف‌پذیری می‌بخشد تا سیگنال‌های خوب به دلیل نویز موقت رد نشوند.
//
// وظایف اصلی:
// - Init/Deinit: توابع ساده‌ای برای مقداردهی اولیه و دفع، بدون مدیریت هندل اشتراکی.
// - GetTrendDirection: تابع کلیدی که یک هندل ایچیموکو محلی برای تایم فریم مشخص (`tf`) ایجاد می‌کند، ابر آینده (Future Kumo) را محاسبه کرده و جهت روند را برمی‌گرداند. پس از اتمام کار، هندل را آزاد می‌کند تا از نشت حافظه جلوگیری شود.
//
// بهینه‌سازی‌ها و اصلاحات نسخه 1.6:
// - **رفع باگ حیاتی:** حذف هندل اشتراکی (`m_ichimokuHandle`) و جایگزینی آن با هندل‌های محلی در `GetTrendDirection` برای جلوگیری از عدم تطابق تایم فریم محاسباتی با تایم فریم هندل.
// - **مدیریت منابع:** تضمین آزادسازی (`IndicatorRelease`) هندل در تمام مسیرهای خروجی تابع (چه در صورت موفقیت و چه در صورت خطا).
// - **لاگ‌گذاری دقیق:** ارائه لاگ‌های واضح در صورت بروز خطا در ایجاد هندل یا کپی کردن بافرها.
//
// این کامنت بخشی از سند کلی نسخه 1.6 است: این ماژول به عنوان یک فیلتر نهایی در منطق ورود دو مرحله‌ای عمل کرده و به افزایش کیفیت معاملات کمک شایانی می‌کند.

#ifndef TREND_FILTER_MQH
#define TREND_FILTER_MQH

#include "Settings.mqh"

class CTrendFilter
{
public:
    // سازنده پیش‌فرض
    CTrendFilter() {}

    // مقداردهی اولیه (در این نسخه کار خاصی انجام نمی‌دهد)
    bool Init()
    {
        if(InpDebugMode) Print("فیلتر روند ایچیموکو مقداردهی شد.");
        return true;
    }

    // دفع مقداردهی (در این نسخه کار خاصی انجام نمی‌دهد)
    void Deinit()
    {
        if(InpDebugMode) Print("فیلتر روند ایچیموکو دفع شد.");
    }

    // تابع کلیدی: گرفتن جهت روند بر اساس تایم‌فریم مشخص
    ENUM_TREND_DIRECTION GetTrendDirection(ENUM_TIMEFRAMES tf)
    {
        if(!Inp_IchimokuFilter_Enabled)
        {
            return TREND_NEUTRAL;
        }

        // 1. ایجاد هندل ایچیموکو به صورت محلی برای تایم فریم ورودی
        int ichimokuHandle = iIchimoku(_Symbol, tf, Inp_Ichimoku_Tenkan, Inp_Ichimoku_Kijun, Inp_Ichimoku_SenkouB);
        if(ichimokuHandle == INVALID_HANDLE)
        {
            Print("خطا در ایجاد هندل ایچیموکو برای تایم‌فریم ", EnumToString(tf), ". کد خطا: ", GetLastError());
            return TREND_NEUTRAL;
        }

        // 2. کپی کردن بافرهای مورد نیاز
        double tenkan[1], kijun[1];
        if(CopyBuffer(ichimokuHandle, 0, 1, 1, tenkan) != 1 || CopyBuffer(ichimokuHandle, 1, 1, 1, kijun) != 1)
        {
            Print("خطا در CopyBuffer ایچیموکو برای تایم فریم ", EnumToString(tf), ". کد خطا: ", GetLastError());
            IndicatorRelease(ichimokuHandle); // آزاد کردن هندل قبل از خروج
            return TREND_NEUTRAL;
        }

        // 3. محاسبه ابر آینده (Future Kumo)
        // Future Senkou Span A
        double futureSenkouA = (tenkan[0] + kijun[0]) / 2.0;

        // Future Senkou Span B
        int senkouB_Period = Inp_Ichimoku_SenkouB;
        double highestHigh = iHigh(_Symbol, tf, iHighest(_Symbol, tf, MODE_HIGH, senkouB_Period, 1));
        double lowestLow = iLow(_Symbol, tf, iLowest(_Symbol, tf, MODE_LOW, senkouB_Period, 1));
        double futureSenkouB = (highestHigh + lowestLow) / 2.0;

        // 4. تشخیص جهت روند
        ENUM_TREND_DIRECTION direction;
        double cloudDiffPoints = MathAbs(futureSenkouA - futureSenkouB) / _Point;

        if(cloudDiffPoints < Inp_Ichimoku_FlatThreshold_Points)
        {
            direction = TREND_NEUTRAL;
        }
        else if(futureSenkouA > futureSenkouB)
        {
            direction = TREND_BUY;
        }
        else
        {
            direction = TREND_SELL;
        }
        
        if(InpDebugMode)
        {
             Print("فیلتر ایچیموکو (", EnumToString(tf), "): SenkouA=", futureSenkouA, ", SenkouB=", futureSenkouB, " -> جهت: ", EnumToString(direction));
        }

        // 5. آزاد کردن هندل محلی
        IndicatorRelease(ichimokuHandle);

        return direction;
    }
};

#endif




//+------------------------------------------------------------------+
//|                        VisualManager.mqh                         |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این کلاس مدیر نمایش گرافیکی روی چارت است. وضعیت روند کلی (از فیلتر ایچیموکو) را با لیبل نمایش می‌دهد.
// در نسخه 1.6، بدون تغییر اصلی، اما حالا با سطوح ورود (HLINE) در CRange ادغام شده برای ویژوال بهتر.
// وظایف اصلی:
// - Init: آماده‌سازی.
// - UpdateTrendStatus: ایجاد/به‌روزرسانی لیبل با ObjectCreate/Set (بدون تکرار).
// - Deinit: حذف لیبل.
// بهینه‌سازی‌ها: چک ObjectFind برای جلوگیری تکرار، conditional log.
// این کامنت بخشی از سند کلی نسخه 1.6 است: نمایش حالا بخشی از سیستم ویژوال کلی است، با تمرکز روی روند.

#ifndef VISUAL_MANAGER_MQH
#define VISUAL_MANAGER_MQH

#include "Settings.mqh"

class CVisualManager
{
private:
   string m_labelName;  // نام لیبل وضعیت روند (ثابت: "TrendStatusLabel")

public:
   // سازنده پیش‌فرض
   CVisualManager() : m_labelName("TrendStatusLabel") {}

   // مقداردهی اولیه
   bool Init()
   {
      if(InpDebugMode) Print("مقداردهی مدیر نمایش...");
      return true;
   }

   // دفع مقداردهی (حذف لیبل)
   void Deinit()
   {
      ObjectDelete(0, m_labelName);
      if(InpDebugMode) Print("لیبل وضعیت روند حذف شد.");
   }

   // تابع کلیدی: به‌روزرسانی وضعیت روند روی چارت
   void UpdateTrendStatus(string text, color textColor)
   {
      if(!Inp_Visual_ShowTrendStatus)
      {
         if(InpDebugMode) Print("نمایش وضعیت روند خاموش است.");
         return;
      }

      if(text == "")
      {
         ObjectDelete(0, m_labelName);
         if(InpDebugMode) Print("لیبل وضعیت روند حذف شد (متن خالی).");
         return;
      }

      // چک وجود لیبل
      if(ObjectFind(0, m_labelName) < 0)
      {
         // ایجاد لیبل جدید
         if(!ObjectCreate(0, m_labelName, OBJ_LABEL, 0, 0, 0))
         {
            Print("خطا در ایجاد لیبل وضعیت روند: ", GetLastError());
            return;
         }
         ObjectSetInteger(0, m_labelName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
         ObjectSetInteger(0, m_labelName, OBJPROP_XDISTANCE, Inp_Visual_X_Offset);
         ObjectSetInteger(0, m_labelName, OBJPROP_YDISTANCE, Inp_Visual_Y_Offset);
         ObjectSetInteger(0, m_labelName, OBJPROP_FONTSIZE, Inp_Visual_FontSize);
         if(InpDebugMode) Print("لیبل وضعیت روند ایجاد شد.");
      }

      // به‌روزرسانی متن و رنگ
      ObjectSetString(0, m_labelName, OBJPROP_TEXT, text);
      ObjectSetInteger(0, m_labelName, OBJPROP_COLOR, textColor);
      if(InpDebugMode) Print("لیبل وضعیت روند به‌روزرسانی شد: متن=", text, ", رنگ=", textColor);
   }
};

#endif



