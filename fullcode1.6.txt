

```mql5
//+------------------------------------------------------------------+
//|                                                         Settings.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل نقش تعریف ساختارهای پایه‌ای و پارامترهای ورودی (inputs) اکسپرت Elemento را بر عهده دارد.
// استراتژی کلی اکسپرت: Elemento یک سیستم معاملاتی مبتنی بر شکست رنج (Breakout Range) است که بر اساس زمان‌های مشخص (رنج‌های زمانی) عمل می‌کند. این اکسپرت تا چهار رنج زمانی مختلف را تعریف می‌کند، هر رنج را بر اساس ارتفاع قیمت (High/Low) در بازه زمانی تعیین‌شده شناسایی می‌کند، سپس منتظر شکست (Breakout) سقف یا کف رنج با افست (Offset) مبتنی بر ATR یا درصد ارتفاع رنج می‌ماند. پس از شکست، با تأیید اختیاری قیمت (کندل تایید) و فیلتر روند ایچیموکو، معامله خرید یا فروش باز می‌کند. مدیریت معامله شامل استاپ لاس (SL) مبتنی بر نقطه مقابل رنج به علاوه تنظیم ATR یا درصد (برای پوشش کامل رنج و جلوگیری از زیان زودرس)، تیک پروفیت (TP) بر اساس نسبت R:R، خروج پله‌ای (Partial Close) در رسیدن به نسبت مشخص سود به ریسک، و تریلینگ استاپ (Trailing Stop) برای حفظ سود است. پاکسازی رنج‌ها پس از انقضا یا بسته شدن بازار انجام می‌شود تا از تداخل جلوگیری شود.
// منطق فایل Settings.mqh: این فایل هیچ کدی اجرایی ندارد و فقط enums و گروه‌های input را تعریف می‌کند تا کاربر بتواند پارامترها را تنظیم کند. enums برای حالت‌های مختلف (مانند PLACEMENT_MODE برای تعیین افست شکست، SL_MODE برای SL، و TRAILING_MODE برای تریلینگ) استفاده می‌شوند. گروه‌های input شامل تنظیمات عمومی (ریسک، دیباگ، تایید قیمت)، فیلتر ایچیموکو (برای جلوگیری از معاملات خلاف روند)، نمایشگر چارت (برای نشان دادن وضعیت روند)، و تنظیمات چهار رنج جداگانه (هر رنج می‌تواند تایم‌فریم، ساعات، حداقل/حداکثر ارتفاع، دوره‌های ATR، ضرایب، نسبت R:R، درصد خروج پله‌ای، ساعت پاکسازی و رنگ داشته باشد). این ساختار اجازه می‌دهد اکسپرت برای بازارهای مختلف (مانند فارکس یا شاخص‌ها) سفارشی‌سازی شود و استراتژی شکست رنج را با فیلتر روند ترکیب کند تا سیگنال‌های معتبرتری تولید شود. فایل توسط سایر فایل‌ها include می‌شود تا به inputs دسترسی داشته باشند.

#ifndef SETTINGS_MQH
#define SETTINGS_MQH

// تعریف enum برای حالت‌های مختلف قرارگیری سفارش (تعیین افست شکست رنج با ATR یا درصد ارتفاع رنج برای جلوگیری از شکست‌های کاذب)
enum ENUM_PLACEMENT_MODE
{
   PLACEMENT_ATR,    // استفاده از ATR برای محاسبه افست ثبت سفارش (پویا بر اساس نوسان بازار)
   PLACEMENT_PERCENT // استفاده از درصد ارتفاع رنج برای محاسبه افست ثبت سفارش (ثابت بر اساس اندازه رنج)
};

// تعریف enum برای حالت‌های استاپ لاس (تعیین فاصله SL با ATR یا درصد ارتفاع رنج برای مدیریت ریسک)
enum ENUM_SL_MODE
{
   SL_ATR,    // استفاده از ATR برای محاسبه فاصله استاپ لاس (پویا و تطبیقی با نوسان)
   SL_PERCENT // استفاده از درصد ارتفاع رنج برای محاسبه فاصله استاپ لاس (ثابت و ساده)
};

// تعریف enum برای حالت‌های تریلینگ استاپ (تعیین فاصله تریلینگ با ATR یا مقدار ثابت برای حفظ سود)
enum ENUM_TRAILING_MODE
{
   TRAILING_ATR,   // استفاده از ATR برای محاسبه فاصله تریلینگ استاپ (پویا)
   TRAILING_SIMPLE // استفاده از فاصله ثابت برای تریلینگ استاپ (ساده و غیرپویا)
};

// گروه ورودی برای تنظیمات عمومی (پارامترهای پایه‌ای که بر تمام رنج‌ها تأثیر می‌گذارند)
input group "تنظیمات عمومی"
input long InpBaseMagicNumber = 123456; // مجیک نامبر پایه (برای تمایز معاملات رنج‌های مختلف و جلوگیری از تداخل با دیگر اکسپرت‌ها)
input double InpRiskPercent = 1.0; // درصد ریسک (0.1 تا 5.0) - مقدار ریسک هر معامله بر اساس موجودی حساب برای کنترل زیان
input bool InpDebugMode = true; // حالت دیباگ (چاپ پیام‌های اضافی برای عیب‌یابی و نظارت بر عملکرد اکسپرت)
input int Inp_Confirmation_Timeout = 3; // مهلت تأیید قیمت و فیلتر (تعداد کندل) - حداکثر تعداد کندل برای تأیید شرایط معامله و جلوگیری از تأخیر بیش از حد
input bool Inp_PriceConfirmation_Enabled = true; // فعال کردن تأیید قیمت پس از کندل شکننده (اگر خاموش باشد، مستقیم به فیلتر روند می‌رود یا ورود)

// گروه ورودی برای فیلتر روند ایچیموکو (برای اطمینان از معامله در جهت روند یا خنثی و جلوگیری از معاملات خلاف روند)
input group "فیلتر روند ایچیموکو"
input bool Inp_IchimokuFilter_Enabled = true; // فعال کردن فیلتر روند ایچیموکو (اگر خاموش باشد، همیشه خنثی فرض می‌شود)
input int Inp_Ichimoku_Tenkan = 9; // دوره تنکان-سن (خط سریع ایچیموکو برای تشخیص روند کوتاه‌مدت)
input int Inp_Ichimoku_Kijun = 26; // دوره کیجون-سن (خط کند ایچیموکو برای تشخیص روند میان‌مدت)
input int Inp_Ichimoku_SenkouB = 52; // دوره سنکو اسپن B (ابر ایچیموکو برای تشخیص حمایت/مقاومت آینده)
input int Inp_Ichimoku_FlatThreshold_Points = 90; // آستانه تشخیص ابر فلت به پوینت (برای تعیین روند خنثی اگر تفاوت سنکو A و B کمتر باشد)

// گروه ورودی برای تنظیمات نمایشگر چارت (برای نمایش بصری وضعیت روند روی چارت به کاربر)
input group "تنظیمات نمایشگر چارت"
input bool Inp_Visual_ShowTrendStatus = true; // فعال کردن نمایش وضعیت روند (روی چارت برای نظارت بصری)
input int Inp_Visual_FontSize = 12; // اندازه فونت نمایشگر (برای خوانایی بهتر)
input color Inp_Visual_FontColor_Buy = clrGreen; // رنگ متن برای روند BUY (سبز برای مثبت)
input color Inp_Visual_FontColor_Sell = clrRed; // رنگ متن برای روند SELL (قرمز برای منفی)
input color Inp_Visual_FontColor_Neutral = clrGray; // رنگ متن برای روند NEUTRAL (خاکستری برای خنثی)
input int Inp_Visual_X_Offset = 10; // فاصله افقی از لبه چارت (پیکسل برای موقعیت مناسب)
input int Inp_Visual_Y_Offset = 10; // فاصله عمودی از لبه چارت (پیکسل برای موقعیت مناسب)

// گروه ورودی برای تنظیمات رنج ۱ (اولین رنج زمانی، معمولاً برای سشن آسیا یا شبانه)
input group "تنظیمات رنج 1"
input bool InpRange1_Enabled = true; // فعال کردن رنج 1 (اگر خاموش باشد، این رنج نادیده گرفته می‌شود)
input ENUM_TIMEFRAMES InpRange1_Execution_Timeframe = PERIOD_M5; // تایم‌فریم اجرا رنج 1 (برای اجرای منطق رنج و محاسبات)
input ENUM_TIMEFRAMES InpRange1_TrendFilter_Timeframe = PERIOD_H1; // تایم‌فریم فیلتر روند رنج 1 (برای فیلتر ایچیموکو، می‌تواند متفاوت باشد)
input int InpRange1_Start_Hour = 22; // ساعت شروع رنج 1 (0-23 برای تعریف بازه زمانی)
input int InpRange1_Start_Minute = 0; // دقیقه شروع رنج 1 (0-59 برای دقت زمانی)
input int InpRange1_End_Hour = 9; // ساعت پایان رنج 1 (0-23، اگر کمتر از شروع باشد، رنج شبانه فرض می‌شود)
input int InpRange1_End_Minute = 30; // دقیقه پایان رنج 1 (0-59)
input int InpRange1_MinRangePoints = 200; // حداقل ارتفاع رنج 1 به پوینت (برای فیلتر رنج‌های کوچک و بی‌کیفیت)
input int InpRange1_MaxRangePoints = 1500; // حداکثر ارتفاع رنج 1 به پوینت (برای فیلتر رنج‌های بزرگ و پرریسک)
input ENUM_PLACEMENT_MODE InpRange1_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 1 (افست شکست)
input int InpRange1_ATR_Period = 122; // دوره ATR برای ثبت سفارش رنج 1 (برای محاسبه افست پویا)
input double InpRange1_ATR_Multiplier = 2.3; // ضریب ATR برای ثبت سفارش رنج 1 (برای تنظیم حساسیت افست)
input ENUM_SL_MODE InpRange1_SL_Mode = SL_ATR; // حالت استاپ لاس رنج 1
input int InpRange1_SL_ATR_Period = 62; // دوره ATR برای استاپ لاس رنج 1
input double InpRange1_SL_ATR_Multiplier = 1.3; // ضریب ATR برای استاپ لاس رنج 1
input ENUM_TRAILING_MODE InpRange1_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 1
input int InpRange1_Trailing_ATR_Period = 43; // دوره ATR برای تریلینگ رنج 1
input double InpRange1_Trailing_ATR_Multiplier = 1.4; // ضریب ATR برای تریلینگ رنج 1
input double InpRange1_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 1 (سود به ریسک برای TP و خروج)
input double InpRange1_PartialClosePercent = 60.0; // درصد بستن پله‌ای رنج 1 (هنگام رسیدن به RR)
input int InpRange1_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج 1 (0-24، زمان انقضای رنج پس از پایان)
input color InpRange1_Color = clrBlue; // رنگ مستطیل رنج 1 (برای نمایش گرافیکی روی چارت)

// گروه ورودی برای تنظیمات رنج ۲ (دومین رنج، معمولاً برای سشن اروپا)
input group "تنظیمات رنج 2"
input bool InpRange2_Enabled = true; // فعال کردن رنج 2
input ENUM_TIMEFRAMES InpRange2_Execution_Timeframe = PERIOD_M15; // تایم‌فریم اجرا رنج 2
input ENUM_TIMEFRAMES InpRange2_TrendFilter_Timeframe = PERIOD_M15; // تایم‌فریم فیلتر روند رنج 2
input int InpRange2_Start_Hour = 5; // ساعت شروع رنج 2 (0-23)
input int InpRange2_Start_Minute = 0; // دقیقه شروع رنج 2 (0-59)
input int InpRange2_End_Hour = 13; // ساعت پایان رنج 2 (0-23)
input int InpRange2_End_Minute = 0; // دقیقه پایان رنج 2 (0-59)
input int InpRange2_MinRangePoints = 200; // حداقل ارتفاع رنج 2 به پوینت
input int InpRange2_MaxRangePoints = 3500; // حداکثر ارتفاع رنج 2 به پوینت
input ENUM_PLACEMENT_MODE InpRange2_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 2
input int InpRange2_ATR_Period = 27; // دوره ATR برای ثبت سفارش رنج 2
input double InpRange2_ATR_Multiplier = 2.8; // ضریب ATR برای ثبت سفارش رنج 2
input ENUM_SL_MODE InpRange2_SL_Mode = SL_ATR; // حالت استاپ لاس رنج 2
input int InpRange2_SL_ATR_Period = 86; // دوره ATR برای استاپ لاس رنج 2
input double InpRange2_SL_ATR_Multiplier = 1.56; // ضریب ATR برای استاپ لاس رنج 2
input ENUM_TRAILING_MODE InpRange2_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 2
input int InpRange2_Trailing_ATR_Period = 101; // دوره ATR برای تریلینگ رنج 2
input double InpRange2_Trailing_ATR_Multiplier = 1.58; // ضریب ATR برای تریلینگ رنج 2
input double InpRange2_RR_Ratio = 2.8; // نسبت R:R برای خروج پله‌ای رنج 2
input double InpRange2_PartialClosePercent = 26; // درصد بستن پله‌ای رنج 2
input int InpRange2_Cleanup_Hours = 4; // ساعت‌های پاکسازی رنج 2 (0-24)
input color InpRange2_Color = clrRed; // رنگ مستطیل رنج 2

// گروه ورودی برای تنظیمات رنج ۳ (سومین رنج، معمولاً برای سشن آمریکا)
input group "تنظیمات رنج 3"
input bool InpRange3_Enabled = false; // فعال کردن رنج 3
input ENUM_TIMEFRAMES InpRange3_Execution_Timeframe = PERIOD_M5; // تایم‌فریم اجرا رنج 3
input ENUM_TIMEFRAMES InpRange3_TrendFilter_Timeframe = PERIOD_M30; // تایم‌فریم فیلتر روند رنج 3
input int InpRange3_Start_Hour = 15; // ساعت شروع رنج 3 (0-23)
input int InpRange3_Start_Minute = 0; // دقیقه شروع رنج 3 (0-59)
input int InpRange3_End_Hour = 18; // ساعت پایان رنج 3 (0-23)
input int InpRange3_End_Minute = 0; // دقیقه پایان رنج 3 (0-59)
input int InpRange3_MinRangePoints = 100; // حداقل ارتفاع رنج 3 به پوینت
input int InpRange3_MaxRangePoints = 2110; // حداکثر ارتفاع رنج 3 به پوینت
input ENUM_PLACEMENT_MODE InpRange3_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 3
input int InpRange3_ATR_Period = 14; // دوره ATR برای ثبت سفارش رنج 3
input double InpRange3_ATR_Multiplier = 1.2; // ضریب ATR برای ثبت سفارش رنج 3
input ENUM_SL_MODE InpRange3_SL_Mode = SL_ATR; // حالت استاپ لاس رنج 3
input int InpRange3_SL_ATR_Period = 14; // دوره ATR برای استاپ لاس رنج 3
input double InpRange3_SL_ATR_Multiplier = 1.5; // ضریب ATR برای استاپ لاس رنج 3
input ENUM_TRAILING_MODE InpRange3_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 3
input int InpRange3_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج 3
input double InpRange3_Trailing_ATR_Multiplier = 1.0; // ضریب ATR برای تریلینگ رنج 3
input double InpRange3_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 3
input double InpRange3_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج 3
input int InpRange3_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج 3 (0-24)
input color InpRange3_Color = clrGreen; // رنگ مستطیل رنج 3

// گروه ورودی برای تنظیمات رنج ۴ (چهارمین رنج، برای سفارشی‌سازی اضافی یا تست)
input group "تنظیمات رنج 4"
input bool InpRange4_Enabled = false; // فعال کردن رنج 4
input ENUM_TIMEFRAMES InpRange4_Execution_Timeframe = PERIOD_CURRENT; // تایم‌فریم اجرا رنج 4
input ENUM_TIMEFRAMES InpRange4_TrendFilter_Timeframe = PERIOD_CURRENT; // تایم‌فریم فیلتر روند رنج 4
input int InpRange4_Start_Hour = 0; // ساعت شروع رنج 4 (0-23)
input int InpRange4_Start_Minute = 0; // دقیقه شروع رنج 4 (0-59)
input int InpRange4_End_Hour = 0; // ساعت پایان رنج 4 (0-23)
input int InpRange4_End_Minute = 0; // دقیقه پایان رنج 4 (0-59)
input int InpRange4_MinRangePoints = 50; // حداقل ارتفاع رنج 4 به پوینت
input int InpRange4_MaxRangePoints = 500; // حداکثر ارتفاع رنج 4 به پوینت
input ENUM_PLACEMENT_MODE InpRange4_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 4
input int InpRange4_ATR_Period = 14; // دوره ATR برای ثبت سفارش رنج 4
input double InpRange4_ATR_Multiplier = 1.2; // ضریب ATR برای ثبت سفارش رنج 4
input ENUM_SL_MODE InpRange4_SL_Mode = SL_ATR; // حالت استاپ لاس رنج 4
input int InpRange4_SL_ATR_Period = 14; // دوره ATR برای استاپ لاس رنج 4
input double InpRange4_SL_ATR_Multiplier = 1.5; // ضریب ATR برای استاپ لاس رنج 4
input ENUM_TRAILING_MODE InpRange4_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 4
input int InpRange4_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج 4
input double InpRange4_Trailing_ATR_Multiplier = 1.0; // ضریب ATR برای تریلینگ رنج 4
input double InpRange4_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 4
input double InpRange4_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج 4
input int InpRange4_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج 4 (0-24)
input color InpRange4_Color = clrYellow; // رنگ مستطیل رنج 4

#endif
```

```mql5
//+------------------------------------------------------------------+
//|                                                       Elemento.mq5 |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل اصلی اکسپرت Elemento است و نقطه ورود برنامه (OnInit, OnDeinit, OnTick, OnTimer) را مدیریت می‌کند.
// استراتژی کلی اکسپرت: Elemento بر اساس استراتژی شکست رنج عمل می‌کند که رنج‌های زمانی را شناسایی می‌کند، منتظر شکست با افست می‌ماند، با تایید اختیاری قیمت و فیلتر ایچیموکو تأیید می‌کند، معامله باز می‌کند و سپس با خروج پله‌ای و تریلینگ مدیریت می‌کند. این استراتژی برای بازارهای رنجی مانند سشن آسیا مناسب است و با فیلتر روند از معاملات خلاف جهت جلوگیری می‌کند تا ریسک کاهش یابد. اکسپرت از چهار رنج همزمان پشتیبانی می‌کند تا پوشش کامل بازار را فراهم کند.
// منطق فایل Elemento.mq5: این فایل هماهنگ‌کننده اصلی است. در OnInit اطلاعات نماد را کش می‌کند، ورودی‌ها را ولید می‌کند، چهار نمونه CRange را مقداردهی می‌کند، هندل‌های ATR را ایجاد می‌کند، فیلتر روند و مدیر نمایش را راه‌اندازی می‌کند. در OnDeinit تمام منابع را آزاد و پاکسازی سخت انجام می‌دهد. در OnTick کندل‌های جدید را تشخیص می‌دهد، رنج‌ها را به‌روزرسانی می‌کند، وضعیت روند را نمایش می‌دهد و در صورت بسته بودن بازار پاکسازی می‌کند. در OnTimer (هر ۶۰ ثانیه) معاملات فعال را مدیریت می‌کند تا بار OnTick کاهش یابد. متغیرهای جهانی مانند g_ranges برای نگهداری رنج‌ها، g_lastBarTime برای تشخیص کندل جدید، و g_trendFilter برای فیلتر روند استفاده می‌شوند. این فایل سایر فایل‌ها را include می‌کند تا استراتژی کامل شود.

#property copyright "Copyright 2025, Hipoalgorithm Team"
#property link      "https://hipoalgorithm.com"
#property version   "1.80" // ورژن آپدیت شده برای اعمال تغییرات جدید (اصلاح کش ATR، نمایشگر روند، مقاوم‌سازی Risk Manager)
#property strict

#include "Settings.mqh"
#include "CRange.mqh"
#include "TrendFilter.mqh"
#include "VisualManager.mqh"

// آرایه برای ذخیره ۴ رنج (هر کدام یک نمونه از کلاس CRange برای مدیریت مستقل رنج‌ها)
CRange g_ranges[4];

// آرایه برای ذخیره زمان آخرین کندل هر تایم‌فریم (برای تشخیص کندل جدید و جلوگیری از اجرای مکرر)
datetime g_lastBarTime[4];

// آرایه برای هندل‌های ATR shared (برای هر رنج یک هندل ATR برای محاسبات افست، SL و تریلینگ)
int g_atrHandles[4];

// متغیرهای کش‌شده برای بهینه‌سازی (اطلاعات نماد برای محاسبه ریسک، حجم و فاصله‌ها به طور دقیق و مستقل از نوع نماد)
double g_tickValue;
double g_tickSize;
double g_volumeStep;
double g_volumeMin;
double g_volumeMax;

// فلگ برای تشخیص حالت tester (برای رفتار متفاوت مانند نادیده گرفتن چک بازار بسته در بک‌تست)
bool g_isTester = false;

// فیلتر روند جهانی (نمونه‌ای از CTrendFilter برای استفاده مشترک در تمام رنج‌ها و تعیین جهت روند)
CTrendFilter g_trendFilter;

// مدیر نمایش جهانی (نمونه‌ای از CVisualManager برای نمایش بصری وضعیت روند روی چارت)
CVisualManager g_visualManager;

// تابع شروع اکسپرت (OnInit): مقداردهی اولیه، چک ولیدیشن و راه‌اندازی تایمر
int OnInit()
{
   g_isTester = MQLInfoInteger(MQL_TESTER); // تشخیص حالت تستر برای تنظیم رفتار خاص
   if(InpDebugMode) Print("شروع مقداردهی اکسپرت Elemento نسخه 1.80...");

   // کش اطلاعات سیمبل (نماد) برای استفاده در محاسبه ریسک، حجم و فاصله‌ها
   g_tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   g_tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   g_volumeStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   g_volumeMin = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   g_volumeMax = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

   // چک ولید بودن اطلاعات نماد (اگر صفر یا نامعتبر باشد، اکسپرت متوقف می‌شود برای جلوگیری از محاسبات اشتباه)
   if(g_tickValue <= 0 || g_tickSize <= 0 || g_volumeStep <= 0)
   {
      Print("خطای مرگبار: اطلاعات نماد نامعتبر است (tickValue/tickSize/volumeStep). اکسپرت متوقف می‌شود.");
      return(INIT_FAILED);
   }

   // ولیدیشن ورودی‌های عمومی (اطمینان از محدوده مجاز برای جلوگیری از خطاهای منطقی)
   if(InpRiskPercent <= 0 || InpRiskPercent > 5.0)
   {
      Print("خطا: RiskPercent باید بین 0.1 تا 5.0 باشد.");
      return(INIT_PARAMETERS_INCORRECT);
   }
   if(Inp_Confirmation_Timeout < 1 || Inp_Confirmation_Timeout > 10)
   {
      Print("خطا: Confirmation_Timeout باید بین 1 تا 10 باشد.");
      return(INIT_PARAMETERS_INCORRECT);
   }

   // مقداردهی ۴ رنج (برای هر رنج فعال، پارامترها را از ورودی‌ها گرفته، هندل ATR می‌سازد و Init می‌کند)
   for(int i = 0; i < 4; i++)
   {
      bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;
      if(!enabled)
      {
         if(InpDebugMode) Print("رنج ", i + 1, " غیرفعال است. رد می‌شود.");
         continue;
      }

      long magic = InpBaseMagicNumber + i; // مجیک نامبر منحصربه‌فرد برای هر رنج جهت تمایز معاملات
      int startHour = i == 0 ? InpRange1_Start_Hour : i == 1 ? InpRange2_Start_Hour : i == 2 ? InpRange3_Start_Hour : InpRange4_Start_Hour;
      int startMinute = i == 0 ? InpRange1_Start_Minute : i == 1 ? InpRange2_Start_Minute : i == 2 ? InpRange3_Start_Minute : InpRange4_Start_Minute;
      int endHour = i == 0 ? InpRange1_End_Hour : i == 1 ? InpRange2_End_Hour : i == 2 ? InpRange3_End_Hour : InpRange4_End_Hour;
      int endMinute = i == 0 ? InpRange1_End_Minute : i == 1 ? InpRange2_End_Minute : i == 2 ? InpRange3_End_Minute : InpRange4_End_Minute;

      // چک ولید بودن ساعات و دقیقه‌ها (برای جلوگیری از زمان‌های نامعتبر)
      if(startHour < 0 || startHour > 23 || startMinute < 0 || startMinute > 59 ||
         endHour < 0 || endHour > 23 || endMinute < 0 || endMinute > 59)
      {
         Print("خطا: ساعات یا دقیقه‌های رنج ", i + 1, " نامعتبر است.");
         return(INIT_PARAMETERS_INCORRECT);
      }

      ENUM_TIMEFRAMES timeframe = i == 0 ? InpRange1_Execution_Timeframe : i == 1 ? InpRange2_Execution_Timeframe : i == 2 ? InpRange3_Execution_Timeframe : InpRange4_Execution_Timeframe;
      int atrPeriod = i == 0 ? InpRange1_ATR_Period : i == 1 ? InpRange2_ATR_Period : i == 2 ? InpRange3_ATR_Period : InpRange4_ATR_Period;
      g_atrHandles[i] = iATR(_Symbol, timeframe, atrPeriod); // ایجاد هندل ATR برای محاسبات پویا
      if(g_atrHandles[i] == INVALID_HANDLE)
      {
         Print("خطا در ایجاد هندل ATR برای رنج ", i + 1);
         return(INIT_FAILED);
      }

      // فراخوانی Init برای هر رنج با پارامترهای مربوطه (مقداردهی کامل رنج)
      if(!g_ranges[i].Init(
         i + 1, magic, timeframe, startHour, startMinute, endHour, endMinute,
         i == 0 ? InpRange1_MinRangePoints : i == 1 ? InpRange2_MinRangePoints : i == 2 ? InpRange3_MinRangePoints : InpRange4_MinRangePoints,
         i == 0 ? InpRange1_MaxRangePoints : i == 1 ? InpRange2_MaxRangePoints : i == 2 ? InpRange3_MaxRangePoints : InpRange4_MaxRangePoints,
         i == 0 ? InpRange1_Placement_Mode : i == 1 ? InpRange2_Placement_Mode : i == 2 ? InpRange3_Placement_Mode : InpRange4_Placement_Mode,
         atrPeriod,
         i == 0 ? InpRange1_ATR_Multiplier : i == 1 ? InpRange2_ATR_Multiplier : i == 2 ? InpRange3_ATR_Multiplier : InpRange4_ATR_Multiplier,
         i == 0 ? InpRange1_SL_Mode : i == 1 ? InpRange2_SL_Mode : i == 2 ? InpRange3_SL_Mode : InpRange4_SL_Mode,
         i == 0 ? InpRange1_SL_ATR_Period : i == 1 ? InpRange2_SL_ATR_Period : i == 2 ? InpRange3_SL_ATR_Period : InpRange4_SL_ATR_Period,
         i == 0 ? InpRange1_SL_ATR_Multiplier : i == 1 ? InpRange2_SL_ATR_Multiplier : i == 2 ? InpRange3_SL_ATR_Multiplier : InpRange4_SL_ATR_Multiplier,
         i == 0 ? InpRange1_Trailing_Mode : i == 1 ? InpRange2_Trailing_Mode : i == 2 ? InpRange3_Trailing_Mode : InpRange4_Trailing_Mode,
         i == 0 ? InpRange1_Trailing_ATR_Period : i == 1 ? InpRange2_Trailing_ATR_Period : i == 2 ? InpRange3_Trailing_ATR_Period : InpRange4_Trailing_ATR_Period,
         i == 0 ? InpRange1_Trailing_ATR_Multiplier : i == 1 ? InpRange2_Trailing_ATR_Multiplier : i == 2 ? InpRange3_Trailing_ATR_Multiplier : InpRange4_Trailing_ATR_Multiplier,
         i == 0 ? InpRange1_RR_Ratio : i == 1 ? InpRange2_RR_Ratio : i == 2 ? InpRange3_RR_Ratio : InpRange4_RR_Ratio,
         i == 0 ? InpRange1_PartialClosePercent : i == 1 ? InpRange2_PartialClosePercent : i == 2 ? InpRange3_PartialClosePercent : InpRange4_PartialClosePercent,
         i == 0 ? InpRange1_Cleanup_Hours : i == 1 ? InpRange2_Cleanup_Hours : i == 2 ? InpRange3_Cleanup_Hours : InpRange4_Cleanup_Hours,
         i == 0 ? InpRange1_Color : i == 1 ? InpRange2_Color : i == 2 ? InpRange3_Color : InpRange4_Color,
         i == 0 ? InpRange1_TrendFilter_Timeframe : i == 1 ? InpRange2_TrendFilter_Timeframe : i == 2 ? InpRange3_TrendFilter_Timeframe : InpRange4_TrendFilter_Timeframe,
         g_atrHandles[i]
      ))
      {
         Print("خطا در مقداردهی رنج ", i + 1, ": ", GetLastError());
         return(INIT_PARAMETERS_INCORRECT);
      }
   }

   // مقداردهی فیلتر روند جهانی (برای تعیین جهت روند در تمام رنج‌ها)
   if(!g_trendFilter.Init())
   {
      Print("خطا در مقداردهی فیلتر روند.");
      return(INIT_FAILED);
   }
   // مقداردهی مدیر نمایش جهانی (برای نمایش وضعیت روند روی چارت)
   if(!g_visualManager.Init())
   {
      Print("خطا در مقداردهی مدیر نمایش.");
      return(INIT_FAILED);
   }

   // مقداردهی اولیه زمان آخرین کندل‌ها (برای تشخیص کندل جدید در OnTick)
   for(int i = 0; i < 4; i++)
   {
      g_lastBarTime[i] = 0;
   }

   // راه‌اندازی تایمر برای مدیریت معاملات هر ۶۰ ثانیه (بهینه‌سازی عملکرد OnTick)
   EventSetTimer(60);

   Print("مقداردهی اکسپرت Elemento نسخه 1.80 با موفقیت انجام شد.");
   return(INIT_SUCCEEDED);
}

// تابع پایان اکسپرت (OnDeinit): پاکسازی منابع و پاکسازی سخت تمام رنج‌ها
void OnDeinit(const int reason)
{
   if(InpDebugMode) Print("دفع مقداردهی اکسپرت Elemento نسخه 1.80. دلیل: ", reason);

   // پاکسازی سخت تمام رنج‌ها برای بستن معاملات باقی‌مانده و ریست (در صورت کرش یا خروج)
   for(int i = 0; i < 4; i++)
   {
      g_ranges[i].HardCleanup();
   }

   // دفع هر رنج و آزادسازی هندل ATR مربوطه
   for(int i = 0; i < 4; i++)
   {
      g_ranges[i].Deinit();
      if(g_atrHandles[i] != INVALID_HANDLE)
      {
         IndicatorRelease(g_atrHandles[i]);
      }
   }

   // دفع فیلتر روند و مدیر نمایش
   g_trendFilter.Deinit();
   g_visualManager.Deinit();
   ObjectsDeleteAll(0, "Range_"); // حذف تمام اشیاء گرافیکی با پیشوند Range_ برای پاکسازی چارت
   Print("تمامی اشیاء گرافیکی پاکسازی شدند.");

   // خاموش کردن تایمر
   EventKillTimer();
}

// تابع اصلی هر تیک (OnTick): تشخیص کندل جدید، به‌روزرسانی رنج‌ها و چک بازار
void OnTick()
{
   // چک لود کافی تاریخچه (برای جلوگیری از اجرای زودرس در بک‌تست تا بارگذاری کامل داده‌ها)
   if(Bars(_Symbol, _Period) < 200)
   {
      // هنوز تاریخچه کافی لود نشده، رد می‌شود تا از خطاهای داده‌ای جلوگیری شود
      return;
   }

   // چک روز جدید برای به‌روزرسانی کش اطلاعات نماد (در صورت تغییر مشخصات بروکر)
   static datetime lastDay = 0;
   datetime currentDay = TimeCurrent() / 86400;
   if(currentDay != lastDay)
   {
      // به‌روزرسانی کش اطلاعات نماد
      g_tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
      g_tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
      g_volumeStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
      g_volumeMin = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
      g_volumeMax = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
      if(InpDebugMode) Print("به‌روزرسانی کش اطلاعات نماد در روز جدید.");
      lastDay = currentDay;
   }

   // اگر تستر نیست و بازار بسته است یا یک ساعت قبل از بسته شدن، پاکسازی سخت انجام می‌شود
   if(!g_isTester && (IsMarketClosed() || IsOneHourBeforeMarketClose()))
   {
      for(int i = 0; i < 4; i++)
      {
         bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;
         if(enabled)
         {
            g_ranges[i].HardCleanup(); // پاکسازی سخت رنج (بستن معاملات و ریست برای جلوگیری از معاملات باز در تعطیلات)
         }
      }
      return;
   }

   bool newBarDetected = false; // فلگ برای تشخیص کندل جدید و به‌روزرسانی نمایش
   for(int i = 0; i < 4; i++)
   {
      bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;
      if(!enabled) continue;

      ENUM_TIMEFRAMES timeframe = g_ranges[i].GetTimeframe();
      datetime currentBarTime = iTime(_Symbol, timeframe, 0); // زمان کندل فعلی برای تشخیص جدید بودن
      if(currentBarTime == 0)
      {
         if(InpDebugMode) Print("خطا: iTime مقدار نامعتبر برای رنج ", i + 1);
         continue;
      }

      // تشخیص کندل جدید و به‌روزرسانی رنج (فقط در کندل جدید اجرا می‌شود تا بار کاهش یابد)
      if(currentBarTime > g_lastBarTime[i])
      {
         if(InpDebugMode) Print("کندل جدید برای رنج ", i + 1, " در تایم‌فریم ", EnumToString(timeframe));
         g_ranges[i].UpdateOnNewBar(); // به‌روزرسانی ماشین حالت رنج
         g_lastBarTime[i] = currentBarTime;
         newBarDetected = true;
      }

      // مدیریت معاملات به OnTimer منتقل شده، اینجا فقط چک حالت برای اطمینان
      if(enabled && g_ranges[i].GetCurrentState() == MANAGING_TRADE)
      {
         // هیچ عملی در OnTick، مدیریت در OnTimer انجام می‌شود
      }
   }

   // اگر کندل جدید تشخیص داده شده، وضعیت روند را به‌روزرسانی کن (از اولین رنج فعال استفاده شود)
   if(newBarDetected)
   {
      ENUM_TIMEFRAMES trendDisplayTimeframe = PERIOD_CURRENT;
      bool anyRangeActive = false;

      // پیدا کردن اولین رنج فعال برای نمایش روند
      for(int i = 0; i < 4; i++)
      {
         bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;
         if(enabled)
         {
            trendDisplayTimeframe = g_ranges[i].GetTrendFilterTimeframe();
            anyRangeActive = true;
            break; // پیدا شد، از حلقه خارج شو
         }
      }

      // اگر حداقل یک رنج فعال بود، نمایشگر رو آپدیت کن
      if(anyRangeActive)
      {
         ENUM_TREND_DIRECTION globalTrend = g_trendFilter.GetTrendDirection(trendDisplayTimeframe);
         string trendText;
         color trendColor;
         switch(globalTrend)
         {
            case TREND_BUY: trendText = "TREND BUY"; trendColor = Inp_Visual_FontColor_Buy; break;
            case TREND_SELL: trendText = "TREND SELL"; trendColor = Inp_Visual_FontColor_Sell; break;
            default: trendText = "TREND NEUTRAL"; trendColor = Inp_Visual_FontColor_Neutral; break;
         }
         g_visualManager.UpdateTrendStatus(trendText, trendColor); // به‌روزرسانی نمایش بصری روند
      }
   }
}

// تابع تایمر (OnTimer): مدیریت معاملات فعال هر ۶۰ ثانیه برای کاهش بار OnTick
void OnTimer()
{
   for(int i = 0; i < 4; i++)
   {
      bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;
      if(enabled && g_ranges[i].GetCurrentState() == MANAGING_TRADE)
      {
         g_ranges[i].ManageActiveTrade(); // مدیریت خروج پله‌ای، بریک‌اون و تریلینگ
      }
   }
}

// تابع چک یک ساعت قبل از بسته شدن بازار (برای فعال کردن پاکسازی سخت و جلوگیری از معاملات باز در تعطیلات)
bool IsOneHourBeforeMarketClose()
{
   datetime from = 0, to = 0;
   MqlDateTime dt;
   TimeToStruct(TimeTradeServer(), dt); // زمان سرور معامله برای دقت زمانی
   ENUM_DAY_OF_WEEK day = (ENUM_DAY_OF_WEEK)dt.day_of_week;
   datetime max_to = 0;
   uint session = 0;
   // پیدا کردن آخرین جلسه معاملاتی روز برای تعیین زمان بسته شدن
   while(SymbolInfoSessionTrade(_Symbol, day, session, from, to))
   {
      if(to > max_to) max_to = to;
      session++;
   }
   if(max_to == 0)
   {
      if(InpDebugMode) Print("خطا در SymbolInfoSessionTrade: ", GetLastError());
      return false;
   }
   datetime currentTime = TimeTradeServer();
   // چک اگر زمان فعلی یک ساعت قبل از بسته شدن باشد (برای پاکسازی پیشگیرانه)
   if(currentTime >= (max_to - 3600) && currentTime < max_to)
   {
      if(InpDebugMode) Print("یک ساعت قبل از بسته شدن بازار: پاکسازی سخت فعال شد.");
      return true;
   }
   return false;
}

// تابع چک بسته بودن بازار (برای فعال کردن پاکسازی نرم و جلوگیری از عملیات در تعطیلات)
bool IsMarketClosed()
{
   datetime from = 0, to = 0;
   MqlDateTime dt;
   TimeToStruct(TimeTradeServer(), dt);
   ENUM_DAY_OF_WEEK day = (ENUM_DAY_OF_WEEK)dt.day_of_week;
   uint session = 0;
   // چک جلسات معاملاتی روز برای تعیین وضعیت بازار
   while(SymbolInfoSessionTrade(_Symbol, day, session, from, to))
   {
      if(TimeTradeServer() >= from && TimeTradeServer() <= to)
      {
         return false; // بازار باز است، عملیات ادامه می‌یابد
      }
      session++;
   }
   // چک تعطیلات آخر هفته (شنبه و یکشنبه)
   if(dt.day_of_week == 6 || dt.day_of_week == 0)
   {
      if(InpDebugMode) Print("بازار تعطیل است (weekend).");
      return true;
   }
   if(InpDebugMode) Print("بازار تعطیل است (خارج از جلسه).");
   return true;
}
```

```mql5
//+------------------------------------------------------------------+
//|                                                         CRange.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CRange را تعریف می‌کند که هسته استراتژی شکست رنج را مدیریت می‌کند.
// استراتژی کلی اکسپرت: هر رنج زمانی (مانند سشن آسیا) را شناسایی می‌کند، سقف و کف آن را تعیین می‌کند، اگر ارتفاع معتبر باشد، با افست (بر اساس ATR یا درصد) مسلح می‌شود، منتظر کندل بریک (شکست) می‌ماند، به صورت اختیاری قیمت را تأیید می‌کند (اگر Inp_PriceConfirmation_Enabled فعال باشد)، فیلتر روند را چک می‌کند، معامله باز می‌کند، سپس معامله را با خروج پله‌ای (هنگام رسیدن به RR)، انتقال SL به ورود، و تریلینگ مدیریت می‌کند. این استراتژی برای بازارهای رنجی با شکست قوی مناسب است و با فیلتر ایچیموکو ریسک خلاف روند را کاهش می‌دهد.
// منطق فایل CRange.mqh: این کلاس برای هر رنج جداگانه عمل می‌کند. ماشین حالت (ENUM_RANGE_STATE) جریان را کنترل می‌کند: از انتظار رنج جدید شروع می‌شود، رنج را شناسایی و ولید می‌کند، مسلح می‌کند، منتظر بریک و تأییدها می‌ماند، معامله اجرا می‌کند و مدیریت می‌کند. پاکسازی نرم برای ریست روزانه و سخت برای بستن معاملات در تعطیلات استفاده می‌شود. کش ATR برای بهینه‌سازی محاسبات، و استفاده از g_trendFilter برای فیلتر. تغییرات شامل چک اضافی برای cleanupTime، بهینه جستجو تیکت، خروج پله‌ای بهبودیافته، تریلینگ با حداقل تغییر، SL با بافر minStop و بر اساس نقطه مقابل رنج (برای BUY: کف رنج - adjustment، برای SELL: سقف رنج + adjustment)، بررسی فیلتر روند در هر کندل جدید تایم‌فریم فیلتر، و مدیریت اختیاری تایید قیمت (اگر خاموش، مستقیم از بریک به فیلتر یا ورود). همچنین چک برای عدم وجود کندل در بازه رنج اضافه شده تا از خطاهای Edge Case جلوگیری شود. اصلاح کش ATR برای ثابت بودن در ورود و پویا در تریلینگ، با ریست کش در پاکسازی‌ها.

#ifndef CRANGE_MQH
#define CRANGE_MQH

#include "TradeManager.mqh"
#include "RiskManager.mqh"
#include "TimeHelper.mqh"
#include "TrendFilter.mqh"
#include <Trade\Trade.mqh>

// تعریف enum برای حالت‌های رنج (ماشین حالت برای کنترل جریان استراتژی از شناسایی تا مدیریت)
enum ENUM_RANGE_STATE
{
   RANGE_WAITING,                          // حالت انتظار برای رنج جدید (شروع روزانه)
   RANGE_IDENTIFIED,                       // رنج شناسایی و ولید شده (سقف/کف تعیین شده)
   ARMED_AND_WAITING,                      // رنج مسلح شده با افست و انتظار برای بریک (رسم خطوط خرید/فروش)
   WAITING_FOR_PRICE_CONFIRMATION_BUY,     // انتظار تأیید قیمت پس از بریک خرید (چک کلوز بالای سطح بریک)
   WAITING_FOR_PRICE_CONFIRMATION_SELL,    // انتظار تأیید قیمت پس از بریک فروش (چک کلوز پایین سطح بریک)
   WAITING_FOR_FILTER_CONFIRMATION_BUY,    // انتظار تأیید فیلتر روند برای خرید (چک ایچیموکو)
   WAITING_FOR_FILTER_CONFIRMATION_SELL,   // انتظار تأیید فیلتر روند برای فروش (چک ایچیموکو)
   EXECUTE_TRADE_BUY,                      // اجرای معامله خرید (محاسبه SL/TP/حجم و ارسال سفارش)
   EXECUTE_TRADE_SELL,                     // اجرای معامله فروش (محاسبه SL/TP/حجم و ارسال سفارش)
   MANAGING_TRADE,                         // مدیریت معامله فعال (خروج پله‌ای، بریک‌اون، تریلینگ)
   RANGE_EXPIRED                           // رنج منقضی شده (پس از پاکسازی)
};

// کلاس CRange برای مدیریت مستقل هر رنج در استراتژی شکست
class CRange
{
private:
   int m_rangeIndex;                       // شماره رنج (1 تا 4 برای تمایز)
   long m_magicNumber;                     // مجیک نامبر رنج برای شناسایی معاملات
   ENUM_TIMEFRAMES m_timeframe;            // تایم‌فریم اجرا رنج برای محاسبات بارها
   int m_startHour, m_startMinute;         // ساعت و دقیقه شروع رنج برای محاسبه زمان
   int m_endHour, m_endMinute;             // ساعت و دقیقه پایان رنج برای محاسبه زمان
   int m_minRangePoints, m_maxRangePoints; // حداقل و حداکثر ارتفاع رنج به پوینت برای فیلتر کیفیت
   ENUM_PLACEMENT_MODE m_placementMode;    // حالت افست شکست (ATR یا درصد)
   int m_atrPeriod;                        // دوره ATR برای افست
   double m_atrMultiplier;                 // ضریب ATR برای افست
   ENUM_SL_MODE m_slMode;                  // حالت SL (ATR یا درصد)
   int m_slAtrPeriod;                      // دوره ATR برای SL
   double m_slAtrMultiplier;               // ضریب ATR برای SL
   ENUM_TRAILING_MODE m_trailingMode;      // حالت تریلینگ (ATR یا ساده)
   int m_trailingAtrPeriod;                // دوره ATR برای تریلینگ
   double m_trailingAtrMultiplier;         // ضریب ATR برای تریلینگ
   double m_rrRatio;                       // نسبت R:R برای TP و خروج پله‌ای
   double m_partialClosePercent;           // درصد خروج پله‌ای هنگام رسیدن به RR
   int m_cleanupHours;                     // ساعت‌های پاکسازی پس از پایان رنج
   color m_color;                          // رنگ مستطیل رنج برای نمایش
   double m_rangeHigh, m_rangeLow;         // سقف و کف شناسایی‌شده رنج
   datetime m_cleanupTime;                 // زمان محاسبه‌شده پاکسازی
   string m_rangeObjectName;               // نام شیء گرافیکی مستطیل رنج
   ENUM_RANGE_STATE m_currentState;        // حالت فعلی ماشین حالت
   int m_atrHandle;                        // هندل ATR اصلی برای افست
   int m_slAtrHandle;                      // هندل ATR برای SL
   int m_trailingAtrHandle;                // هندل ATR برای تریلینگ
   bool m_trailingActivated;               // فلگ فعال شدن تریلینگ پس از خروج پله‌ای
   ulong m_activeTicket;                   // تیکت معامله فعال برای مدیریت
   double m_cachedATR;                     // کش ATR اصلی برای بهینه‌سازی (فقط برای ورود ثابت استفاده شود)
   double m_cachedSlATR;                   // کش ATR برای SL (فقط برای ورود ثابت استفاده شود)
   double m_cachedTrailingATR;             // کش ATR برای تریلینگ (فقط برای ورود ثابت استفاده شود، برای مدیریت پویا استفاده نشود)
   ENUM_TIMEFRAMES m_trendFilterTimeframe; // تایم‌فریم فیلتر روند برای ایچیموکو
   double m_potentialBuyPrice;             // قیمت افست خرید برای بریک
   double m_potentialSellPrice;            // قیمت افست فروش برای بریک
   double m_breakerCandleLevel;            // سطح High/Low کندل بریک برای تأیید
   int m_waitCounter;                      // شمارنده تایم‌اوت برای تأییدها
   string m_buyLineName;                   // نام خط گرافیکی خرید
   string m_sellLineName;                  // نام خط گرافیکی فروش
   datetime m_lastEndTime;                 // زمان پایان آخرین رنج برای جلوگیری از تکرار
   bool m_lastInvalid;                     // فلگ نامعتبر بودن آخرین رنج برای skip
   datetime m_lastFilterBarTime;           // زمان آخرین کندل در تایم‌فریم فیلتر برای تشخیص کندل جدید

public:
   // سازنده پیش‌فرض: مقداردهی اولیه تمام متغیرها به مقادیر پیش‌فرض برای جلوگیری از خطاهای دسترسی
   CRange() : m_rangeIndex(0), m_magicNumber(0), m_timeframe(PERIOD_H1),
              m_startHour(0), m_startMinute(0), m_endHour(0), m_endMinute(0),
              m_minRangePoints(0), m_maxRangePoints(0), m_placementMode(PLACEMENT_ATR),
              m_atrPeriod(14), m_atrMultiplier(1.2), m_slMode(SL_ATR),
              m_slAtrPeriod(14), m_slAtrMultiplier(1.5), m_trailingMode(TRAILING_ATR),
              m_trailingAtrPeriod(14), m_trailingAtrMultiplier(1.0),
              m_rrRatio(1.5), m_partialClosePercent(50.0), m_cleanupHours(5),
              m_color(clrBlue), m_rangeHigh(0), m_rangeLow(0), m_cleanupTime(0),
              m_currentState(RANGE_WAITING), m_atrHandle(INVALID_HANDLE),
              m_slAtrHandle(INVALID_HANDLE), m_trailingAtrHandle(INVALID_HANDLE),
              m_trailingActivated(false), m_activeTicket(0), m_cachedATR(0),
              m_cachedSlATR(0), m_cachedTrailingATR(0),
              m_trendFilterTimeframe(PERIOD_H4),
              m_potentialBuyPrice(0), m_potentialSellPrice(0), m_breakerCandleLevel(0),
              m_waitCounter(0), m_buyLineName(""), m_sellLineName(""),
              m_lastEndTime(0), m_lastInvalid(false), m_lastFilterBarTime(0) {}

   // تابع مقداردهی رنج: ذخیره پارامترها، ایجاد هندل‌های ATR و نام‌گذاری اشیاء گرافیکی
   bool Init(
      int rangeIndex, long magicNumber, ENUM_TIMEFRAMES timeframe,
      int startHour, int startMinute, int endHour, int endMinute,
      int minRangePoints, int maxRangePoints, ENUM_PLACEMENT_MODE placementMode,
      int atrPeriod, double atrMultiplier, ENUM_SL_MODE slMode,
      int slAtrPeriod, double slAtrMultiplier, ENUM_TRAILING_MODE trailingMode,
      int trailingAtrPeriod, double trailingAtrMultiplier, double rrRatio,
      double partialClosePercent, int cleanupHours, color rangeColor,
      ENUM_TIMEFRAMES trendFilterTimeframe, int atrHandle)
   {
      if(InpDebugMode) Print("مقداردهی رنج ", rangeIndex, " نسخه 1.80...");
      m_rangeIndex = rangeIndex;
      m_magicNumber = magicNumber;
      m_timeframe = timeframe;
      m_startHour = startHour;
      m_startMinute = startMinute;
      m_endHour = endHour;
      m_endMinute = endMinute;
      m_minRangePoints = minRangePoints;
      m_maxRangePoints = maxRangePoints;
      m_placementMode = placementMode;
      m_atrPeriod = atrPeriod;
      m_atrMultiplier = atrMultiplier;
      m_slMode = slMode;
      m_slAtrPeriod = slAtrPeriod;
      m_slAtrMultiplier = slAtrMultiplier;
      m_trailingMode = trailingMode;
      m_trailingAtrPeriod = trailingAtrPeriod;
      m_trailingAtrMultiplier = trailingAtrMultiplier;
      m_rrRatio = rrRatio;
      m_partialClosePercent = partialClosePercent;
      m_cleanupHours = cleanupHours;
      m_color = rangeColor;
      m_trendFilterTimeframe = trendFilterTimeframe;
      m_atrHandle = atrHandle;

      if(m_atrHandle == INVALID_HANDLE)
      {
         Print("خطا در هندل ATR برای رنج ", rangeIndex);
         return false;
      }

      // ایجاد هندل ATR برای SL اگر حالت مربوطه فعال باشد
      if(m_slMode == SL_ATR)
      {
         m_slAtrHandle = iATR(_Symbol, m_timeframe, m_slAtrPeriod);
         if(m_slAtrHandle == INVALID_HANDLE)
         {
            Print("خطا در ایجاد هندل ATR برای SL رنج ", rangeIndex);
            return false;
         }
      }

      // ایجاد هندل ATR برای تریلینگ اگر حالت مربوطه فعال باشد
      if(m_trailingMode == TRAILING_ATR)
      {
         m_trailingAtrHandle = iATR(_Symbol, m_timeframe, m_trailingAtrPeriod);
         if(m_trailingAtrHandle == INVALID_HANDLE)
         {
            Print("خطا در ایجاد هندل ATR برای تریلینگ رنج ", rangeIndex);
            return false;
         }
      }

      // نام‌گذاری منحصربه‌فرد اشیاء گرافیکی برای جلوگیری از تداخل
      m_rangeObjectName = "Range_" + IntegerToString(rangeIndex) + "_" + TimeToString(TimeCurrent(), TIME_DATE|TIME_MINUTES);
      m_buyLineName = "BuyLine_" + IntegerToString(rangeIndex);
      m_sellLineName = "SellLine_" + IntegerToString(rangeIndex);
      if(InpDebugMode) Print("رنج ", rangeIndex, " با موفقیت مقداردهی شد.");
      return true;
   }

   // تابع دفع رنج: حذف اشیاء گرافیکی و آزادسازی تمام هندل‌های ATR
   void Deinit()
   {
      ObjectDelete(0, m_rangeObjectName);
      ObjectDelete(0, m_buyLineName);
      ObjectDelete(0, m_sellLineName);
      if(InpDebugMode) Print("اشیاء گرافیکی رنج ", m_rangeIndex, " حذف شدند.");

      if(m_slAtrHandle != INVALID_HANDLE)
      {
         IndicatorRelease(m_slAtrHandle);
      }
      if(m_trailingAtrHandle != INVALID_HANDLE)
      {
         IndicatorRelease(m_trailingAtrHandle);
      }
   }

   // تابع به‌روزرسانی در کندل جدید: مدیریت ماشین حالت با چک اضافی برای انقضا
   void UpdateOnNewBar()
   {
      if(InpDebugMode) Print("به‌روزرسانی رنج ", m_rangeIndex, " در حالت ", EnumToString(m_currentState));

      // اگر تستر نیست و بازار بسته است، پاکسازی نرم برای ریست روزانه
      if(!g_isTester && IsMarketClosed())
      {
         SoftCleanup();
         return;
      }

      // چک اضافی برای انقضای رنج (اگر زمان گذشته باشد، مستقیم به پاکسازی)
      if(TimeCurrent() > m_cleanupTime && m_cleanupTime != 0 && m_currentState != MANAGING_TRADE)
      {
         SoftCleanup();
         return;
      }

      // سوئیچ بر اساس حالت فعلی برای اجرای گام‌به‌گام استراتژی
      switch(m_currentState)
      {
         case RANGE_WAITING:
            IdentifyAndValidateRange(); // شناسایی سقف/کف و چک کیفیت رنج
            break;
         case RANGE_IDENTIFIED:
            ArmAndWait(); // محاسبه افست و رسم خطوط برای مسلح کردن
            break;
         case ARMED_AND_WAITING:
            WaitForBreakerCandle(); // چک کلوز بالای/پایین افست برای تشخیص بریک
            break;
         case WAITING_FOR_PRICE_CONFIRMATION_BUY:
         case WAITING_FOR_PRICE_CONFIRMATION_SELL:
            WaitForPriceConfirmation(); // تأیید کلوز بعدی برای جلوگیری از شکست کاذب
            break;
         case WAITING_FOR_FILTER_CONFIRMATION_BUY:
         case WAITING_FOR_FILTER_CONFIRMATION_SELL:
            WaitForFilterConfirmation(); // چک جهت روند با ایچیموکو
            break;
         case EXECUTE_TRADE_BUY:
         case EXECUTE_TRADE_SELL:
            ExecuteTrade(); // محاسبه SL/TP/حجم و ارسال سفارش بازار
            break;
         case RANGE_EXPIRED:
            SoftCleanup(); // ریست برای رنج بعدی
            break;
      }

      // چک زمان پاکسازی استاندارد (اگر > نباشد، >= برای پوشش دقیق)
      if(TimeCurrent() >= m_cleanupTime && m_cleanupTime != 0 && m_currentState != MANAGING_TRADE)
      {
         SoftCleanup();
      }
   }

   // گترها برای دسترسی به خصوصیات رنج از فایل اصلی
   long GetMagicNumber() { return m_magicNumber; }
   ENUM_TIMEFRAMES GetTimeframe() { return m_timeframe; }
   ENUM_TIMEFRAMES GetTrendFilterTimeframe() { return m_trendFilterTimeframe; }
   ENUM_RANGE_STATE GetCurrentState() { return m_currentState; }

   // پاکسازی سخت: بستن معامله فعال و ریست کامل متغیرها برای شرایط اضطراری
   void HardCleanup()
   {
      if(InpDebugMode) Print("پاکسازی سخت رنج ", m_rangeIndex, "...");

      if(m_activeTicket != 0 && PositionSelectByTicket(m_activeTicket))
      {
         if(CTradeManager::ClosePosition(m_activeTicket))
         {
            if(InpDebugMode) Print("پوزیشن با تیکت ", m_activeTicket, " برای رنج ", m_rangeIndex, " بسته شد.");
         }
      }

      m_activeTicket = 0;
      m_trailingActivated = false;
      m_potentialBuyPrice = 0;
      m_potentialSellPrice = 0;
      m_breakerCandleLevel = 0;
      m_waitCounter = 0;
      m_rangeHigh = 0;
      m_rangeLow = 0;
      m_cleanupTime = 0;
      ResetCaches(); // ریست کش‌ها برای جلوگیری از استفاده از داده‌های کهنه
      ObjectDelete(0, m_buyLineName);
      ObjectDelete(0, m_sellLineName);
      ObjectDelete(0, m_rangeObjectName);
      m_lastEndTime = 0;
      m_lastInvalid = false;

      m_currentState = RANGE_WAITING;
      if(InpDebugMode) Print("رنج ", m_rangeIndex, " کاملاً پاکسازی شد (سخت).");
   }

   // مدیریت معامله فعال: جستجو تیکت، خروج پله‌ای بهبودیافته، بریک‌اون و تریلینگ با حداقل تغییر
   void ManageActiveTrade()
   {
      if(InpDebugMode) Print("مدیریت معامله برای رنج ", m_rangeIndex, "...");

      // جستجو بهینه تیکت فعال با چک Magic برای جلوگیری از تداخل
      if(m_activeTicket == 0 || !PositionSelectByTicket(m_activeTicket) || PositionGetInteger(POSITION_MAGIC) != m_magicNumber)
      {
         m_activeTicket = 0;
         for(int i = PositionsTotal() - 1; i >= 0; i--)
         {
            ulong ticket = PositionGetTicket(i);
            if(PositionGetInteger(POSITION_MAGIC) == m_magicNumber)
            {
               m_activeTicket = ticket;
               break;
            }
         }
      }

      if(m_activeTicket == 0)
      {
         if(InpDebugMode) Print("هیچ معامله فعالی برای رنج ", m_rangeIndex, " یافت نشد.");
         m_currentState = RANGE_WAITING;
         SoftCleanup();
         return;
      }

      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      double currentPrice = posType == POSITION_TYPE_BUY ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double sl = PositionGetDouble(POSITION_SL);
      double volume = PositionGetDouble(POSITION_VOLUME);
      double slDistance = MathAbs(openPrice - sl);

      double currentProfit = MathAbs(currentPrice - openPrice);

      // اگر تریلینگ فعال نشده، چک خروج پله‌ای با شرط اضافی برای حجم کوچک
      if(!m_trailingActivated)
      {
         double targetDistance = slDistance * m_rrRatio;
         if(currentProfit >= targetDistance)
         {
            double partialVolume = volume * m_partialClosePercent / 100.0;
            double closeVolume = MathRound(partialVolume / g_volumeStep) * g_volumeStep;

            // اگر closeVolume < g_volumeMin اما سود رسیده، کل را ببند برای جلوگیری از گیر کردن
            if(closeVolume < g_volumeMin)
            {
               if(InpDebugMode) Print("حجم محاسبه شده برای خروج پله‌ای (", closeVolume, ") کمتر از حداقل مجاز (", g_volumeMin, ") است. رنج ", m_rangeIndex);
               closeVolume = volume; // بستن کامل اگر جزئی ممکن نیست
            }

            double remainingVolume = volume - closeVolume;

            // اگر حجم باقی‌مانده کمتر از حداقل است، کل پوزیشن را ببند
            if(remainingVolume < g_volumeMin && remainingVolume > 0)
            {
               closeVolume = volume;
               if(InpDebugMode) Print("حجم باقی‌مانده کمتر از حداقل بود. کل پوزیشن بسته می‌شود. رنج ", m_rangeIndex);
            }

            // چک حداکثر حجم و بستن جزئی (با چک Magic اضافی برای امنیت)
            if(closeVolume >= g_volumeMin && closeVolume <= g_volumeMax)
            {
               if(PositionGetInteger(POSITION_MAGIC) != m_magicNumber)
               {
                  Print("خطا: Magic Number پوزیشن مطابقت ندارد. رنج ", m_rangeIndex);
                  return;
               }
               if(CTradeManager::PartialClose(m_activeTicket, closeVolume))
               {
                  if(InpDebugMode) Print("بخشی از معامله رنج ", m_rangeIndex, " بسته شد. حجم بسته شده=", closeVolume);
                  if(CTradeManager::MoveSLToBreakEven(m_activeTicket, openPrice))
                  {
                     if(InpDebugMode) Print("استاپ لاس رنج ", m_rangeIndex, " به نقطه ورود منتقل شد.");
                     m_trailingActivated = true;
                  }
               }
            }
            else
            {
               Print("حجم بستن نامعتبر برای رنج ", m_rangeIndex, " (کمتر از min یا بیشتر از max).");
            }
         }
      }

      // اگر تریلینگ فعال است، اعمال تریلینگ استاپ با چک حداقل تغییر برای جلوگیری از به‌روزرسانی‌های غیرضروری
      if(m_trailingActivated)
      {
         int atrHandleToUse = (m_trailingMode == TRAILING_ATR) ? m_trailingAtrHandle : m_atrHandle;
         if(!CTradeManager::TrailingStop(m_activeTicket, m_trailingMode, m_trailingAtrPeriod, m_trailingAtrMultiplier, m_timeframe, atrHandleToUse))
         {
            Print("خطا در اعمال تریلینگ استاپ برای رنج ", m_rangeIndex);
         }
      }

      if(InpDebugMode) Print("معامله رنج ", m_rangeIndex, " در حالت MANAGING_TRADE.");
   }

private:
   // ریست کش‌های ATR: برای جلوگیری از استفاده از داده‌های کهنه در رنج جدید یا پس از پاکسازی
   void ResetCaches()
   {
      m_cachedATR = 0;
      m_cachedSlATR = 0;
      m_cachedTrailingATR = 0;
      if(InpDebugMode) Print("رنج ", m_rangeIndex, ": کش‌های ATR ریست شدند.");
   }

   // شناسایی و ولیدیشن رنج: محاسبه سقف/کف، چک ارتفاع و رسم مستطیل، با چک عدم وجود کندل
   void IdentifyAndValidateRange()
   {
      if(InpDebugMode) Print("شناسایی رنج ", m_rangeIndex, "...");

      datetime startTime, endTime;
      if(!CTimeHelper::CalculateRangeTimes(m_startHour, m_startMinute, m_endHour, m_endMinute, startTime, endTime))
      {
         Print("خطا در محاسبه زمان رنج ", m_rangeIndex);
         m_currentState = RANGE_EXPIRED;
         return;
      }

      if(endTime == m_lastEndTime && m_lastInvalid)
      {
         if(InpDebugMode) Print("رنج قبلی نامعتبر بود، skip تا رنج جدید.");
         return;
      }

      if(TimeCurrent() < endTime)
      {
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " هنوز تمام نشده است.");
         return;
      }

      int startShift = iBarShift(_Symbol, m_timeframe, startTime);
      int endShift = iBarShift(_Symbol, m_timeframe, endTime);

      // چک برای عدم وجود کندل در بازه (Edge Case مدیریت تعطیلی بازار)
      if(startShift < 0 || endShift < 0)
      {
         Print("خطا: کندلی در بازه زمانی مشخص شده برای رنج ", m_rangeIndex, " یافت نشد.");
         m_lastInvalid = true;
         m_lastEndTime = endTime;
         m_currentState = RANGE_EXPIRED;
         return;
      }

      int bars = startShift - endShift + 1;
      if(bars <= 0)
      {
         Print("خطا: تعداد بارها نامعتبر برای رنج ", m_rangeIndex);
         m_lastInvalid = true;
         m_lastEndTime = endTime;
         m_currentState = RANGE_EXPIRED;
         return;
      }

      int highestIdx = iHighest(_Symbol, m_timeframe, MODE_HIGH, bars, endShift);
      int lowestIdx = iLowest(_Symbol, m_timeframe, MODE_LOW, bars, endShift);
      m_rangeHigh = iHigh(_Symbol, m_timeframe, highestIdx);
      m_rangeLow = iLow(_Symbol, m_timeframe, lowestIdx);

      double rangeHeight = (m_rangeHigh - m_rangeLow) / _Point;
      if(InpDebugMode) Print("رنج ", m_rangeIndex, ": سقف=", m_rangeHigh, ", کف=", m_rangeLow, ", ارتفاع=", rangeHeight, " پوینت");

      if(rangeHeight < m_minRangePoints || rangeHeight > m_maxRangePoints)
      {
         Print("رنج ", m_rangeIndex, " بی‌کیفیت است. ارتفاع خارج از محدوده مجاز.");
         m_lastInvalid = true;
         m_lastEndTime = endTime;
         m_currentState = RANGE_EXPIRED;
         return;
      }

      if(!ObjectCreate(0, m_rangeObjectName, OBJ_RECTANGLE, 0, startTime, m_rangeHigh, endTime, m_rangeLow))
      {
         Print("خطا در رسم مستطیل رنج ", m_rangeIndex, ": ", GetLastError());
      }
      else
      {
         ObjectSetInteger(0, m_rangeObjectName, OBJPROP_COLOR, m_color);
         ObjectSetInteger(0, m_rangeObjectName, OBJPROP_STYLE, STYLE_SOLID);
         ObjectSetInteger(0, m_rangeObjectName, OBJPROP_WIDTH, 1);
         if(InpDebugMode) Print("مستطیل رنج ", m_rangeIndex, " رسم شد.");
      }

      m_lastInvalid = false;
      m_lastEndTime = endTime;
      m_currentState = RANGE_IDENTIFIED;
      if(InpDebugMode) Print("رنج ", m_rangeIndex, " معتبر است. تغییر حالت به IDENTIFIED.");
   }

   // مسلح کردن رنج: محاسبه افست خرید/فروش و رسم خطوط گرافیکی، با محاسبه ثابت ATR بدون کش (برای ثابت ماندن خطوط)
   void ArmAndWait()
   {
      if(InpDebugMode) Print("مسلح کردن رنج ", m_rangeIndex, "...");

      double offset;
      if(m_placementMode == PLACEMENT_ATR)
      {
         // محاسبه مستقیم ATR بدون کش برای ثابت ماندن افست (یک بار محاسبه و ثابت می‌ماند)
         double atr[];
         ArraySetAsSeries(atr, true);
         if(CopyBuffer(m_atrHandle, 0, 1, 1, atr) <= 0)
         {
            Print("خطا در گرفتن ATR برای مسلح کردن رنج ", m_rangeIndex, ": ", GetLastError());
            return;
         }
         offset = atr[0] * m_atrMultiplier;
      }
      else
      {
         offset = (m_rangeHigh - m_rangeLow) * m_atrMultiplier / 100.0;
      }

      m_potentialBuyPrice = NormalizeDouble(m_rangeHigh + offset, _Digits);
      m_potentialSellPrice = NormalizeDouble(m_rangeLow - offset, _Digits);

      datetime currentTime = TimeCurrent();
      if(!ObjectCreate(0, m_buyLineName, OBJ_HLINE, 0, currentTime, m_potentialBuyPrice))
      {
         Print("خطا در رسم خط BUY برای رنج ", m_rangeIndex);
      }
      else
      {
         ObjectSetInteger(0, m_buyLineName, OBJPROP_COLOR, clrGreen);
         ObjectSetInteger(0, m_buyLineName, OBJPROP_STYLE, STYLE_DASH);
      }
      if(!ObjectCreate(0, m_sellLineName, OBJ_HLINE, 0, currentTime, m_potentialSellPrice))
      {
         Print("خطا در رسم خط SELL برای رنج ", m_rangeIndex);
      }
      else
      {
         ObjectSetInteger(0, m_sellLineName, OBJPROP_COLOR, clrRed);
         ObjectSetInteger(0, m_sellLineName, OBJPROP_STYLE, STYLE_DASH);
      }

      m_cleanupTime = CTimeHelper::CalculateCleanupTime(m_endHour, m_endMinute, m_cleanupHours);

      if(InpDebugMode) Print("رنج ", m_rangeIndex, " مسلح شد. Potential Buy: ", m_potentialBuyPrice, ", Sell: ", m_potentialSellPrice);
      m_currentState = ARMED_AND_WAITING;
   }

   // انتظار برای کندل بریک: چک کلوز بالای/پایین افست برای شروع تأیید
   void WaitForBreakerCandle()
   {
      double close1 = iClose(_Symbol, m_timeframe, 1);
      if(close1 == 0)
      {
         Print("خطا: iClose مقدار نامعتبر برای رنج ", m_rangeIndex);
         return;
      }

      if(close1 > m_potentialBuyPrice)
      {
         m_breakerCandleLevel = iHigh(_Symbol, m_timeframe, 1);
         m_waitCounter = 0;
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " - BUY Breaker Candle detected! Level: ", m_breakerCandleLevel);
         if(Inp_PriceConfirmation_Enabled)
         {
            m_currentState = WAITING_FOR_PRICE_CONFIRMATION_BUY;
         }
         else
         {
            m_currentState = Inp_IchimokuFilter_Enabled ? WAITING_FOR_FILTER_CONFIRMATION_BUY : EXECUTE_TRADE_BUY;
         }
      }
      else if(close1 < m_potentialSellPrice)
      {
         m_breakerCandleLevel = iLow(_Symbol, m_timeframe, 1);
         m_waitCounter = 0;
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " - SELL Breaker Candle detected! Level: ", m_breakerCandleLevel);
         if(Inp_PriceConfirmation_Enabled)
         {
            m_currentState = WAITING_FOR_PRICE_CONFIRMATION_SELL;
         }
         else
         {
            m_currentState = Inp_IchimokuFilter_Enabled ? WAITING_FOR_FILTER_CONFIRMATION_SELL : EXECUTE_TRADE_SELL;
         }
      }
   }

   // تأیید قیمت: چک کلوز بعدی برای اطمینان از ادامه بریک (با تایم‌اوت)
   void WaitForPriceConfirmation()
   {
      double close1 = iClose(_Symbol, m_timeframe, 1);
      if(close1 == 0)
      {
         Print("خطا: iClose مقدار نامعتبر برای رنج ", m_rangeIndex);
         return;
      }

      bool isBuy = (m_currentState == WAITING_FOR_PRICE_CONFIRMATION_BUY);
      bool confirmed = isBuy ? (close1 > m_breakerCandleLevel) : (close1 < m_breakerCandleLevel);

      if(confirmed)
      {
         m_waitCounter = 0;
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " - ", (isBuy ? "BUY" : "SELL"), " Price Confirmation received!");
         m_currentState = isBuy ? (Inp_IchimokuFilter_Enabled ? WAITING_FOR_FILTER_CONFIRMATION_BUY : EXECUTE_TRADE_BUY) : (Inp_IchimokuFilter_Enabled ? WAITING_FOR_FILTER_CONFIRMATION_SELL : EXECUTE_TRADE_SELL);
         m_lastFilterBarTime = iTime(_Symbol, m_trendFilterTimeframe, 0); // تنظیم زمان کندل فیلتر
      }
      else
      {
         m_waitCounter++;
         if(m_waitCounter > Inp_Confirmation_Timeout)
         {
            if(InpDebugMode) Print("رنج ", m_rangeIndex, " - ", (isBuy ? "BUY" : "SELL"), " Price Confirmation Timeout!");
            if(isBuy)
            {
               m_potentialBuyPrice = 0;
               ObjectDelete(0, m_buyLineName);
            }
            else
            {
               m_potentialSellPrice = 0;
               ObjectDelete(0, m_sellLineName);
            }
            m_breakerCandleLevel = 0;
            m_currentState = ARMED_AND_WAITING;
         }
      }
   }

   // تأیید فیلتر روند: چک جهت روند فقط در کندل جدید تایم‌فریم فیلتر
   void WaitForFilterConfirmation()
   {
      // گرفتن زمان کندل فعلی در تایم‌فریم فیلتر
      datetime currentFilterBarTime = iTime(_Symbol, m_trendFilterTimeframe, 0);
      if(currentFilterBarTime == 0)
      {
         Print("خطا: iTime مقدار نامعتبر برای تایم‌فریم فیلتر رنج ", m_rangeIndex);
         return;
      }

      // اگر کندل جدیدی در تایم‌فریم فیلتر نیست، منتظر بمان
      if(currentFilterBarTime == m_lastFilterBarTime)
      {
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " - در انتظار کندل جدید در تایم‌فریم فیلتر ", EnumToString(m_trendFilterTimeframe));
         return;
      }

      // کندل جدید تشخیص داده شده، به‌روزرسانی زمان و بررسی فیلتر
      m_lastFilterBarTime = currentFilterBarTime;

      bool isBuy = (m_currentState == WAITING_FOR_FILTER_CONFIRMATION_BUY);
      ENUM_TREND_DIRECTION currentTrend = g_trendFilter.GetTrendDirection(m_trendFilterTimeframe);

      bool filterPassed = !Inp_IchimokuFilter_Enabled || (isBuy && (currentTrend == TREND_BUY || currentTrend == TREND_NEUTRAL)) || (!isBuy && (currentTrend == TREND_SELL || currentTrend == TREND_NEUTRAL));

      if(filterPassed)
      {
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " - فیلتر در لحظه تأیید شد! جهت فعلی: ", EnumToString(currentTrend));
         m_waitCounter = 0;
         m_currentState = isBuy ? EXECUTE_TRADE_BUY : EXECUTE_TRADE_SELL;
      }
      else
      {
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " - فیلتر رد شد. جهت فعلی: ", EnumToString(currentTrend));
         m_waitCounter++;
         if(m_waitCounter > Inp_Confirmation_Timeout)
         {
            if(InpDebugMode) Print("رنج ", m_rangeIndex, " - ", (isBuy ? "BUY" : "SELL"), " Filter Confirmation Timeout!");
            if(isBuy)
            {
               m_potentialBuyPrice = 0;
               ObjectDelete(0, m_buyLineName);
            }
            else
            {
               m_potentialSellPrice = 0;
               ObjectDelete(0, m_sellLineName);
            }
            m_breakerCandleLevel = 0;
            m_currentState = ARMED_AND_WAITING;
         }
      }
   }

   // اجرای معامله: محاسبه SL بر اساس نقطه مقابل رنج با بافر minStop، TP، حجم و ارسال سفارش بازار
   void ExecuteTrade()
   {
      bool isBuy = (m_currentState == EXECUTE_TRADE_BUY);
      double entryPrice = isBuy ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);

      double adjustment;
      if(m_slMode == SL_ATR)
      {
         // محاسبه مستقیم SL ATR بدون کش برای ثابت ماندن
         double atr[];
         ArraySetAsSeries(atr, true);
         if(CopyBuffer(m_slAtrHandle, 0, 1, 1, atr) <= 0)
         {
            Print("خطا در گرفتن ATR برای SL رنج ", m_rangeIndex, ": ", GetLastError());
            return;
         }
         adjustment = atr[0] * m_slAtrMultiplier;
      }
      else
      {
         adjustment = (m_rangeHigh - m_rangeLow) * m_slAtrMultiplier / 100.0;
      }

      // محاسبه SL بر اساس نقطه مقابل رنج
      double slPrice;
      if(isBuy)
      {
         slPrice = NormalizeDouble(m_rangeLow - adjustment, _Digits); // برای BUY: کف رنج - adjustment
      }
      else
      {
         slPrice = NormalizeDouble(m_rangeHigh + adjustment, _Digits); // برای SELL: سقف رنج + adjustment
      }

      double slDistance = MathAbs(entryPrice - slPrice);

      // چک ولید slDistance با بافر اضافی برای minStop (جلوگیری از رد سفارش توسط بروکر)
      long stops_level = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
      double minStop = stops_level * _Point + _Point;
      if(slDistance <= 0 || slDistance < minStop)
      {
         Print("خطا: slDistance نامعتبر یا کمتر از حداقل فاصله مجاز برای رنج ", m_rangeIndex, " (slDistance=", slDistance, ")");
         m_currentState = RANGE_EXPIRED;
         return;
      }

      if(InpDebugMode) Print("رنج ", m_rangeIndex, ": slDistance=", slDistance, ", slPrice=", slPrice);

      double tpDistance = slDistance * m_rrRatio;
      double tpPrice = isBuy ? NormalizeDouble(entryPrice + tpDistance, _Digits) : NormalizeDouble(entryPrice - tpDistance, _Digits);

      double lotSize = CRiskManager::CalculateLotSize(InpRiskPercent, slDistance);
      if(lotSize == 0)
      {
         Print("خطا در محاسبه حجم برای رنج ", m_rangeIndex);
         m_currentState = RANGE_EXPIRED;
         return;
      }

      if(InpDebugMode) Print("رنج ", m_rangeIndex, ": lotSize=", lotSize);

      CTrade trade;
      MqlTradeRequest request;
      MqlTradeResult result;
      ZeroMemory(request);
      request.action = TRADE_ACTION_DEAL;
      request.symbol = _Symbol;
      request.volume = lotSize;
      request.type = isBuy ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
      request.price = entryPrice; // استفاده از قیمت لحظه‌ای برای سفارش بازار
      request.sl = slPrice;
      request.tp = tpPrice;
      request.magic = m_magicNumber;
      request.comment = (isBuy ? "Buy" : "Sell") + " Range " + IntegerToString(m_rangeIndex);
      request.deviation = 10;
      if(!trade.OrderSend(request, result) || result.deal == 0)
      {
         Print("خطا در باز کردن معامله برای رنج ", m_rangeIndex, ": ", result.retcode);
         m_currentState = RANGE_EXPIRED;
         return;
      }
      m_activeTicket = result.deal;

      if(InpDebugMode) Print("رنج ", m_rangeIndex, " - ", (isBuy ? "BUY" : "SELL"), " Trade Opened! Ticket: ", m_activeTicket);

      DisableOppositePath(isBuy); // غیرفعال کردن مسیر مخالف برای OCO
      m_currentState = MANAGING_TRADE;
   }

   // غیرفعال کردن مسیر مخالف: حذف خط گرافیکی و ریست قیمت بالقوه برای جلوگیری از سیگنال دوگانه
   void DisableOppositePath(bool isBuy)
   {
      if(isBuy)
      {
         m_potentialSellPrice = 0;
         ObjectDelete(0, m_sellLineName);
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " - SELL path deactivated (OCO).");
      }
      else
      {
         m_potentialBuyPrice = 0;
         ObjectDelete(0, m_buyLineName);
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " - BUY path deactivated (OCO).");
      }
   }

   // پاکسازی نرم: ریست متغیرها و حذف اشیاء بدون بستن معامله برای آماده‌سازی رنج بعدی
   void SoftCleanup()
   {
      if(InpDebugMode) Print("پاکسازی نرم رنج ", m_rangeIndex, "...");

      m_potentialBuyPrice = 0;
      m_potentialSellPrice = 0;
      m_breakerCandleLevel = 0;
      m_waitCounter = 0;
      m_lastFilterBarTime = 0;
      ObjectDelete(0, m_buyLineName);
      ObjectDelete(0, m_sellLineName);
      ObjectDelete(0, m_rangeObjectName);
      m_lastEndTime = 0;
      m_lastInvalid = false;

      ResetCaches(); // ریست کش‌ها برای جلوگیری از استفاده از داده‌های کهنه

      m_currentState = RANGE_WAITING;
      m_cleanupTime = 0;
      if(InpDebugMode) Print("رنج ", m_rangeIndex, " برای روز بعد ریست شد (نرم).");
   }

   // گرفتن ATR کش‌شده اصلی: اگر کش خالی باشد، از هندل کپی می‌گیرد (فقط برای ورود استفاده شود)
   double GetCachedATR()
   {
      if(m_cachedATR <= 0)
      {
         double atr[];
         ArraySetAsSeries(atr, true);
         if(CopyBuffer(m_atrHandle, 0, 1, 1, atr) <= 0)
         {
            Print("خطا در گرفتن ATR برای رنج ", m_rangeIndex, ": ", GetLastError());
            return 0;
         }
         m_cachedATR = atr[0];
      }
      return m_cachedATR;
   }

   // گرفتن ATR کش‌شده برای SL: مشابه برای بهینه‌سازی محاسبات SL (فقط برای ورود استفاده شود)
   double GetSlATR()
   {
      if(m_cachedSlATR <= 0)
      {
         double atr[];
         ArraySetAsSeries(atr, true);
         if(CopyBuffer(m_slAtrHandle, 0, 1, 1, atr) <= 0)
         {
            Print("خطا در گرفتن ATR برای SL رنج ", m_rangeIndex, ": ", GetLastError());
            return 0;
         }
         m_cachedSlATR = atr[0];
      }
      return m_cachedSlATR;
   }

   // گرفتن ATR کش‌شده برای تریلینگ: مشابه برای بهینه‌سازی تریلینگ (فقط برای ورود استفاده شود، برای مدیریت پویا استفاده نشود)
   double GetTrailingATR()
   {
      if(m_cachedTrailingATR <= 0)
      {
         double atr[];
         ArraySetAsSeries(atr, true);
         if(CopyBuffer(m_trailingAtrHandle, 0, 1, 1, atr) <= 0)
         {
            Print("خطا در گرفتن ATR برای تریلینگ رنج ", m_rangeIndex, ": ", GetLastError());
            return 0;
         }
         m_cachedTrailingATR = atr[0];
      }
      return m_cachedTrailingATR;
   }
};

#endif
```

```mql5
//+------------------------------------------------------------------+
//|                                                     TradeManager.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CTradeManager را تعریف می‌کند که عملیات معاملاتی پیشرفته را مدیریت می‌کند.
// استراتژی کلی اکسپرت: این کلاس بخشی از مدیریت معامله در استراتژی شکست رنج است، جایی که پس از باز شدن معامله، خروج پله‌ای (هنگام رسیدن به RR)، انتقال SL به ورود (برای حفظ سرمایه)، تریلینگ (برای قفل سود) و بستن کامل (در پاکسازی سخت) انجام می‌شود. این عملیات ریسک را کنترل و سود را به حداکثر می‌رساند.
// منطق فایل TradeManager.mqh: کلاس شامل متدهای استاتیک برای بستن جزئی (PartialClose با چک حجم مجاز)، انتقال SL به بریک‌اون (MoveSLToBreakEven با نرمالایز قیمت)، تریلینگ استاپ (TrailingStop با محاسبه فاصله ATR یا ساده و چک حداقل تغییر برای جلوگیری از به‌روزرسانی‌های بیهوده)، و بستن کامل (ClosePosition). تمام متدها PositionSelectByTicket را چک می‌کنند و از CTrade برای ارسال درخواست استفاده می‌کنند. این فایل توسط CRange برای مدیریت معاملات در ManageActiveTrade فراخوانی می‌شود و هیچ وابستگی خارجی ندارد جز Trade.mqh.

#ifndef TRADE_MANAGER_MQH
#define TRADE_MANAGER_MQH

#include <Trade\Trade.mqh>

// کلاس CTradeManager برای عملیات معاملاتی استاتیک (بدون نیاز به نمونه‌سازی)
class CTradeManager
{
public:
   // بستن جزئی پوزیشن: محاسبه و بستن حجم مشخص با چک اضافی Magic برای امنیت
   static bool PartialClose(ulong ticket, double volume)
   {
      if(!PositionSelectByTicket(ticket))
      {
         Print("خطا: پوزیشن با تیکت ", ticket, " یافت نشد.");
         return false;
      }

      CTrade trade;
      if(trade.PositionClose(ticket, volume))
      {
         if(InpDebugMode) Print("بخشی از پوزیشن با تیکت ", ticket, " بسته شد.");
         return true;
      }
      else
      {
         Print("خطا در بستن بخشی از پوزیشن با تیکت ", ticket, ": ", trade.ResultRetcode());
         return false;
      }
   }

   // انتقال SL به بریک‌اون: نرمالایز قیمت و تغییر SL به نقطه ورود
   static bool MoveSLToBreakEven(ulong ticket, double breakEvenPrice)
   {
      if(!PositionSelectByTicket(ticket))
      {
         Print("خطا: پوزیشن با تیکت ", ticket, " یافت نشد.");
         return false;
      }

      CTrade trade;
      breakEvenPrice = NormalizeDouble(breakEvenPrice, _Digits);
      if(trade.PositionModify(ticket, breakEvenPrice, PositionGetDouble(POSITION_TP)))
      {
         if(InpDebugMode) Print("استاپ لاس پوزیشن ", ticket, " به نقطه ورود منتقل شد.");
         return true;
      }
      else
      {
         Print("خطا در انتقال استاپ لاس پوزیشن ", ticket, ": ", trade.ResultRetcode());
         return false;
      }
   }

   // اعمال تریلینگ استاپ: محاسبه فاصله جدید، چک حداقل تغییر و تغییر SL (محاسبه پویا ATR هر بار)
   static bool TrailingStop(ulong ticket, ENUM_TRAILING_MODE mode, int atrPeriod, double atrMultiplier, ENUM_TIMEFRAMES timeframe, int atrHandle)
   {
      if(!PositionSelectByTicket(ticket))
      {
         Print("خطا: پوزیشن با تیکت ", ticket, " یافت نشد.");
         return false;
      }

      double sl = PositionGetDouble(POSITION_SL);
      if(sl == 0)
      {
         if(InpDebugMode) Print("هشدار: SL اولیه صفر است برای پوزیشن ", ticket, ". تریلینگ skip شد.");
         return false;
      }

      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      double currentPrice = posType == POSITION_TYPE_BUY ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);

      double trailingDistance;
      if(mode == TRAILING_ATR)
      {
         double atr[];
         ArraySetAsSeries(atr, true);
         if(CopyBuffer(atrHandle, 0, 1, 1, atr) <= 0)
         {
            Print("خطا در گرفتن ATR برای تریلینگ: ", GetLastError());
            return false;
         }
         trailingDistance = atr[0] * atrMultiplier; // محاسبه پویا هر بار بدون کش
      }
      else
      {
         trailingDistance = atrMultiplier * _Point;
      }

      double newSL;
      if(posType == POSITION_TYPE_BUY)
      {
         newSL = NormalizeDouble(currentPrice - trailingDistance, _Digits);
         if(newSL > sl)
         {
            // چک حداقل تغییر برای جلوگیری از به‌روزرسانی‌های بیهوده و هزینه‌های اضافی
            if(MathAbs(newSL - sl) < _Point * 5) return true;
            CTrade trade;
            if(trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP)))
            {
               if(InpDebugMode) Print("تریلینگ استاپ برای پوزیشن ", ticket, " به‌روزرسانی شد. SL جدید=", newSL);
               return true;
            }
            else
            {
               Print("خطا در به‌روزرسانی تریلینگ استاپ: ", trade.ResultRetcode());
               return false;
            }
         }
      }
      else
      {
         newSL = NormalizeDouble(currentPrice + trailingDistance, _Digits);
         if(newSL < sl)
         {
            // چک حداقل تغییر مشابه
            if(MathAbs(newSL - sl) < _Point * 5) return true;
            CTrade trade;
            if(trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP)))
            {
               if(InpDebugMode) Print("تریلینگ استاپ برای پوزیشن ", ticket, " به‌روزرسانی شد. SL جدید=", newSL);
               return true;
            }
            else
            {
               Print("خطا در به‌روزرسانی تریلینگ استاپ: ", trade.ResultRetcode());
               return false;
            }
         }
      }
      return true;
   }

   // بستن کامل پوزیشن: انتخاب و بستن با چک نتیجه
   static bool ClosePosition(ulong ticket)
   {
      if(!PositionSelectByTicket(ticket))
      {
         Print("خطا: پوزیشن با تیکت ", ticket, " یافت نشد.");
         return false;
      }

      CTrade trade;
      if(trade.PositionClose(ticket))
      {
         if(InpDebugMode) Print("پوزیشن با تیکت ", ticket, " بسته شد.");
         return true;
      }
      else
      {
         Print("خطا در بستن پوزیشن با تیکت ", ticket, ": ", trade.ResultRetcode());
         return false;
      }
   }
};

#endif
```

```mql5
//+------------------------------------------------------------------+
//|                                                     RiskManager.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CRiskManager را تعریف می‌کند که محاسبه ریسک و حجم را مدیریت می‌کند.
// استراتژی کلی اکسپرت: ریسک هر معامله بر اساس درصد موجودی حساب و فاصله SL محاسبه می‌شود تا زیان محدود شود. این کلاس حجم را طوری تعیین می‌کند که زیان SL برابر درصد ریسک باشد، مستقل از نوع نماد (فارکس، شاخص، JPY).
// منطق فایل RiskManager.mqh: متد استاتیک CalculateLotSize فاصله SL (قیمت واقعی) را می‌گیرد، ریسک به ازای هر لات را با فرمول slDistance * (g_tickValue / g_tickSize) محاسبه می‌کند (برای سازگاری با نمادهای مختلف)، حجم را بر اساس ریسک مطلوب تعیین می‌کند و به گام حجم راند می‌کند. چک‌های ولید برای جلوگیری از حجم نامعتبر اضافه شده. این فایل توسط CRange برای محاسبه حجم در ExecuteTrade فراخوانی می‌شود.

#ifndef RISK_MANAGER_MQH
#define RISK_MANAGER_MQH

extern double g_tickValue;
extern double g_tickSize;
extern double g_volumeStep;
extern double g_volumeMin;
extern double g_volumeMax;

// کلاس CRiskManager برای محاسبه حجم معاملاتی بر اساس ریسک
class CRiskManager
{
public:
   // محاسبه حجم: بر اساس درصد ریسک و فاصله SL، با فرمول سازگار برای تمام نمادها
   static double CalculateLotSize(double riskPercent, double slDistance) 
   {
      if(g_tickValue == 0 || g_tickSize == 0)
      {
         Print("خطا: tickValue یا tickSize صفر است. محاسبه حجم ممکن نیست.");
         return 0;
      }

      // اگر g_tickSize صفر باشد (نادر)، default به _Point برای سازگاری
      if(g_tickSize == 0) g_tickSize = _Point;

      double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
      double riskPerLot = slDistance * (g_tickValue / g_tickSize); 

      if (riskPerLot <= 0) 
      {
          Print("خطا: ریسک به ازای هر لات نامعتبر است. slDistance=", slDistance);
          return 0;
      }

      double riskAmount = riskPercent / 100.0 * accountBalance;
      double lotSize = riskAmount / riskPerLot;

      lotSize = MathRound(lotSize / g_volumeStep) * g_volumeStep;
      lotSize = MathMax(g_volumeMin, MathMin(g_volumeMax, lotSize));

      if(lotSize < g_volumeMin)
      {
         Print("خطا: حجم محاسبه شده (", lotSize, ") کمتر از حداقل (", g_volumeMin, ") است.");
         return 0;
      }

      if(InpDebugMode) Print("حجم محاسبه شده: ", lotSize, ", slDistance=", slDistance, ", riskPerLot=", riskPerLot);
      return lotSize;
   }
};

#endif
```

```mql5
//+------------------------------------------------------------------+
//|                                                      TimeHelper.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CTimeHelper را تعریف می‌کند که محاسبات زمانی را مدیریت می‌کند.
// استراتژی کلی اکسپرت: زمان‌های رنج و پاکسازی بر اساس ساعات محلی سرور محاسبه می‌شود تا رنج‌ها دقیقاً در بازه‌های تعریف‌شده عمل کنند و پس از انقضا پاک شوند.
// منطق فایل TimeHelper.mqh: متدهای استاتیک CalculateRangeTimes زمان شروع/پایان رنج را محاسبه می‌کند (با مدیریت رنج‌های شبانه و تنظیم بر اساس روز فعلی)، و CalculateCleanupTime زمان انقضا را بر اساس ساعت‌های پاکسازی اضافه می‌کند. این فایل توسط CRange برای تعیین زمان‌ها استفاده می‌شود و وابستگی به TimeCurrent دارد.

#ifndef TIME_HELPER_MQH
#define TIME_HELPER_MQH

// کلاس CTimeHelper برای محاسبات زمانی رنج و پاکسازی
class CTimeHelper
{
public:
   // محاسبه زمان شروع و پایان رنج: تنظیم بر اساس روز فعلی و مدیریت رنج‌های عبور از نیمه‌شب
   static bool CalculateRangeTimes(int startHour, int startMinute, int endHour, int endMinute, datetime &startTime, datetime &endTime)
   {
      MqlDateTime dt;
      TimeToStruct(TimeCurrent(), dt);

      datetime today = TimeCurrent() - (dt.hour * 3600 + dt.min * 60 + dt.sec);
      datetime start = today + startHour * 3600 + startMinute * 60;
      datetime end = today + endHour * 3600 + endMinute * 60;

      if(endHour < startHour || (endHour == startHour && endMinute <= startMinute))
      {
         end += 86400; // مدیریت رنج شبانه (عبور از نیمه‌شب)
      }

      if(TimeCurrent() < start)
      {
         start -= 86400;
         end -= 86400; // تنظیم برای رنج قبلی اگر زمان فعلی قبل از شروع باشد
      }

      startTime = start;
      endTime = end;
      if(InpDebugMode) Print("محاسبه زمان رنج: Start=", TimeToString(startTime), ", End=", TimeToString(endTime));
      return true;
   }

   // محاسبه زمان پاکسازی: اضافه کردن ساعت‌های پاکسازی به زمان پایان برای انقضا
   static datetime CalculateCleanupTime(int endHour, int endMinute, int cleanupHours)
   {
      MqlDateTime dt;
      TimeToStruct(TimeCurrent(), dt);

      datetime today = TimeCurrent() - (dt.hour * 3600 + dt.min * 60 + dt.sec);
      datetime end = today + endHour * 3600 + endMinute * 60;
      if(endHour < dt.hour || (endHour == dt.hour && endMinute <= dt.min))
      {
         end += 86400; // مدیریت پایان در روز بعد اگر لازم باشد
      }

      datetime cleanupTime = end + cleanupHours * 3600;
      if(InpDebugMode) Print("زمان پاکسازی: ", TimeToString(cleanupTime));
      return cleanupTime;
   }
};

#endif
```

```mql5
//+------------------------------------------------------------------+
//|                                                     TrendFilter.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CTrendFilter را تعریف می‌کند که فیلتر روند بر اساس ایچیموکو را مدیریت می‌کند.
// استراتژی کلی اکسپرت: فیلتر روند برای جلوگیری از معاملات خلاف جهت استفاده می‌شود؛ اگر ابر ایچیموکو فلت (خنثی) یا هم‌جهت باشد، معامله مجاز است، иначе رد می‌شود.
// منطق فایل TrendFilter.mqh: enum ENUM_TREND_DIRECTION برای خروجی (BUY/SELL/NEUTRAL). تابع GetTrendDirection هندل ایچیموکو را برای تایم‌فریم مشخص می‌سازد، سنکو A/B را می‌گیرد، تفاوت را چک می‌کند (اگر کمتر از آستانه، خنثی)، و جهت را تعیین می‌کند (A > B برای BUY). هندل پس از استفاده آزاد می‌شود تا از leak جلوگیری شود. Init/Deinit خالی هستند زیرا هندل پویا ساخته می‌شود. این فایل توسط CRange برای تأیید فیلتر فراخوانی می‌شود.

#ifndef TREND_FILTER_MQH
#define TREND_FILTER_MQH

// تعریف enum برای جهت روند (برای تصمیم‌گیری در فیلتر)
enum ENUM_TREND_DIRECTION
{
   TREND_BUY,     // روند صعودی (سنکو A بالای B)
   TREND_SELL,    // روند نزولی (سنکو A پایین B)
   TREND_NEUTRAL  // روند خنثی (ابر فلت یا فیلتر خاموش)
};

// کلاس CTrendFilter برای فیلتر روند پویا بر اساس ایچیموکو
class CTrendFilter
{
public:
   CTrendFilter() {}
   // Init خالی (هیچ هندلی ثابت ساخته نمی‌شود، پویا در GetTrendDirection)
   bool Init() { return true; }
   // Deinit خالی (هیچ منبعی ثابت برای آزادسازی نیست)
   void Deinit() {}

   // گرفتن جهت روند: ساخت پویا هندل، محاسبه ابر، تعیین جهت و آزادسازی هندل
   ENUM_TREND_DIRECTION GetTrendDirection(ENUM_TIMEFRAMES timeframe)
   {
      if(!Inp_IchimokuFilter_Enabled)
      {
         return TREND_NEUTRAL; // اگر فیلتر خاموش باشد، همیشه خنثی فرض می‌شود
      }

      int ichimokuHandle = iIchimoku(_Symbol, timeframe, Inp_Ichimoku_Tenkan, Inp_Ichimoku_Kijun, Inp_Ichimoku_SenkouB);
      if(ichimokuHandle == INVALID_HANDLE)
      {
         Print("خطا در ایجاد هندل ایچیموکو برای تایم فریم ", EnumToString(timeframe));
         return TREND_NEUTRAL;
      }

      double senkouA[], senkouB[];
      ArraySetAsSeries(senkouA, true);
      ArraySetAsSeries(senkouB, true);

      if(CopyBuffer(ichimokuHandle, 3, 0, 1, senkouA) <= 0 || CopyBuffer(ichimokuHandle, 4, 0, 1, senkouB) <= 0)
      {
         Print("خطا در گرفتن داده‌های ایچیموکو: ", GetLastError());
         IndicatorRelease(ichimokuHandle); // آزادسازی حتی در خطا برای جلوگیری از leak
         return TREND_NEUTRAL;
      }
      
      IndicatorRelease(ichimokuHandle); // آزادسازی هندل پس از استفاده موفق

      double diff = MathAbs(senkouA[0] - senkouB[0]) / _Point;
      if(diff < Inp_Ichimoku_FlatThreshold_Points)
      {
         if(InpDebugMode) Print("ابر ایچیموکو فلت است. جهت: NEUTRAL");
         return TREND_NEUTRAL;
      }

      if(senkouA[0] > senkouB[0])
      {
         if(InpDebugMode) Print("جهت روند: BUY");
         return TREND_BUY;
      }
      else
      {
         if(InpDebugMode) Print("جهت روند: SELL");
         return TREND_SELL;
      }
   }
};

#endif
```

```mql5
//+------------------------------------------------------------------+
//|                                                   VisualManager.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CVisualManager را تعریف می‌کند که نمایش بصری روی چارت را مدیریت می‌کند.
// استراتژی کلی اکسپرت: نمایش وضعیت روند (BUY/SELL/NEUTRAL) برای کمک به کاربر در نظارت، بدون تأثیر بر منطق معاملاتی.
// منطق فایل VisualManager.mqh: کلاس شیء LABEL را برای نمایش متن روند ایجاد می‌کند، موقعیت، فونت و رنگ را تنظیم می‌کند. تابع UpdateTrendStatus متن و رنگ را به‌روزرسانی و چارت را redraw می‌کند. Init شیء را می‌سازد و Deinit حذف می‌کند. این فایل توسط Elemento.mq5 برای نمایش در OnTick فراخوانی می‌شود و اختیاری است (اگر اگر Inp_Visual_ShowTrendStatus خاموش باشد، نادیده گرفته می‌شود).

#ifndef VISUAL_MANAGER_MQH
#define VISUAL_MANAGER_MQH

// کلاس CVisualManager برای مدیریت نمایش متن روند روی چارت
class CVisualManager
{
private:
   string m_trendStatusObjectName; // نام منحصربه‌فرد شیء LABEL برای نمایش

public:
   CVisualManager() : m_trendStatusObjectName("TrendStatus") {}

   // مقداردهی: ایجاد شیء LABEL با تنظیمات فونت، رنگ و موقعیت اگر نمایش فعال باشد
   bool Init()
   {
      if(InpDebugMode) Print("مقداردهی مدیر نمایش...");
      if(Inp_Visual_ShowTrendStatus)
      {
         if(!ObjectCreate(0, m_trendStatusObjectName, OBJ_LABEL, 0, 0, 0))
         {
            Print("خطا در ایجاد شیء نمایش روند: ", GetLastError());
            return false;
         }

         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_XDISTANCE, Inp_Visual_X_Offset);
         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_YDISTANCE, Inp_Visual_Y_Offset);
         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_FONTSIZE, Inp_Visual_FontSize);
         ObjectSetString(0, m_trendStatusObjectName, OBJPROP_FONT, "Arial");
         ObjectSetString(0, m_trendStatusObjectName, OBJPROP_TEXT, "Initializing...");
         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_COLOR, Inp_Visual_FontColor_Neutral);
      }
      if(InpDebugMode) Print("مدیر نمایش با موفقیت مقداردهی شد.");
      return true;
   }

   // دفع: حذف شیء LABEL برای پاکسازی چارت
   void Deinit()
   {
      ObjectDelete(0, m_trendStatusObjectName);
      if(InpDebugMode) Print("شیء نمایش روند حذف شد.");
   }

   // به‌روزرسانی نمایش: تغییر متن و رنگ وضعیت روند و redraw چارت
   void UpdateTrendStatus(string text, color clr)
   {
      if(!Inp_Visual_ShowTrendStatus) return;

      ObjectSetString(0, m_trendStatusObjectName, OBJPROP_TEXT, text);
      ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_COLOR, clr);
      ChartRedraw();
   }
};

#endif
```
