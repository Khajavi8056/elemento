اوکی پس من پیاده سازی مود را هم انجام میدم یه بار دیگه خیلی دقیق و بسیار جزئی تمام خطوط سیستم نه اینکه فقط آپدیت اخیر رو بررسی کنیم نه تمام سیستم تمام منطق‌ها و تمام جزئیاتشو کامل بررسی کن ببین مشکلی که نداره در واقع چیز غیرمنطقیه چیزی نامتعارفی در واقع مشکل فنی مشکل اجرایی مشکل کامپایلی مشکل آرایه‌ای باشه مشکل متغیری باشه مشکل از نمی‌دونم اجرای درست و بینی سیستم در متاتر ۵ باشه و خیلی جزئی و دقیق باید سیستم رو آنالیز و کالبد شکافی کنیم و خیلی هم حساس باشیم گزارش کامل از سلامت و امنیت سیستم به من بده 

تمامی بخش‌های سیستم توجه شود به منطق ورودش به حالت‌های در واقع ماشین حالت دقیق بررسی شود و این حالت‌ها در واقع همگی به درستی اتفاق می‌افتند برگشت‌های این حالت‌ها یا ریست‌سازی‌های این حالت‌ها اینکه در یک حالت خاص سیستم گیر نکند حتما بررسی شود با دقت بسیار بالا 
دیگه بخش‌های مربوط به مدیریت سرمایه مدیریت حجم مدیریت در واقع استاپ لاس‌ها مدیریت تارگت‌ها تنظیم دقیق استاپلاس‌ها در واقع با تمام حالت‌هایی که در ورودی‌ها داره همه چی به درستی روی هر کدوم باشه اوکی و درست همون چیزی که دارد را کار کند 
منطقه ترولینگ استاپ منطق‌های مربوط به پاکسازی‌ها پاکسازی‌ها منطق مربوط به oco منطقه‌های در واقع و سایر بخش‌های خیلی ریز و درشت دیگر کاملاً باید بررسی و گزارش شود 
همچنین توجه شود که در واقع برای هر چهار رنج باید سیستم بتواند تفکیک قائل شود و برای هر کدام اگر دو رنج همزمان در شرایطی قرار باشه هر دوی آنها همزمان معاملاتی را انجام و مراحل و ماشین حالت هر کدام باید بتواند به طور همزمان کار کند برای مثال اگر همزمان دو رنج مختلف که در زمان‌ها و تنظیمات مختلفی هم دارا هستند در یک حالت ماشین قرار گرفتن باید به درستی در واقع مدیریت بشه یا حتی در این مورد جدید به درستی ریست‌های هر حالت انجام بشه و چرخش‌هایی که در حالت‌های مختلف اتفاق می‌افته و برگشت‌ها به حالت‌های مختلف حتماً باید به درستی و هیچ تداخلی نداشته باشد این‌ها رو دقیق بررسی کن
خط به خط کد زیر بررسی شود 


```mql5
//+------------------------------------------------------------------+
//|                                                         Settings.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل نقش تعریف ساختارهای پایه‌ای و پارامترهای ورودی (inputs) اکسپرت Elemento را بر عهده دارد.
// استراتژی کلی اکسپرت: Elemento یک سیستم معاملاتی مبتنی بر شکست رنج (Breakout Range) است که بر اساس زمان‌های مشخص (رنج‌های زمانی) عمل می‌کند. این اکسپرت تا چهار رنج زمانی مختلف را تعریف می‌کند، هر رنج را بر اساس ارتفاع قیمت (High/Low) در بازه زمانی تعیین‌شده شناسایی می‌کند، سپس منتظر شکست (Breakout) سقف یا کف رنج با افست (Offset) مبتنی بر ATR یا درصد ارتفاع رنج می‌ماند. پس از شکست، با تأیید اختیاری قیمت (کندل تایید) و فیلتر روند ایچیموکو، معامله خرید یا فروش باز می‌کند. مدیریت معامله شامل استاپ لاس (SL) مبتنی بر استراتژی جایگذاری (مقابل رنج یا سطح شکست) به علاوه تنظیم ATR یا درصد (برای پوشش کامل رنج و جلوگیری از زیان زودرس)، تیک پروفیت (TP) بر اساس نسبت R:R، خروج پله‌ای (Partial Close) در رسیدن به نسبت مشخص سود به ریسک، و تریلینگ استاپ (Trailing Stop) برای حفظ سود است. پاکسازی رنج‌ها پس از انقضا یا بسته شدن بازار انجام می‌شود تا از تداخل جلوگیری شود.
// منطق فایل Settings.mqh: این فایل هیچ کدی اجرایی ندارد و فقط enums و گروه‌های input را تعریف می‌کند تا کاربر بتواند پارامترها را تنظیم کند. enums برای حالت‌های مختلف (مانند PLACEMENT_MODE برای تعیین افست شکست، SL_STRATEGY برای استراتژی جایگذاری SL، SL_CALC_MODE برای محاسبه بافر SL، TRAILING_MODE برای تریلینگ) استفاده می‌شوند. گروه‌های input شامل تنظیمات عمومی (ریسک، دیباگ، تایید قیمت)، فیلتر ایچیموکو (برای جلوگیری از معاملات خلاف روند)، نمایشگر چارت (برای نشان دادن وضعیت روند هر رنج به طور جداگانه)، و تنظیمات چهار رنج جداگانه (هر رنج می‌تواند تایم‌فریم، ساعات، حداقل/حداکثر ارتفاع، دوره‌های ATR، ضرایب، نسبت R:R، درصد خروج پله‌ای، ساعت پاکسازی و رنگ داشته باشد). این ساختار اجازه می‌دهد اکسپرت برای بازارهای مختلف (مانند فارکس یا شاخص‌ها) سفارشی‌سازی شود و استراتژی شکست رنج را با فیلتر روند ترکیب کند تا سیگنال‌های معتبرتری تولید شود. فایل توسط سایر فایل‌ها include می‌شود تا به inputs دسترسی داشته باشند. تغییرات جدید در نسخه 1.92: حذف Inp_Confirmation_Timeout برای حذف محدودیت زمانی تایمر کندلی و جایگزینی با منطق ابطال بر اساس بازگشت قیمت به داخل رنج (برای حفظ فرصت‌های معاملاتی و جلوگیری از فرصت‌سوزی). همچنین اضافه شدن ENUM_INVALIDATION_MODE برای انتخاب استراتژی ابطال تلاش ورود (بازگشت به رنج یا عبور از خط شکست) به عنوان یک پارامتر ورودی در تنظیمات عمومی برای افزایش انعطاف‌پذیری.

#ifndef SETTINGS_MQH
#define SETTINGS_MQH

// تعریف enum برای حالت‌های مختلف قرارگیری سفارش (تعیین افست شکست رنج با ATR یا درصد ارتفاع رنج برای جلوگیری از شکست‌های کاذب)
enum ENUM_PLACEMENT_MODE
{
   PLACEMENT_ATR,    // استفاده از ATR برای محاسبه افست ثبت سفارش (پویا بر اساس نوسان بازار)
   PLACEMENT_PERCENT // استفاده از درصد ارتفاع رنج برای محاسبه افست ثبت سفارش (ثابت بر اساس اندازه رنج)
};

// تعریف enum برای استراتژی جایگذاری استاپ لاس (تعیین پایه SL: مقابل رنج یا سطح شکست)
enum ENUM_SL_STRATEGY
{
   SL_OPPOSITE_SIDE,  // استاپ لاس در سمت مقابل رنج (قبلی: برای BUY در کف - بافر، برای SELL در سقف + بافر)
   SL_BREAKOUT_LEVEL  // استاپ لاس در سطح شکست (جدید: برای BUY در سقف - بافر، برای SELL در کف + بافر)
};

// تعریف enum برای حالت محاسبه بافر استاپ لاس (تعیین فاصله بافر SL با ATR یا درصد ارتفاع رنج)
enum ENUM_SL_CALC_MODE
{
   SL_CALC_ATR,    // استفاده از ATR برای محاسبه بافر استاپ لاس (پویا و تطبیقی با نوسان)
   SL_CALC_PERCENT // استفاده از درصد ارتفاع رنج برای محاسبه بافر استاپ لاس (ثابت و ساده)
};

// تعریف enum برای حالت‌های تریلینگ استاپ (تعیین فاصله تریلینگ با ATR یا مقدار ثابت برای حفظ سود)
enum ENUM_TRAILING_MODE
{
   TRAILING_ATR,   // استفاده از ATR برای محاسبه فاصله تریلینگ استاپ (پویا)
   TRAILING_SIMPLE // استفاده از فاصله ثابت برای تریلینگ استاپ (ساده و غیرپویا)
};

// (جدید) تعریف enum برای استراتژی ابطال تلاش برای ورود (انتخاب بین حالت صبور یا تهاجمی برای ابطال فرصت ورود)
enum ENUM_INVALIDATION_MODE
{
   INVALIDATION_RANGE_REENTRY,     // حالت صبور: فرصت ورود فقط در صورت بازگشت قیمت به داخل رنج اصلی باطل می‌شود
   INVALIDATION_BREAKOUT_LINE_CROSS  // حالت تهاجمی: فرصت ورود به محض بازگشت قیمت به زیر خط شکست باطل می‌شود
};

// گروه ورودی برای تنظیمات عمومی (پارامترهای پایه‌ای که بر تمام رنج‌ها تأثیر می‌گذارند)
input group "تنظیمات عمومی"
input long InpBaseMagicNumber = 123456; // مجیک نامبر پایه (برای تمایز معاملات رنج‌های مختلف و جلوگیری از تداخل با دیگر اکسپرت‌ها)
input double InpRiskPercent = 1.0; // درصد ریسک (0.1 تا 5.0) - مقدار ریسک هر معامله بر اساس موجودی حساب برای کنترل زیان
input bool InpDebugMode = true; // حالت دیباگ (چاپ پیام‌های اضافی برای عیب‌یابی و نظارت بر عملکرد اکسپرت)
input bool Inp_PriceConfirmation_Enabled = true; // فعال کردن تأیید قیمت پس از کندل شکننده (اگر خاموش باشد، مستقیم به فیلتر روند می‌رود یا ورود)
// (جدید) انتخاب‌گر استراتژی ابطال تلاش ورود (برای انعطاف‌پذیری در رفتار اکسپرت: صبور یا تهاجمی)
input ENUM_INVALIDATION_MODE Inp_Invalidation_Mode = INVALIDATION_RANGE_REENTRY; // استراتژی ابطال: بازگشت به رنج (صبور) یا عبور از خط شکست (تهاجمی)

// گروه ورودی برای فیلتر روند ایچیموکو (برای اطمینان از معامله در جهت روند یا خنثی و جلوگیری از معاملات خلاف روند)
input group "فیلتر روند ایچیموکو"
input bool Inp_IchimokuFilter_Enabled = true; // فعال کردن فیلتر روند ایچیموکو (اگر خاموش باشد، همیشه خنثی فرض می‌شود)
input int Inp_Ichimoku_Tenkan = 9; // دوره تنکان-سن (خط سریع ایچیموکو برای تشخیص روند کوتاه‌مدت)
input int Inp_Ichimoku_Kijun = 26; // دوره کیجون-سن (خط کند ایچیموکو برای تشخیص روند میان‌مدت)
input int Inp_Ichimoku_SenkouB = 52; // دوره سنکو اسپن B (ابر ایچیموکو برای تشخیص حمایت/مقاومت آینده)
input int Inp_Ichimoku_FlatThreshold_Points = 90; // آستانه تشخیص ابر فلت به پوینت (برای تعیین روند خنثی اگر تفاوت سنکو A و B کمتر باشد)

// گروه ورودی برای تنظیمات نمایشگر چارت (برای نمایش بصری وضعیت روند هر رنج به طور جداگانه روی چارت به کاربر)
input group "تنظیمات نمایشگر چارت"
input bool Inp_Visual_ShowTrendStatus = true; // فعال کردن نمایش وضعیت روند (روی چارت برای نظارت بصری هر رنج)
input int Inp_Visual_FontSize = 12; // اندازه فونت نمایشگر (برای خوانایی بهتر)
input color Inp_Visual_FontColor_Buy = clrGreen; // رنگ متن برای روند BUY (سبز برای مثبت)
input color Inp_Visual_FontColor_Sell = clrRed; // رنگ متن برای روند SELL (قرمز برای منفی)
input color Inp_Visual_FontColor_Neutral = clrGray; // رنگ متن برای روند NEUTRAL (خاکستری برای خنثی)
input int Inp_Visual_X_Offset = 10; // فاصله افقی از لبه چارت (پیکسل برای موقعیت مناسب)
input int Inp_Visual_Y_Offset = 10; // فاصله عمودی از لبه چارت (پیکسل برای موقعیت مناسب)

// گروه ورودی برای تنظیمات رنج ۱ (اولین رنج زمانی، معمولاً برای سشن آسیا یا شبانه)
input group "تنظیمات رنج 1"
input bool InpRange1_Enabled = true; // فعال کردن رنج 1 (اگر خاموش باشد، این رنج نادیده گرفته می‌شود)
input ENUM_TIMEFRAMES InpRange1_Execution_Timeframe = PERIOD_M5; // تایم‌فریم اجرا رنج 1 (برای اجرای منطق رنج و محاسبات)
input ENUM_TIMEFRAMES InpRange1_TrendFilter_Timeframe = PERIOD_H1; // تایم‌فریم فیلتر روند رنج 1 (برای فیلتر ایچیموکو، می‌تواند متفاوت باشد)
input int InpRange1_Start_Hour = 22; // ساعت شروع رنج 1 (0-23 برای تعریف بازه زمانی)
input int InpRange1_Start_Minute = 0; // دقیقه شروع رنج 1 (0-59 برای دقت زمانی)
input int InpRange1_End_Hour = 9; // ساعت پایان رنج 1 (0-23، اگر کمتر از شروع باشد، رنج شبانه فرض می‌شود)
input int InpRange1_End_Minute = 30; // دقیقه پایان رنج 1 (0-59)
input int InpRange1_MinRangePoints = 200; // حداقل ارتفاع رنج 1 به پوینت (برای فیلتر رنج‌های کوچک و بی‌کیفیت)
input int InpRange1_MaxRangePoints = 1500; // حداکثر ارتفاع رنج 1 به پوینت (برای فیلتر رنج‌های بزرگ و پرریسک)
input ENUM_PLACEMENT_MODE InpRange1_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 1 (افست شکست)
input int InpRange1_ATR_Period = 122; // دوره ATR برای ثبت سفارش رنج 1 (برای محاسبه افست پویا)
input double InpRange1_ATR_Multiplier = 2.3; // ضریب ATR برای ثبت سفارش رنج 1 (برای تنظیم حساسیت افست)
input ENUM_SL_STRATEGY InpRange1_SL_Strategy = SL_BREAKOUT_LEVEL; // استراتژی جایگذاری استاپ لاس رنج 1 (مقابل یا سطح شکست)
input ENUM_SL_CALC_MODE InpRange1_SL_Calc_Mode = SL_CALC_ATR; // حالت محاسبه بافر استاپ لاس رنج 1
input int InpRange1_SL_ATR_Period = 62; // دوره ATR برای بافر استاپ لاس رنج 1
input double InpRange1_SL_ATR_Multiplier = 1.3; // ضریب ATR برای بافر استاپ لاس رنج 1
input ENUM_TRAILING_MODE InpRange1_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 1
input int InpRange1_Trailing_ATR_Period = 43; // دوره ATR برای تریلینگ رنج 1
input double InpRange1_Trailing_ATR_Multiplier = 1.4; // ضریب ATR برای تریلینگ رنج 1
input double InpRange1_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 1 (سود به ریسک برای TP و خروج)
input double InpRange1_PartialClosePercent = 60.0; // درصد بستن پله‌ای رنج 1 (هنگام رسیدن به RR)
input int InpRange1_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج 1 (0-24، زمان انقضای رنج پس از پایان)
input color InpRange1_Color = clrBlue; // رنگ مستطیل رنج 1 (برای نمایش گرافیکی روی چارت)

// گروه ورودی برای تنظیمات رنج ۲ (دومین رنج، معمولاً برای سشن اروپا)
input group "تنظیمات رنج 2"
input bool InpRange2_Enabled = true; // فعال کردن رنج 2
input ENUM_TIMEFRAMES InpRange2_Execution_Timeframe = PERIOD_M15; // تایم‌فریم اجرا رنج 2
input ENUM_TIMEFRAMES InpRange2_TrendFilter_Timeframe = PERIOD_M15; // تایم‌فریم فیلتر روند رنج 2
input int InpRange2_Start_Hour = 5; // ساعت شروع رنج 2 (0-23)
input int InpRange2_Start_Minute = 0; // دقیقه شروع رنج 2 (0-59)
input int InpRange2_End_Hour = 13; // ساعت پایان رنج 2 (0-23)
input int InpRange2_End_Minute = 0; // دقیقه پایان رنج 2 (0-59)
input int InpRange2_MinRangePoints = 200; // حداقل ارتفاع رنج 2 به پوینت
input int InpRange2_MaxRangePoints = 3500; // حداکثر ارتفاع رنج 2 به پوینت
input ENUM_PLACEMENT_MODE InpRange2_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 2
input int InpRange2_ATR_Period = 27; // دوره ATR برای ثبت سفارش رنج 2
input double InpRange2_ATR_Multiplier = 2.8; // ضریب ATR برای ثبت سفارش رنج 2
input ENUM_SL_STRATEGY InpRange2_SL_Strategy = SL_OPPOSITE_SIDE; // استراتژی جایگذاری استاپ لاس رنج 2
input ENUM_SL_CALC_MODE InpRange2_SL_Calc_Mode = SL_CALC_ATR; // حالت محاسبه بافر استاپ لاس رنج 2
input int InpRange2_SL_ATR_Period = 86; // دوره ATR برای بافر استاپ لاس رنج 2
input double InpRange2_SL_ATR_Multiplier = 1.56; // ضریب ATR برای بافر استاپ لاس رنج 2
input ENUM_TRAILING_MODE InpRange2_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 2
input int InpRange2_Trailing_ATR_Period = 101; // دوره ATR برای تریلینگ رنج 2
input double InpRange2_Trailing_ATR_Multiplier = 1.58; // ضریب ATR برای تریلینگ رنج 2
input double InpRange2_RR_Ratio = 2.8; // نسبت R:R برای خروج پله‌ای رنج 2
input double InpRange2_PartialClosePercent = 26; // درصد بستن پله‌ای رنج 2
input int InpRange2_Cleanup_Hours = 4; // ساعت‌های پاکسازی رنج 2 (0-24)
input color InpRange2_Color = clrRed; // رنگ مستطیل رنج 2

// گروه ورودی برای تنظیمات رنج ۳ (سومین رنج، معمولاً برای سشن آمریکا)
input group "تنظیمات رنج 3"
input bool InpRange3_Enabled = false; // فعال کردن رنج 3
input ENUM_TIMEFRAMES InpRange3_Execution_Timeframe = PERIOD_M5; // تایم‌فریم اجرا رنج 3
input ENUM_TIMEFRAMES InpRange3_TrendFilter_Timeframe = PERIOD_M30; // تایم‌فریم فیلتر روند رنج 3
input int InpRange3_Start_Hour = 15; // ساعت شروع رنج 3 (0-23)
input int InpRange3_Start_Minute = 0; // دقیقه شروع رنج 3 (0-59)
input int InpRange3_End_Hour = 18; // ساعت پایان رنج 3 (0-23)
input int InpRange3_End_Minute = 0; // دقیقه پایان رنج 3 (0-59)
input int InpRange3_MinRangePoints = 100; // حداقل ارتفاع رنج 3 به پوینت
input int InpRange3_MaxRangePoints = 2110; // حداکثر ارتفاع رنج 3 به پوینت
input ENUM_PLACEMENT_MODE InpRange3_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 3
input int InpRange3_ATR_Period = 14; // دوره ATR برای ثبت سفارش رنج 3
input double InpRange3_ATR_Multiplier = 1.2; // ضریب ATR برای ثبت سفارش رنج 3
input ENUM_SL_STRATEGY InpRange3_SL_Strategy = SL_OPPOSITE_SIDE; // استراتژی جایگذاری استاپ لاس رنج 3
input ENUM_SL_CALC_MODE InpRange3_SL_Calc_Mode = SL_CALC_ATR; // حالت محاسبه بافر استاپ لاس رنج 3
input int InpRange3_SL_ATR_Period = 14; // دوره ATR برای بافر استاپ لاس رنج 3
input double InpRange3_SL_ATR_Multiplier = 1.5; // ضریب ATR برای بافر استاپ لاس رنج 3
input ENUM_TRAILING_MODE InpRange3_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 3
input int InpRange3_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج 3
input double InpRange3_Trailing_ATR_Multiplier = 1.0; // ضریب ATR برای تریلینگ رنج 3
input double InpRange3_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 3
input double InpRange3_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج 3
input int InpRange3_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج 3 (0-24)
input color InpRange3_Color = clrGreen; // رنگ مستطیل رنج 3

// گروه ورودی برای تنظیمات رنج ۴ (چهارمین رنج، برای سفارشی‌سازی اضافی یا تست)
input group "تنظیمات رنج 4"
input bool InpRange4_Enabled = false; // فعال کردن رنج 4
input ENUM_TIMEFRAMES InpRange4_Execution_Timeframe = PERIOD_CURRENT; // تایم‌فریم اجرا رنج 4
input ENUM_TIMEFRAMES InpRange4_TrendFilter_Timeframe = PERIOD_CURRENT; // تایم‌فریم فیلتر روند رنج 4
input int InpRange4_Start_Hour = 0; // ساعت شروع رنج 4 (0-23)
input int InpRange4_Start_Minute = 0; // دقیقه شروع رنج 4 (0-59)
input int InpRange4_End_Hour = 0; // ساعت پایان رنج 4 (0-23)
input int InpRange4_End_Minute = 0; // دقیقه پایان رنج 4 (0-59)
input int InpRange4_MinRangePoints = 50; // حداقل ارتفاع رنج 4 به پوینت
input int InpRange4_MaxRangePoints = 500; // حداکثر ارتفاع رنج 4 به پوینت
input ENUM_PLACEMENT_MODE InpRange4_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 4
input int InpRange4_ATR_Period = 14; // دوره ATR برای ثبت سفارش رنج 4
input double InpRange4_ATR_Multiplier = 1.2; // ضریب ATR برای ثبت سفارش رنج 4
input ENUM_SL_STRATEGY InpRange4_SL_Strategy = SL_OPPOSITE_SIDE; // استراتژی جایگذاری استاپ لاس رنج 4
input ENUM_SL_CALC_MODE InpRange4_SL_Calc_Mode = SL_CALC_ATR; // حالت محاسبه بافر استاپ لاس رنج 4
input int InpRange4_SL_ATR_Period = 14; // دوره ATR برای بافر استاپ لاس رنج 4
input double InpRange4_SL_ATR_Multiplier = 1.5; // ضریب ATR برای بافر استاپ لاس رنج 4
input ENUM_TRAILING_MODE InpRange4_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 4
input int InpRange4_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج 4
input double InpRange4_Trailing_ATR_Multiplier = 1.0; // ضریب ATR برای تریلینگ رنج 4
input double InpRange4_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 4
input double InpRange4_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج 4
input int InpRange4_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج 4 (0-24)
input color InpRange4_Color = clrYellow; // رنگ مستطیل رنج 4

#endif
```
```mql5
//+------------------------------------------------------------------+
//|                                                       Elemento.mq5 |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل اصلی اکسپرت Elemento است و نقطه ورود برنامه (OnInit, OnDeinit, OnTick, OnTimer) را مدیریت می‌کند.
// استراتژی کلی اکسپرت: Elemento بر اساس استراتژی شکست رنج عمل می‌کند که رنج‌های زمانی را شناسایی می‌کند، منتظر شکست با افست می‌ماند، با تایید اختیاری قیمت و فیلتر ایچیموکو تأیید می‌کند، معامله باز می‌کند و سپس با خروج پله‌ای و تریلینگ مدیریت می‌کند. این استراتژی برای بازارهای رنجی مانند سشن آسیا مناسب است و با فیلتر روند از معاملات خلاف جهت جلوگیری می‌کند تا ریسک کاهش یابد. اکسپرت از چهار رنج همزمان پشتیبانی می‌کند تا پوشش کامل بازار را فراهم کند.
// منطق فایل Elemento.mq5: این فایل هماهنگ‌کننده اصلی است. در OnInit اطلاعات نماد را کش می‌کند، ورودی‌ها را ولید می‌کند، چهار نمونه CRange را مقداردهی می‌کند، هندل‌های ATR را ایجاد می‌کند، فیلتر روند و مدیر نمایش را راه‌اندازی می‌کند. در OnDeinit تمام منابع را آزاد و پاکسازی سخت انجام می‌دهد. در OnTick کندل‌های جدید را تشخیص می‌دهد، رنج‌ها را به‌روزرسانی می‌کند، وضعیت روند هر رنج را به طور جداگانه نمایش می‌دهد و در صورت بسته بودن بازار پاکسازی می‌کند. در OnTimer (هر ۶۰ ثانیه) معاملات فعال را مدیریت می‌کند تا بار OnTick کاهش یابد. متغیرهای جهانی مانند g_ranges برای نگهداری رنج‌ها، g_lastBarTime برای تشخیص کندل جدید، و g_trendFilter برای فیلتر روند استفاده می‌شوند. تغییرات جدید در نسخه 1.92: حذف چک ولیدیشن Inp_Confirmation_Timeout (زیرا حذف شده)، چک تاریخچه کندل‌ها (Bars) برای هر رنج جداگانه بر اساس تایم‌فریم اجرای آن رنج انجام می‌شود تا از لود کافی داده‌ها اطمینان حاصل شود. این فایل سایر فایل‌ها را include می‌کند تا استراتژی کامل شود.

#property copyright "Copyright 2025, Hipoalgorithm Team"
#property link      "https://hipoalgorithm.com"
#property version   "1.92" // ورژن آپدیت شده برای اعمال تغییرات جدید (اصلاح منطق تایمر کندلی و جایگزینی با ابطال بر اساس بازگشت قیمت)
#property strict

#include "Settings.mqh" // فایل تنظیمات برای دسترسی به ورودی‌ها و enums
#include "CRange.mqh" // کلاس مدیریت رنج برای هر رنج جداگانه
#include "TrendFilter.mqh" // کلاس فیلتر روند برای تعیین جهت روند
#include "VisualManager.mqh" // کلاس مدیر نمایش برای نمایش بصری روی چارت

// آرایه برای ذخیره ۴ رنج (هر کدام یک نمونه از کلاس CRange برای مدیریت مستقل رنج‌ها)
CRange g_ranges[4];

// آرایه برای ذخیره زمان آخرین کندل هر تایم‌فریم (برای تشخیص کندل جدید و جلوگیری از اجرای مکرر)
datetime g_lastBarTime[4];

// آرایه برای هندل‌های ATR shared (برای هر رنج یک هندل ATR برای محاسبات افست، SL و تریلینگ)
int g_atrHandles[4];

// متغیرهای کش‌شده برای بهینه‌سازی (اطلاعات نماد برای محاسبه ریسک، حجم و فاصله‌ها به طور دقیق و مستقل از نوع نماد)
double g_tickValue; // ارزش تیک برای محاسبه ریسک
double g_tickSize; // اندازه تیک برای محاسبات دقیق
double g_volumeStep; // گام حجم برای راند کردن لات
double g_volumeMin; // حداقل حجم مجاز
double g_volumeMax; // حداکثر حجم مجاز

// فلگ برای تشخیص حالت tester (برای رفتار متفاوت مانند نادیده گرفتن چک بازار بسته در بک‌تست)
bool g_isTester = false;

// فیلتر روند جهانی (نمونه‌ای از CTrendFilter برای استفاده مشترک در تمام رنج‌ها و تعیین جهت روند)
CTrendFilter g_trendFilter;

// مدیر نمایش جهانی (نمونه‌ای از CVisualManager برای نمایش بصری وضعیت روند هر رنج روی چارت)
CVisualManager g_visualManager;

// تابع شروع اکسپرت (OnInit): مقداردهی اولیه، چک ولیدیشن و راه‌اندازی تایمر
int OnInit()
{
   g_isTester = MQLInfoInteger(MQL_TESTER); // تشخیص حالت تستر برای تنظیم رفتار خاص (مانند نادیده گرفتن چک بازار بسته)
   if(InpDebugMode) Print("شروع مقداردهی اکسپرت Elemento نسخه 1.92..."); // چاپ پیام دیباگ برای شروع مقداردهی

   // کش اطلاعات سیمبل (نماد) برای استفاده در محاسبه ریسک، حجم و فاصله‌ها
   g_tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE); // کش ارزش تیک برای محاسبات ریسک
   g_tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE); // کش اندازه تیک برای دقت محاسبات
   g_volumeStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP); // کش گام حجم برای راند کردن لات
   g_volumeMin = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN); // کش حداقل حجم مجاز برای معاملات
   g_volumeMax = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX); // کش حداکثر حجم مجاز برای معاملات

   // چک ولید بودن اطلاعات نماد (اگر صفر یا نامعتبر باشد، اکسپرت متوقف می‌شود برای جلوگیری از محاسبات اشتباه)
   if(g_tickValue <= 0 || g_tickSize <= 0 || g_volumeStep <= 0)
   {
      Print("خطای مرگبار: اطلاعات نماد نامعتبر است (tickValue/tickSize/volumeStep). اکسپرت متوقف می‌شود."); // چاپ خطا و توقف اکسپرت
      return(INIT_FAILED); // بازگشت شکست مقداردهی
   }

   // ولیدیشن ورودی‌های عمومی (اطمینان از محدوده مجاز برای جلوگیری از خطاهای منطقی)
   if(InpRiskPercent <= 0 || InpRiskPercent > 5.0)
   {
      Print("خطا: RiskPercent باید بین 0.1 تا 5.0 باشد."); // چاپ خطا برای ریسک نامعتبر
      return(INIT_PARAMETERS_INCORRECT); // بازگشت شکست پارامترها
   }

   // مقداردهی ۴ رنج (برای هر رنج فعال، پارامترها را از ورودی‌ها گرفته، هندل ATR می‌سازد و Init می‌کند)
   for(int i = 0; i < 4; i++) // حلقه برای مقداردهی چهار رنج
   {
      bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled; // چک فعال بودن رنج بر اساس ورودی
      if(!enabled)
      {
         if(InpDebugMode) Print("رنج ", i + 1, " غیرفعال است. رد می‌شود."); // چاپ دیباگ برای رنج غیرفعال
         continue; // پرش به رنج بعدی
      }

      long magic = InpBaseMagicNumber + i; // مجیک نامبر منحصربه‌فرد برای هر رنج جهت تمایز معاملات
      int startHour = i == 0 ? InpRange1_Start_Hour : i == 1 ? InpRange2_Start_Hour : i == 2 ? InpRange3_Start_Hour : InpRange4_Start_Hour; // ساعت شروع رنج
      int startMinute = i == 0 ? InpRange1_Start_Minute : i == 1 ? InpRange2_Start_Minute : i == 2 ? InpRange3_Start_Minute : InpRange4_Start_Minute; // دقیقه شروع رنج
      int endHour = i == 0 ? InpRange1_End_Hour : i == 1 ? InpRange2_End_Hour : i == 2 ? InpRange3_End_Hour : InpRange4_End_Hour; // ساعت پایان رنج
      int endMinute = i == 0 ? InpRange1_End_Minute : i == 1 ? InpRange2_End_Minute : i == 2 ? InpRange3_End_Minute : InpRange4_End_Minute; // دقیقه پایان رنج

      // چک ولید بودن ساعات و دقیقه‌ها (برای جلوگیری از زمان‌های نامعتبر)
      if(startHour < 0 || startHour > 23 || startMinute < 0 || startMinute > 59 ||
         endHour < 0 || endHour > 23 || endMinute < 0 || endMinute > 59)
      {
         Print("خطا: ساعات یا دقیقه‌های رنج ", i + 1, " نامعتبر است."); // چاپ خطا برای زمان نامعتبر
         return(INIT_PARAMETERS_INCORRECT); // بازگشت شکست پارامترها
      }

      ENUM_TIMEFRAMES timeframe = i == 0 ? InpRange1_Execution_Timeframe : i == 1 ? InpRange2_Execution_Timeframe : i == 2 ? InpRange3_Execution_Timeframe : InpRange4_Execution_Timeframe; // تایم‌فریم اجرا رنج
      int atrPeriod = i == 0 ? InpRange1_ATR_Period : i == 1 ? InpRange2_ATR_Period : i == 2 ? InpRange3_ATR_Period : InpRange4_ATR_Period; // دوره ATR برای افست
      g_atrHandles[i] = iATR(_Symbol, timeframe, atrPeriod); // ایجاد هندل ATR برای محاسبات پویا
      if(g_atrHandles[i] == INVALID_HANDLE)
      {
         Print("خطا در ایجاد هندل ATR برای رنج ", i + 1); // چاپ خطا برای هندل نامعتبر
         return(INIT_FAILED); // بازگشت شکست مقداردهی
      }

      ENUM_SL_STRATEGY slStrategy = i == 0 ? InpRange1_SL_Strategy : i == 1 ? InpRange2_SL_Strategy : i == 2 ? InpRange3_SL_Strategy : InpRange4_SL_Strategy; // استراتژی SL
      ENUM_SL_CALC_MODE slCalcMode = i == 0 ? InpRange1_SL_Calc_Mode : i == 1 ? InpRange2_SL_Calc_Mode : i == 2 ? InpRange3_SL_Calc_Mode : InpRange4_SL_Calc_Mode; // حالت محاسبه بافر SL
      int slAtrPeriod = i == 0 ? InpRange1_SL_ATR_Period : i == 1 ? InpRange2_SL_ATR_Period : i == 2 ? InpRange3_SL_ATR_Period : InpRange4_SL_ATR_Period; // دوره ATR برای SL
      double slAtrMultiplier = i == 0 ? InpRange1_SL_ATR_Multiplier : i == 1 ? InpRange2_SL_ATR_Multiplier : i == 2 ? InpRange3_SL_ATR_Multiplier : InpRange4_SL_ATR_Multiplier; // ضریب ATR برای SL

      // فراخوانی Init برای هر رنج با پارامترهای مربوطه (مقداردهی کامل رنج، شامل SL strategy جدید)
      if(!g_ranges[i].Init(
         i + 1, magic, timeframe, startHour, startMinute, endHour, endMinute,
         i == 0 ? InpRange1_MinRangePoints : i == 1 ? InpRange2_MinRangePoints : i == 2 ? InpRange3_MinRangePoints : InpRange4_MinRangePoints,
         i == 0 ? InpRange1_MaxRangePoints : i == 1 ? InpRange2_MaxRangePoints : i == 2 ? InpRange3_MaxRangePoints : InpRange4_MaxRangePoints,
         i == 0 ? InpRange1_Placement_Mode : i == 1 ? InpRange2_Placement_Mode : i == 2 ? InpRange3_Placement_Mode : InpRange4_Placement_Mode,
         atrPeriod,
         i == 0 ? InpRange1_ATR_Multiplier : i == 1 ? InpRange2_ATR_Multiplier : i == 2 ? InpRange3_ATR_Multiplier : InpRange4_ATR_Multiplier,
         slStrategy, slCalcMode, slAtrPeriod, slAtrMultiplier,
         i == 0 ? InpRange1_Trailing_Mode : i == 1 ? InpRange2_Trailing_Mode : i == 2 ? InpRange3_Trailing_Mode : InpRange4_Trailing_Mode,
         i == 0 ? InpRange1_Trailing_ATR_Period : i == 1 ? InpRange2_Trailing_ATR_Period : i == 2 ? InpRange3_Trailing_ATR_Period : InpRange4_Trailing_ATR_Period,
         i == 0 ? InpRange1_Trailing_ATR_Multiplier : i == 1 ? InpRange2_Trailing_ATR_Multiplier : i == 2 ? InpRange3_Trailing_ATR_Multiplier : InpRange4_Trailing_ATR_Multiplier,
         i == 0 ? InpRange1_RR_Ratio : i == 1 ? InpRange2_RR_Ratio : i == 2 ? InpRange3_RR_Ratio : InpRange4_RR_Ratio,
         i == 0 ? InpRange1_PartialClosePercent : i == 1 ? InpRange2_PartialClosePercent : i == 2 ? InpRange3_PartialClosePercent : InpRange4_PartialClosePercent,
         i == 0 ? InpRange1_Cleanup_Hours : i == 1 ? InpRange2_Cleanup_Hours : i == 2 ? InpRange3_Cleanup_Hours : InpRange4_Cleanup_Hours,
         i == 0 ? InpRange1_Color : i == 1 ? InpRange2_Color : i == 2 ? InpRange3_Color : InpRange4_Color,
         i == 0 ? InpRange1_TrendFilter_Timeframe : i == 1 ? InpRange2_TrendFilter_Timeframe : i == 2 ? InpRange3_TrendFilter_Timeframe : InpRange4_TrendFilter_Timeframe,
         g_atrHandles[i]
      ))
      {
         Print("خطا در مقداردهی رنج ", i + 1, ": ", GetLastError()); // چاپ خطا برای شکست Init
         return(INIT_PARAMETERS_INCORRECT); // بازگشت شکست پارامترها
      }
   }

   // مقداردهی فیلتر روند جهانی (برای تعیین جهت روند در تمام رنج‌ها)
   if(!g_trendFilter.Init())
   {
      Print("خطا در مقداردهی فیلتر روند."); // چاپ خطا برای شکست Init فیلتر
      return(INIT_FAILED); // بازگشت شکست مقداردهی
   }
   // مقداردهی مدیر نمایش جهانی (برای نمایش وضعیت روند هر رنج روی چارت)
   if(!g_visualManager.Init())
   {
      Print("خطا در مقداردهی مدیر نمایش."); // چاپ خطا برای شکست Init نمایشگر
      return(INIT_FAILED); // بازگشت شکست مقداردهی
   }

   // مقداردهی اولیه زمان آخرین کندل‌ها (برای تشخیص کندل جدید در OnTick)
   for(int i = 0; i < 4; i++) // حلقه برای ریست زمان‌ها
   {
      g_lastBarTime[i] = 0; // تنظیم زمان اولیه به صفر
   }

   // راه‌اندازی تایمر برای مدیریت معاملات هر ۶۰ ثانیه (بهینه‌سازی عملکرد OnTick)
   EventSetTimer(60); // تنظیم تایمر ۶۰ ثانیه

   Print("مقداردهی اکسپرت Elemento نسخه 1.92 با موفقیت انجام شد."); // چاپ موفقیت مقداردهی
   return(INIT_SUCCEEDED); // بازگشت موفقیت
}

// تابع پایان اکسپرت (OnDeinit): پاکسازی منابع و پاکسازی سخت تمام رنج‌ها
void OnDeinit(const int reason)
{
   if(InpDebugMode) Print("دفع مقداردهی اکسپرت Elemento نسخه 1.92. دلیل: ", reason); // چاپ دیباگ برای دلیل دفع

   // پاکسازی سخت تمام رنج‌ها برای بستن معاملات باقی‌مانده و ریست (در صورت کرش یا خروج)
   for(int i = 0; i < 4; i++) // حلقه برای پاکسازی سخت هر رنج
   {
      g_ranges[i].HardCleanup(); // فراخوانی پاکسازی سخت
   }

   // دفع هر رنج و آزادسازی هندل ATR مربوطه
   for(int i = 0; i < 4; i++) // حلقه برای دفع رنج‌ها
   {
      g_ranges[i].Deinit(); // دفع رنج
      if(g_atrHandles[i] != INVALID_HANDLE) // چک هندل معتبر
      {
         IndicatorRelease(g_atrHandles[i]); // آزادسازی هندل ATR
      }
   }

   // دفع فیلتر روند و مدیر نمایش
   g_trendFilter.Deinit(); // دفع فیلتر روند
   g_visualManager.Deinit(); // دفع مدیر نمایش
   ObjectsDeleteAll(0, "Range_"); // حذف تمام اشیاء گرافیکی با پیشوند Range_ برای پاکسازی چارت
   Print("تمامی اشیاء گرافیکی پاکسازی شدند."); // چاپ موفقیت پاکسازی اشیاء

   // خاموش کردن تایمر
   EventKillTimer(); // خاموش کردن تایمر
}

// تابع اصلی هر تیک (OnTick): تشخیص کندل جدید، به‌روزرسانی رنج‌ها و چک بازار
void OnTick()
{
   // چک روز جدید برای به‌روزرسانی کش اطلاعات نماد (در صورت تغییر مشخصات بروکر)
   static datetime lastDay = 0; // متغیر استاتیک برای ذخیره روز آخرین
   datetime currentDay = TimeCurrent() / 86400; // محاسبه روز فعلی
   if(currentDay != lastDay) // چک تغییر روز
   {
      // به‌روزرسانی کش اطلاعات نماد
      g_tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE); // به‌روزرسانی ارزش تیک
      g_tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE); // به‌روزرسانی اندازه تیک
      g_volumeStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP); // به‌روزرسانی گام حجم
      g_volumeMin = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN); // به‌روزرسانی حداقل حجم
      g_volumeMax = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX); // به‌روزرسانی حداکثر حجم
      if(InpDebugMode) Print("به‌روزرسانی کش اطلاعات نماد در روز جدید."); // چاپ دیباگ برای به‌روزرسانی
      lastDay = currentDay; // ذخیره روز جدید
   }

   // اگر تستر نیست و بازار بسته است یا یک ساعت قبل از بسته شدن، پاکسازی سخت انجام می‌شود
   if(!g_isTester && (IsMarketClosed() || IsOneHourBeforeMarketClose())) // چک شرایط بازار بسته
   {
      for(int i = 0; i < 4; i++) // حلقه برای هر رنج
      {
         bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled; // چک فعال بودن
         if(enabled)
         {
            g_ranges[i].HardCleanup(); // پاکسازی سخت رنج (بستن معاملات و ریست برای جلوگیری از معاملات باز در تعطیلات)
         }
      }
      return; // خروج از تابع
   }

   bool newBarDetected = false; // فلگ برای تشخیص کندل جدید و به‌روزرسانی نمایش
   string trendDisplayText = ""; // متن کامل نمایش وضعیت روند هر رنج
   for(int i = 0; i < 4; i++) // حلقه برای هر رنج
   {
      bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled; // چک فعال بودن رنج
      if(!enabled) continue; // پرش اگر غیرفعال

      ENUM_TIMEFRAMES timeframe = g_ranges[i].GetTimeframe(); // گرفتن تایم‌فریم اجرا رنج

      // چک لود کافی تاریخچه برای هر رنج جداگانه (بر اساس تایم‌فریم اجرای رنج برای جلوگیری از اجرای زودرس)
      if(Bars(_Symbol, timeframe) < 200) // چک تعداد بارها
      {
         if(InpDebugMode) Print("تاریخچه کافی برای رنج ", i + 1, " لود نشده است. رد می‌شود."); // چاپ دیباگ برای تاریخچه ناکافی
         continue; // پرش به رنج بعدی
      }

      datetime currentBarTime = iTime(_Symbol, timeframe, 0); // زمان کندل فعلی برای تشخیص جدید بودن
      if(currentBarTime == 0) // چک زمان معتبر
      {
         if(InpDebugMode) Print("خطا: iTime مقدار نامعتبر برای رنج ", i + 1); // چاپ خطا
         continue; // پرش
      }

      // تشخیص کندل جدید و به‌روزرسانی رنج (فقط در کندل جدید اجرا می‌شود تا بار کاهش یابد)
      if(currentBarTime > g_lastBarTime[i]) // چک کندل جدید
      {
         if(InpDebugMode) Print("کندل جدید برای رنج ", i + 1, " در تایم‌فریم ", EnumToString(timeframe)); // چاپ دیباگ برای کندل جدید
         g_ranges[i].UpdateOnNewBar(); // به‌روزرسانی ماشین حالت رنج
         g_lastBarTime[i] = currentBarTime; // ذخیره زمان جدید
         newBarDetected = true; // تنظیم فلگ کندل جدید
      }

      // چک کندل جدید در تایم‌فریم فیلتر برای آپدیت نمایش روند آن رنج
      ENUM_TIMEFRAMES trendTf = g_ranges[i].GetTrendFilterTimeframe(); // گرفتن تایم‌فریم فیلتر
      datetime currentTrendBarTime = iTime(_Symbol, trendTf, 0); // زمان کندل فیلتر فعلی
      if(currentTrendBarTime > g_ranges[i].GetLastFilterBarTime()) // چک کندل جدید فیلتر
      {
         ENUM_TREND_DIRECTION trend = g_trendFilter.GetTrendDirection(trendTf); // گرفتن جهت روند
         string trendStr = trend == TREND_BUY ? "Bullish" : trend == TREND_SELL ? "Bearish" : "Neutral"; // تبدیل جهت به رشته
         string tfStr = EnumToString(trendTf); // تبدیل تایم‌فریم به رشته
         trendDisplayText += "Range " + IntegerToString(i + 1) + " (Filter " + tfStr + "): " + trendStr + "\n"; // اضافه به متن نمایش
         g_ranges[i].UpdateLastFilterBarTime(currentTrendBarTime); // آپدیت زمان در رنج
         if(InpDebugMode) Print("آپدیت روند رنج ", i + 1, ": ", trendStr); // چاپ دیباگ برای آپدیت روند
      }

      // مدیریت معاملات به OnTimer منتقل شده، اینجا فقط چک حالت برای اطمینان
      if(enabled && g_ranges[i].GetCurrentState() == MANAGING_TRADE) // چک حالت مدیریت معامله
      {
         // هیچ عملی در OnTick، مدیریت در OnTimer انجام می‌شود
      }
   }

   // آپدیت نمایشگر با متن کامل وضعیت روند هر رنج (اگر نمایش فعال باشد)
   if(Inp_Visual_ShowTrendStatus && trendDisplayText != "") // چک فعال بودن نمایش و متن موجود
   {
      g_visualManager.UpdateTrendStatus(trendDisplayText); // به‌روزرسانی نمایشگر
   }
}

// تابع تایمر (OnTimer): مدیریت معاملات فعال هر ۶۰ ثانیه برای کاهش بار OnTick
void OnTimer()
{
   for(int i = 0; i < 4; i++) // حلقه برای هر رنج
   {
      bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled; // چک فعال بودن
      if(enabled && g_ranges[i].GetCurrentState() == MANAGING_TRADE) // چک حالت مدیریت
      {
         g_ranges[i].ManageActiveTrade(); // مدیریت خروج پله‌ای، بریک‌اون و تریلینگ
      }
   }
}

// تابع چک یک ساعت قبل از بسته شدن بازار (برای فعال کردن پاکسازی سخت و جلوگیری از معاملات باز در تعطیلات)
bool IsOneHourBeforeMarketClose()
{
   datetime from = 0, to = 0; // متغیرهای زمان جلسه
   MqlDateTime dt; // ساختار زمان
   TimeToStruct(TimeTradeServer(), dt); // تبدیل زمان سرور به ساختار
   ENUM_DAY_OF_WEEK day = (ENUM_DAY_OF_WEEK)dt.day_of_week; // روز هفته
   datetime max_to = 0; // حداکثر زمان بسته شدن
   uint session = 0; // شمارنده جلسه
   // پیدا کردن آخرین جلسه معاملاتی روز برای تعیین زمان بسته شدن
   while(SymbolInfoSessionTrade(_Symbol, day, session, from, to)) // حلقه جلسات
   {
      if(to > max_to) max_to = to; // ذخیره حداکثر زمان
      session++; // افزایش شمارنده
   }
   if(max_to == 0) // چک عدم یافتن جلسه
   {
      if(InpDebugMode) Print("خطا در SymbolInfoSessionTrade: ", GetLastError()); // چاپ خطا
      return false; // بازگشت نادرست
   }
   datetime currentTime = TimeTradeServer(); // زمان فعلی سرور
   // چک اگر زمان فعلی یک ساعت قبل از بسته شدن باشد (برای پاکسازی پیشگیرانه)
   if(currentTime >= (max_to - 3600) && currentTime < max_to) // چک محدوده زمان
   {
      if(InpDebugMode) Print("یک ساعت قبل از بسته شدن بازار: پاکسازی سخت فعال شد."); // چاپ دیباگ
      return true; // بازگشت درست
   }
   return false; // بازگشت نادرست
}

// تابع چک بسته بودن بازار (برای فعال کردن پاکسازی نرم و جلوگیری از عملیات در تعطیلات)
bool IsMarketClosed()
{
   datetime from = 0, to = 0; // متغیرهای زمان جلسه
   MqlDateTime dt; // ساختار زمان
   TimeToStruct(TimeTradeServer(), dt); // تبدیل زمان سرور به ساختار
   ENUM_DAY_OF_WEEK day = (ENUM_DAY_OF_WEEK)dt.day_of_week; // روز هفته
   uint session = 0; // شمارنده جلسه
   // چک جلسات معاملاتی روز برای تعیین وضعیت بازار
   while(SymbolInfoSessionTrade(_Symbol, day, session, from, to)) // حلقه جلسات
   {
      if(TimeTradeServer() >= from && TimeTradeServer() <= to) // چک داخل جلسه
      {
         return false; // بازار باز است، عملیات ادامه می‌یابد
      }
      session++; // افزایش شمارنده
   }
   // چک تعطیلات آخر هفته (شنبه و یکشنبه)
   if(dt.day_of_week == 6 || dt.day_of_week == 0) // چک شنبه یا یکشنبه
   {
      if(InpDebugMode) Print("بازار تعطیل است (weekend)."); // چاپ دیباگ
      return true; // بازگشت درست
   }
   if(InpDebugMode) Print("بازار تعطیل است (خارج از جلسه)."); // چاپ دیباگ
   return true; // بازگشت درست
}
```
```mql5
//+------------------------------------------------------------------+
//|                                                         CRange.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CRange را تعریف می‌کند که هسته استراتژی شکست رنج را مدیریت می‌کند.
// استراتژی کلی اکسپرت: هر رنج زمانی (مانند سشن آسیا) را شناسایی می‌کند، سقف و کف آن را تعیین می‌کند، اگر ارتفاع معتبر باشد، با افست (بر اساس ATR یا درصد) مسلح می‌شود، منتظر کندل بریک (شکست) می‌ماند، به صورت اختیاری قیمت را تأیید می‌کند (اگر Inp_PriceConfirmation_Enabled فعال باشد)، فیلتر روند را به طور مستقل و در لحظه چک می‌کند، معامله باز می‌کند و سپس معامله را با خروج پله‌ای (هنگام رسیدن به RR)، انتقال SL به ورود، و تریلینگ مدیریت می‌کند. این استراتژی برای بازارهای رنجی با شکست قوی مناسب است و با فیلتر ایچیموکو ریسک خلاف روند را کاهش می‌دهد.
// منطق فایل CRange.mqh: این کلاس برای هر رنج جداگانه عمل می‌کند. ماشین حالت (ENUM_RANGE_STATE) جریان را کنترل می‌کند: از انتظار رنج جدید شروع می‌شود، رنج را شناسایی و ولید می‌کند، مسلح می‌کند، منتظر بریک و تأییدها می‌ماند، معامله اجرا می‌کند و مدیریت می‌کند. پاکسازی نرم برای ریست روزانه و سخت برای بستن معاملات در تعطیلات استفاده می‌شود. کش ATR برای بهینه‌سازی محاسبات، و فراخوانی مستقل g_trendFilter برای فیلتر دینامیک. تغییرات شامل: اعمال ENUM_SL_STRATEGY در ExecuteTrade برای محاسبه SL (base point بر اساس strategy)، رفع باگ فیلتر با فراخوانی مستقل GetTrendDirection در لحظه، اضافه گتر UpdateLastFilterBarTime برای هماهنگی نمایش، چک اضافی برای cleanupTime، بهینه جستجو تیکت، خروج پله‌ای بهبودیافته، تریلینگ با حداقل تغییر، SL با بافر minStop، بررسی فیلتر روند در هر کندل جدید تایم‌فریم فیلتر، و مدیریت اختیاری تایید قیمت (اگر خاموش، مستقیم از بریک به فیلتر یا ورود). همچنین چک برای عدم وجود کندل در بازه رنج اضافه شده تا از خطاهای Edge Case جلوگیری شود. اصلاح کش ATR برای ثابت بودن در ورود و پویا در تریلینگ، با ریست کش در پاکسازی‌ها. تغییرات جدید در نسخه 1.92: حذف محدودیت زمانی تایمر کندلی (m_waitCounter و Inp_Confirmation_Timeout حذف شدند)، جایگزینی با شرط ابطال بر اساس بازگشت قیمت به داخل رنج (در ProcessEntryAttempt)، ادغام حالت‌های انتظار در AWAITING_ENTRY_CONFIRMATION_BUY/SELL، حذف WaitForPriceConfirmation و WaitForFilterConfirmation، اضافه ProcessEntryAttempt برای چک دینامیک در هر کندل، و ResetToArmedState برای ریست بدون حذف مسیرها (برای حفظ فرصت‌های معاملاتی). همچنین اضافه شدن چک بر اساس ENUM_INVALIDATION_MODE برای انتخاب استراتژی ابطال (صبور یا تهاجمی) در ProcessEntryAttempt.

#ifndef CRANGE_MQH
#define CRANGE_MQH

#include "TradeManager.mqh" // کلاس مدیریت معاملات برای عملیات مانند بستن و تریلینگ
#include "RiskManager.mqh" // کلاس مدیریت ریسک برای محاسبه حجم
#include "TimeHelper.mqh" // کلاس کمک زمان برای محاسبات زمانی رنج
#include "TrendFilter.mqh" // کلاس فیلتر روند برای چک ایچیموکو
#include <Trade\Trade.mqh> // کلاس معامله برای ارسال سفارشات

// تعریف enum برای حالت‌های رنج (ماشین حالت برای کنترل جریان استراتژی از شناسایی تا مدیریت)
enum ENUM_RANGE_STATE
{
   RANGE_WAITING,                          // حالت انتظار برای رنج جدید (شروع روزانه) - منتظر شناسایی رنج جدید
   RANGE_IDENTIFIED,                       // رنج شناسایی و ولید شده (سقف/کف تعیین شده) - رنج معتبر پیدا شده
   ARMED_AND_WAITING,                      // رنج مسلح شده با افست و انتظار برای بریک (رسم خطوط خرید/فروش) - منتظر کندل شکست
   AWAITING_ENTRY_CONFIRMATION_BUY,        // حالت انتظار ترکیبی برای تایید ورود خرید (تایید قیمت و فیلتر روند بدون محدودیت زمانی) - چک دینامیک برای ورود خرید
   AWAITING_ENTRY_CONFIRMATION_SELL,       // حالت انتظار ترکیبی برای تایید ورود فروش (تایید قیمت و فیلتر روند بدون محدودیت زمانی) - چک دینامیک برای ورود فروش
   MANAGING_TRADE,                         // مدیریت معامله فعال (خروج پله‌ای، بریک‌اون، تریلینگ) - مدیریت معامله باز
   RANGE_EXPIRED                           // رنج منقضی شده (پس از پاکسازی) - رنج تمام شده و منتظر ریست
};

// کلاس CRange برای مدیریت مستقل هر رنج در استراتژی شکست
class CRange
{
private:
   int m_rangeIndex;                       // شماره رنج (1 تا 4 برای تمایز) - شناسایی رنج جاری
   long m_magicNumber;                     // مجیک نامبر رنج برای شناسایی معاملات - تمایز معاملات رنج‌ها
   ENUM_TIMEFRAMES m_timeframe;            // تایم‌فریم اجرا رنج برای محاسبات بارها - تایم‌فریم اصلی عملیات
   int m_startHour, m_startMinute;         // ساعت و دقیقه شروع رنج برای محاسبه زمان - تعریف بازه شروع
   int m_endHour, m_endMinute;             // ساعت و دقیقه پایان رنج برای محاسبه زمان - تعریف بازه پایان
   int m_minRangePoints, m_maxRangePoints; // حداقل و حداکثر ارتفاع رنج به پوینت برای فیلتر کیفیت - فیلتر رنج‌های نامناسب
   ENUM_PLACEMENT_MODE m_placementMode;    // حالت افست شکست (ATR یا درصد) - نحوه محاسبه افست شکست
   int m_atrPeriod;                        // دوره ATR برای افست - دوره محاسبه ATR افست
   double m_atrMultiplier;                 // ضریب ATR برای افست - تنظیم حساسیت افست
   ENUM_SL_STRATEGY m_slStrategy;          // استراتژی جایگذاری SL (مقابل یا سطح شکست) - پایه SL
   ENUM_SL_CALC_MODE m_slCalcMode;         // حالت محاسبه بافر SL (ATR یا درصد) - نحوه محاسبه بافر SL
   int m_slAtrPeriod;                      // دوره ATR برای بافر SL - دوره ATR بافر SL
   double m_slAtrMultiplier;               // ضریب ATR برای بافر SL - تنظیم بافر SL
   ENUM_TRAILING_MODE m_trailingMode;      // حالت تریلینگ (ATR یا ساده) - نحوه تریلینگ
   int m_trailingAtrPeriod;                // دوره ATR برای تریلینگ - دوره ATR تریلینگ
   double m_trailingAtrMultiplier;         // ضریب ATR برای تریلینگ - تنظیم فاصله تریلینگ
   double m_rrRatio;                       // نسبت R:R برای TP و خروج پله‌ای - نسبت سود به ریسک
   double m_partialClosePercent;           // درصد خروج پله‌ای هنگام رسیدن به RR - درصد بستن جزئی
   int m_cleanupHours;                     // ساعت‌های پاکسازی پس از پایان رنج - زمان انقضا رنج
   color m_color;                          // رنگ مستطیل رنج برای نمایش - رنگ گرافیکی رنج
   double m_rangeHigh, m_rangeLow;         // سقف و کف شناسایی‌شده رنج - سطوح رنج
   datetime m_cleanupTime;                 // زمان محاسبه‌شده پاکسازی - زمان انقضا
   string m_rangeObjectName;               // نام شیء گرافیکی مستطیل رنج - نام مستطیل گرافیکی
   ENUM_RANGE_STATE m_currentState;        // حالت فعلی ماشین حالت - حالت جاری رنج
   int m_atrHandle;                        // هندل ATR اصلی برای افست - هندل ATR افست
   int m_slAtrHandle;                      // هندل ATR برای SL - هندل ATR SL
   int m_trailingAtrHandle;                // هندل ATR برای تریلینگ - هندل ATR تریلینگ
   bool m_trailingActivated;               // فلگ فعال شدن تریلینگ پس از خروج پله‌ای - فعال‌سازی تریلینگ
   ulong m_activeTicket;                   // تیکت معامله فعال برای مدیریت - تیکت معامله باز
   double m_cachedATR;                     // کش ATR اصلی برای بهینه‌سازی (فقط برای ورود ثابت استفاده شود) - کش ATR افست
   double m_cachedSlATR;                   // کش ATR برای SL (فقط برای ورود ثابت استفاده شود) - کش ATR SL
   double m_cachedTrailingATR;             // کش ATR برای تریلینگ (فقط برای ورود ثابت استفاده شود، برای مدیریت پویا استفاده نشود) - کش ATR تریلینگ
   ENUM_TIMEFRAMES m_trendFilterTimeframe; // تایم‌فریم فیلتر روند برای ایچیموکو - تایم‌فریم فیلتر
   double m_potentialBuyPrice;             // قیمت افست خرید برای بریک - سطح ورود خرید
   double m_potentialSellPrice;            // قیمت افست فروش برای بریک - سطح ورود فروش
   double m_breakerCandleLevel;            // سطح High/Low کندل بریک برای تأیید - سطح کندل شکست
   string m_buyLineName;                   // نام خط گرافیکی خرید - نام خط خرید
   string m_sellLineName;                  // نام خط گرافیکی فروش - نام خط فروش
   datetime m_lastEndTime;                 // زمان پایان آخرین رنج برای جلوگیری از تکرار - جلوگیری از تکرار رنج
   bool m_lastInvalid;                     // فلگ نامعتبر بودن آخرین رنج برای skip - پرش رنج نامعتبر
   datetime m_lastFilterBarTime;           // زمان آخرین کندل در تایم‌فریم فیلتر برای تشخیص کندل جدید و آپدیت نمایش - هماهنگی نمایش

public:
   // سازنده پیش‌فرض: مقداردهی اولیه تمام متغیرها به مقادیر پیش‌فرض برای جلوگیری از خطاهای دسترسی
   CRange() : m_rangeIndex(0), m_magicNumber(0), m_timeframe(PERIOD_H1), // مقداردهی اولیه متغیرهای اصلی
              m_startHour(0), m_startMinute(0), m_endHour(0), m_endMinute(0), // مقداردهی زمان‌ها
              m_minRangePoints(0), m_maxRangePoints(0), m_placementMode(PLACEMENT_ATR), // مقداردهی فیلتر ارتفاع و حالت افست
              m_atrPeriod(14), m_atrMultiplier(1.2), m_slStrategy(SL_OPPOSITE_SIDE), // مقداردهی ATR و استراتژی SL
              m_slCalcMode(SL_CALC_ATR), m_slAtrPeriod(14), m_slAtrMultiplier(1.5), // مقداردهی بافر SL
              m_trailingMode(TRAILING_ATR), m_trailingAtrPeriod(14), m_trailingAtrMultiplier(1.0), // مقداردهی تریلینگ
              m_rrRatio(1.5), m_partialClosePercent(50.0), m_cleanupHours(5), // مقداردهی RR و پاکسازی
              m_color(clrBlue), m_rangeHigh(0), m_rangeLow(0), m_cleanupTime(0), // مقداردهی رنگ و سطوح
              m_currentState(RANGE_WAITING), m_atrHandle(INVALID_HANDLE), // مقداردهی حالت و هندل‌ها
              m_slAtrHandle(INVALID_HANDLE), m_trailingAtrHandle(INVALID_HANDLE), // هندل‌های اضافی
              m_trailingActivated(false), m_activeTicket(0), m_cachedATR(0), // فلگ‌ها و کش‌ها
              m_cachedSlATR(0), m_cachedTrailingATR(0), // کش‌های اضافی
              m_trendFilterTimeframe(PERIOD_H4), // تایم‌فریم فیلتر
              m_potentialBuyPrice(0), m_potentialSellPrice(0), m_breakerCandleLevel(0), // سطوح ورود و بریک
              m_buyLineName(""), m_sellLineName(""), // نام خطوط
              m_lastEndTime(0), m_lastInvalid(false), m_lastFilterBarTime(0) {} // فلگ‌ها و زمان‌ها

   // تابع مقداردهی رنج: ذخیره پارامترها، ایجاد هندل‌های ATR و نام‌گذاری اشیاء گرافیکی
   bool Init(
      int rangeIndex, long magicNumber, ENUM_TIMEFRAMES timeframe, // پارامترهای شناسایی و تایم‌فریم
      int startHour, int startMinute, int endHour, int endMinute, // زمان‌های شروع و پایان
      int minRangePoints, int maxRangePoints, ENUM_PLACEMENT_MODE placementMode, // فیلتر ارتفاع و حالت افست
      int atrPeriod, double atrMultiplier, ENUM_SL_STRATEGY slStrategy, // ATR افست و استراتژی SL
      ENUM_SL_CALC_MODE slCalcMode, int slAtrPeriod, double slAtrMultiplier, // محاسبه بافر SL
      ENUM_TRAILING_MODE trailingMode, int trailingAtrPeriod, double trailingAtrMultiplier, // حالت تریلینگ
      double rrRatio, double partialClosePercent, int cleanupHours, color rangeColor, // RR، خروج پله‌ای و پاکسازی
      ENUM_TIMEFRAMES trendFilterTimeframe, int atrHandle) // تایم‌فریم فیلتر و هندل ATR
   {
      if(InpDebugMode) Print("مقداردهی رنج ", rangeIndex, " نسخه 1.92..."); // چاپ دیباگ برای شروع مقداردهی
      m_rangeIndex = rangeIndex; // ذخیره شماره رنج
      m_magicNumber = magicNumber; // ذخیره مجیک نامبر
      m_timeframe = timeframe; // ذخیره تایم‌فریم اجرا
      m_startHour = startHour; // ذخیره ساعت شروع
      m_startMinute = startMinute; // ذخیره دقیقه شروع
      m_endHour = endHour; // ذخیره ساعت پایان
      m_endMinute = endMinute; // ذخیره دقیقه پایان
      m_minRangePoints = minRangePoints; // ذخیره حداقل ارتفاع
      m_maxRangePoints = maxRangePoints; // ذخیره حداکثر ارتفاع
      m_placementMode = placementMode; // ذخیره حالت افست
      m_atrPeriod = atrPeriod; // ذخیره دوره ATR افست
      m_atrMultiplier = atrMultiplier; // ذخیره ضریب ATR افست
      m_slStrategy = slStrategy; // ذخیره استراتژی SL
      m_slCalcMode = slCalcMode; // ذخیره حالت بافر SL
      m_slAtrPeriod = slAtrPeriod; // ذخیره دوره ATR SL
      m_slAtrMultiplier = slAtrMultiplier; // ذخیره ضریب ATR SL
      m_trailingMode = trailingMode; // ذخیره حالت تریلینگ
      m_trailingAtrPeriod = trailingAtrPeriod; // ذخیره دوره ATR تریلینگ
      m_trailingAtrMultiplier = trailingAtrMultiplier; // ذخیره ضریب ATR تریلینگ
      m_rrRatio = rrRatio; // ذخیره نسبت RR
      m_partialClosePercent = partialClosePercent; // ذخیره درصد خروج پله‌ای
      m_cleanupHours = cleanupHours; // ذخیره ساعت‌های پاکسازی
      m_color = rangeColor; // ذخیره رنگ رنج
      m_trendFilterTimeframe = trendFilterTimeframe; // ذخیره تایم‌فریم فیلتر
      m_atrHandle = atrHandle; // ذخیره هندل ATR اصلی

      if(m_atrHandle == INVALID_HANDLE) // چک هندل معتبر
      {
         Print("خطا در هندل ATR برای رنج ", rangeIndex); // چاپ خطا
         return false; // بازگشت شکست
      }

      // ایجاد هندل ATR برای SL اگر حالت مربوطه فعال باشد
      if(m_slCalcMode == SL_CALC_ATR) // چک حالت ATR برای SL
      {
         m_slAtrHandle = iATR(_Symbol, m_timeframe, m_slAtrPeriod); // ایجاد هندل ATR SL
         if(m_slAtrHandle == INVALID_HANDLE) // چک هندل معتبر
         {
            Print("خطا در ایجاد هندل ATR برای SL رنج ", rangeIndex); // چاپ خطا
            return false; // بازگشت شکست
         }
      }

      // ایجاد هندل ATR برای تریلینگ اگر حالت مربوطه فعال باشد
      if(m_trailingMode == TRAILING_ATR) // چک حالت ATR برای تریلینگ
      {
         m_trailingAtrHandle = iATR(_Symbol, m_timeframe, m_trailingAtrPeriod); // ایجاد هندل ATR تریلینگ
         if(m_trailingAtrHandle == INVALID_HANDLE) // چک هندل معتبر
         {
            Print("خطا در ایجاد هندل ATR برای تریلینگ رنج ", rangeIndex); // چاپ خطا
            return false; // بازگشت شکست
         }
      }

      // نام‌گذاری منحصربه‌فرد اشیاء گرافیکی برای جلوگیری از تداخل
      m_rangeObjectName = "Range_" + IntegerToString(m_rangeIndex) + "_Rectangle"; // نام مستطیل رنج
      m_buyLineName = "Range_" + IntegerToString(m_rangeIndex) + "_BuyLine"; // نام خط خرید
      m_sellLineName = "Range_" + IntegerToString(m_rangeIndex) + "_SellLine"; // نام خط فروش

      ResetCaches(); // ریست کش‌های ATR برای شروع تازه
      m_currentState = RANGE_WAITING; // تنظیم حالت اولیه به انتظار
      if(InpDebugMode) Print("رنج ", rangeIndex, " مقداردهی شد."); // چاپ موفقیت
      return true; // بازگشت موفقیت
   }

   // تابع دفع رنج: آزادسازی هندل‌های ATR و پاکسازی منابع
   void Deinit()
   {
      if(m_slAtrHandle != INVALID_HANDLE) IndicatorRelease(m_slAtrHandle); // آزادسازی هندل SL اگر معتبر
      if(m_trailingAtrHandle != INVALID_HANDLE) IndicatorRelease(m_trailingAtrHandle); // آزادسازی هندل تریلینگ اگر معتبر
      if(InpDebugMode) Print("رنج ", m_rangeIndex, " دفع شد."); // چاپ دیباگ برای دفع
   }

   // به‌روزرسانی در هر کندل جدید: مدیریت ماشین حالت و چک انقضا
   void UpdateOnNewBar()
   {
      datetime currentTime = TimeCurrent(); // گرفتن زمان فعلی

      // چک انقضا رنج: اگر زمان زمان پاکسازی رسیده باشد، پاکسازی نرم انجام می‌شود
      if(m_currentState != RANGE_WAITING && m_cleanupTime > 0 && currentTime >= m_cleanupTime) // چک انقضا
      {
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " منقضی شد. پاکسازی نرم..."); // چاپ دیباگ برای انقضا
         SoftCleanup(); // فراخوانی پاکسازی نرم
      }

      // ماشین حالت: بر اساس حالت فعلی، عملیات مربوطه را اجرا می‌کند
      switch(m_currentState) // سوئیچ بر اساس حالت جاری
      {
         case RANGE_WAITING: // حالت انتظار
            IdentifyAndValidateRange(); // شناسایی رنج جدید
            break;

         case RANGE_IDENTIFIED: // حالت شناسایی شده
            ArmAndWait(); // مسلح کردن با افست و رسم خطوط
            break;

         case ARMED_AND_WAITING: // حالت مسلح و انتظار
            WaitForBreakerCandle(); // انتظار برای کندل شکننده
            break;

         case AWAITING_ENTRY_CONFIRMATION_BUY: // حالت انتظار ورود خرید
         case AWAITING_ENTRY_CONFIRMATION_SELL: // حالت انتظار ورود فروش
            ProcessEntryAttempt(); // چک تایید ورود و ابطال (منطق جدید)
            break;

         case MANAGING_TRADE: // حالت مدیریت معامله
            // مدیریت معامله به OnTimer منتقل شده، اما چک اضافی اینجا برای اطمینان
            break;

         case RANGE_EXPIRED: // حالت منقضی
            SoftCleanup(); // پاکسازی نرم و ریست به انتظار
            break;

         default: // حالت پیش‌فرض
            break;
      }
   }

   // گترها برای دسترسی به خصوصیات رنج از فایل اصلی
   long GetMagicNumber() { return m_magicNumber; } // بازگشت مجیک نامبر
   ENUM_TIMEFRAMES GetTimeframe() { return m_timeframe; } // بازگشت تایم‌فریم اجرا
   ENUM_TIMEFRAMES GetTrendFilterTimeframe() { return m_trendFilterTimeframe; } // بازگشت تایم‌فریم فیلتر
   ENUM_RANGE_STATE GetCurrentState() { return m_currentState; } // بازگشت حالت جاری
   datetime GetLastFilterBarTime() { return m_lastFilterBarTime; } // بازگشت زمان آخرین کندل فیلتر
   void UpdateLastFilterBarTime(datetime time) { m_lastFilterBarTime = time; } // آپدیت زمان کندل فیلتر برای هماهنگی نمایش

   // پاکسازی سخت: بستن معامله فعال و ریست کامل متغیرها برای شرایط اضطراری
   void HardCleanup()
   {
      if(InpDebugMode) Print("پاکسازی سخت رنج ", m_rangeIndex, "..."); // چاپ دیباگ برای پاکسازی سخت

      if(m_activeTicket != 0 && PositionSelectByTicket(m_activeTicket)) // چک تیکت فعال
      {
         if(CTradeManager::ClosePosition(m_activeTicket)) // بستن پوزیشن
         {
            if(InpDebugMode) Print("پوزیشن با تیکت ", m_activeTicket, " برای رنج ", m_rangeIndex, " بسته شد."); // چاپ موفقیت
         }
      }

      m_activeTicket = 0; // ریست تیکت
      m_trailingActivated = false; // ریست فلگ تریلینگ
      m_potentialBuyPrice = 0; // ریست قیمت خرید
      m_potentialSellPrice = 0; // ریست قیمت فروش
      m_breakerCandleLevel = 0; // ریست سطح بریک
      m_rangeHigh = 0; // ریست سقف رنج
      m_rangeLow = 0; // ریست کف رنج
      m_cleanupTime = 0; // ریست زمان پاکسازی
      ResetCaches(); // ریست کش‌ها برای جلوگیری از استفاده از داده‌های کهنه
      ObjectDelete(0, m_buyLineName); // حذف خط خرید
      ObjectDelete(0, m_sellLineName); // حذف خط فروش
      ObjectDelete(0, m_rangeObjectName); // حذف مستطیل رنج
      m_lastEndTime = 0; // ریست زمان پایان آخرین
      m_lastInvalid = false; // ریست فلگ نامعتبر
      m_lastFilterBarTime = 0; // ریست زمان فیلتر

      m_currentState = RANGE_WAITING; // تنظیم حالت به انتظار
      if(InpDebugMode) Print("رنج ", m_rangeIndex, " کاملاً پاکسازی شد (سخت)."); // چاپ موفقیت
   }

   // مدیریت معامله فعال: جستجو تیکت، خروج پله‌ای بهبودیافته، بریک‌اون و تریلینگ با حداقل تغییر
   void ManageActiveTrade()
   {
      if(InpDebugMode) Print("مدیریت معامله برای رنج ", m_rangeIndex, "..."); // چاپ دیباگ برای مدیریت

      // جستجو بهینه تیکت فعال با چک Magic برای جلوگیری از تداخل
      if(m_activeTicket == 0 || !PositionSelectByTicket(m_activeTicket) || PositionGetInteger(POSITION_MAGIC) != m_magicNumber) // چک تیکت معتبر
      {
         m_activeTicket = 0; // ریست تیکت
         for(int i = PositionsTotal() - 1; i >= 0; i--) // حلقه پوزیشن‌ها
         {
            ulong ticket = PositionGetTicket(i); // گرفتن تیکت
            if(PositionGetInteger(POSITION_MAGIC) == m_magicNumber) // چک مجیک
            {
               m_activeTicket = ticket; // ذخیره تیکت
               break; // خروج از حلقه
            }
         }
      }

      if(m_activeTicket == 0) // چک عدم یافتن تیکت
      {
         if(InpDebugMode) Print("هیچ معامله فعالی برای رنج ", m_rangeIndex, " یافت نشد."); // چاپ دیباگ
         m_currentState = RANGE_WAITING; // ریست حالت
         SoftCleanup(); // پاکسازی نرم
         return; // خروج
      }

      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE); // نوع پوزیشن
      double currentPrice = posType == POSITION_TYPE_BUY ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK); // قیمت فعلی
      double openPrice = PositionGetDouble(POSITION_PRICE_OPEN); // قیمت ورود
      double sl = PositionGetDouble(POSITION_SL); // SL فعلی
      double volume = PositionGetDouble(POSITION_VOLUME); // حجم پوزیشن
      double slDistance = MathAbs(openPrice - sl); // فاصله SL

      double currentProfit = MathAbs(currentPrice - openPrice); // سود فعلی

      // اگر تریلینگ فعال نشده، چک خروج پله‌ای با شرط اضافی برای حجم کوچک
      if(!m_trailingActivated) // چک فعال نبودن تریلینگ
      {
         double targetDistance = slDistance * m_rrRatio; // فاصله هدف برای خروج پله‌ای
         if(currentProfit >= targetDistance) // چک رسیدن به هدف
         {
            double partialVolume = volume * m_partialClosePercent / 100.0; // محاسبه حجم جزئی
            double closeVolume = MathRound(partialVolume / g_volumeStep) * g_volumeStep; // راند حجم

            // اگر closeVolume < g_volumeMin اما سود رسیده، کل را ببند برای جلوگیری از گیر کردن
            if(closeVolume < g_volumeMin) // چک حجم کمتر از حداقل
            {
               if(InpDebugMode) Print("حجم محاسبه شده برای خروج پله‌ای (", closeVolume, ") کمتر از حداقل مجاز (", g_volumeMin, ") است. رنج ", m_rangeIndex); // چاپ دیباگ
               closeVolume = volume; // بستن کامل اگر جزئی ممکن نیست
            }

            double remainingVolume = volume - closeVolume; // حجم باقی‌مانده

            // اگر حجم باقی‌مانده کمتر از حداقل است، کل پوزیشن را ببند
            if(remainingVolume < g_volumeMin && remainingVolume > 0) // چک باقی‌مانده کمتر از حداقل
            {
               closeVolume = volume; // بستن کامل
               if(InpDebugMode) Print("حجم باقی‌مانده کمتر از حداقل بود. کل پوزیشن بسته می‌شود. رنج ", m_rangeIndex); // چاپ دیباگ
            }

            // چک حداکثر حجم و بستن جزئی (با چک Magic اضافی برای امنیت)
            if(closeVolume >= g_volumeMin && closeVolume <= g_volumeMax) // چک حجم مجاز
            {
               if(PositionGetInteger(POSITION_MAGIC) != m_magicNumber) // چک مجیک
               {
                  Print("خطا: Magic Number پوزیشن مطابقت ندارد. رنج ", m_rangeIndex); // چاپ خطا
                  return; // خروج
               }
               if(CTradeManager::PartialClose(m_activeTicket, closeVolume)) // بستن جزئی
               {
                  if(InpDebugMode) Print("بخشی از معامله رنج ", m_rangeIndex, " بسته شد. حجم بسته شده=", closeVolume); // چاپ موفقیت
                  if(CTradeManager::MoveSLToBreakEven(m_activeTicket, openPrice)) // انتقال SL به ورود
                  {
                     if(InpDebugMode) Print("استاپ لاس رنج ", m_rangeIndex, " به نقطه ورود منتقل شد."); // چاپ موفقیت
                     m_trailingActivated = true; // فعال کردن تریلینگ
                  }
               }
            }
            else
            {
               Print("حجم بستن نامعتبر برای رنج ", m_rangeIndex, " (کمتر از min یا بیشتر از max)."); // چاپ خطا
            }
         }
      }

      // اگر تریلینگ فعال است، اعمال تریلینگ استاپ با چک حداقل تغییر برای جلوگیری از به‌روزرسانی‌های غیرضروری
      if(m_trailingActivated) // چک فعال بودن تریلینگ
      {
         int atrHandleToUse = (m_trailingMode == TRAILING_ATR) ? m_trailingAtrHandle : m_atrHandle; // انتخاب هندل ATR
         if(!CTradeManager::TrailingStop(m_activeTicket, m_trailingMode, m_trailingAtrPeriod, m_trailingAtrMultiplier, m_timeframe, atrHandleToUse)) // اعمال تریلینگ
         {
            Print("خطا در اعمال تریلینگ استاپ برای رنج ", m_rangeIndex); // چاپ خطا
         }
      }

      if(InpDebugMode) Print("معامله رنج ", m_rangeIndex, " در حالت MANAGING_TRADE."); // چاپ دیباگ برای حالت
   }

private:
   // ریست کش‌های ATR: برای جلوگیری از استفاده از داده‌های کهنه در رنج جدید یا پس از پاکسازی
   void ResetCaches()
   {
      m_cachedATR = 0; // ریست کش ATR اصلی
      m_cachedSlATR = 0; // ریست کش ATR SL
      m_cachedTrailingATR = 0; // ریست کش ATR تریلینگ
      if(InpDebugMode) Print("رنج ", m_rangeIndex, ": کش‌های ATR ریست شدند."); // چاپ دیباگ
   }

   // شناسایی و ولیدیشن رنج: محاسبه سقف/کف، چک ارتفاع و رسم مستطیل، با چک عدم وجود کندل
   void IdentifyAndValidateRange()
   {
      if(InpDebugMode) Print("شناسایی رنج ", m_rangeIndex, "..."); // چاپ دیباگ برای شناسایی

      datetime startTime, endTime; // متغیرهای زمان شروع و پایان
      if(!CTimeHelper::CalculateRangeTimes(m_startHour, m_startMinute, m_endHour, m_endMinute, startTime, endTime)) // محاسبه زمان‌ها
      {
         Print("خطا در محاسبه زمان رنج ", m_rangeIndex); // چاپ خطا
         m_currentState = RANGE_EXPIRED; // تنظیم به منقضی
         return; // خروج
      }

      if(endTime == m_lastEndTime && m_lastInvalid) // چک رنج قبلی نامعتبر
      {
         if(InpDebugMode) Print("رنج قبلی نامعتبر بود، skip تا رنج جدید."); // چاپ دیباگ
         return; // خروج
      }

      if(TimeCurrent() < endTime) // چک تمام نشدن رنج
      {
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " هنوز تمام نشده است."); // چاپ دیباگ
         return; // خروج
      }

      int startShift = iBarShift(_Symbol, m_timeframe, startTime); // شیفت شروع
      int endShift = iBarShift(_Symbol, m_timeframe, endTime); // شیفت پایان

      // چک برای عدم وجود کندل در بازه (Edge Case مدیریت تعطیلی بازار)
      if(startShift < 0 || endShift < 0) // چک شیفت معتبر
      {
         Print("خطا: کندلی در بازه زمانی مشخص شده برای رنج ", m_rangeIndex, " یافت نشد."); // چاپ خطا
         m_lastInvalid = true; // تنظیم فلگ نامعتبر
         m_lastEndTime = endTime; // ذخیره زمان
         m_currentState = RANGE_EXPIRED; // تنظیم به منقضی
         return; // خروج
      }

      int bars = startShift - endShift + 1; // تعداد بارها
      if(bars <= 0) // چک تعداد بارها
      {
         Print("خطا: تعداد بارها نامعتبر برای رنج ", m_rangeIndex); // چاپ خطا
         m_lastInvalid = true; // تنظیم فلگ
         m_lastEndTime = endTime; // ذخیره زمان
         m_currentState = RANGE_EXPIRED; // تنظیم به منقضی
         return; // خروج
      }

      int highestIdx = iHighest(_Symbol, m_timeframe, MODE_HIGH, bars, endShift); // ایندکس سقف
      int lowestIdx = iLowest(_Symbol, m_timeframe, MODE_LOW, bars, endShift); // ایندکس کف
      m_rangeHigh = iHigh(_Symbol, m_timeframe, highestIdx); // سقف رنج
      m_rangeLow = iLow(_Symbol, m_timeframe, lowestIdx); // کف رنج

      double rangeHeight = (m_rangeHigh - m_rangeLow) / _Point; // ارتفاع رنج به پوینت
      if(InpDebugMode) Print("رنج ", m_rangeIndex, ": سقف=", m_rangeHigh, ", کف=", m_rangeLow, ", ارتفاع=", rangeHeight, " پوینت"); // چاپ دیباگ سطوح

      if(rangeHeight < m_minRangePoints || rangeHeight > m_maxRangePoints) // چک ارتفاع مجاز
      {
         Print("رنج ", m_rangeIndex, " بی‌کیفیت است. ارتفاع خارج از محدوده مجاز."); // چاپ خطا
         m_lastInvalid = true; // تنظیم فلگ
         m_lastEndTime = endTime; // ذخیره زمان
         m_currentState = RANGE_EXPIRED; // تنظیم به منقضی
         return; // خروج
      }

      if(!ObjectCreate(0, m_rangeObjectName, OBJ_RECTANGLE, 0, startTime, m_rangeHigh, endTime, m_rangeLow)) // رسم مستطیل
      {
         Print("خطا در رسم مستطیل رنج ", m_rangeIndex, ": ", GetLastError()); // چاپ خطا
      }
      else
      {
         ObjectSetInteger(0, m_rangeObjectName, OBJPROP_COLOR, m_color); // تنظیم رنگ
         ObjectSetInteger(0, m_rangeObjectName, OBJPROP_STYLE, STYLE_SOLID); // تنظیم استایل
         ObjectSetInteger(0, m_rangeObjectName, OBJPROP_WIDTH, 1); // تنظیم عرض
         if(InpDebugMode) Print("مستطیل رنج ", m_rangeIndex, " رسم شد."); // چاپ موفقیت
      }

      m_lastInvalid = false; // ریست فلگ نامعتبر
      m_lastEndTime = endTime; // ذخیره زمان
      m_currentState = RANGE_IDENTIFIED; // تغییر حالت به شناسایی شده
      if(InpDebugMode) Print("رنج ", m_rangeIndex, " معتبر است. تغییر حالت به IDENTIFIED."); // چاپ دیباگ
   }

   // مسلح کردن رنج: محاسبه افست خرید/فروش و رسم خطوط گرافیکی، با محاسبه ثابت ATR بدون کش (برای ثابت ماندن خطوط)
   void ArmAndWait()
   {
      if(InpDebugMode) Print("مسلح کردن رنج ", m_rangeIndex, "..."); // چاپ دیباگ برای مسلح کردن

      double offset; // افست شکست
      if(m_placementMode == PLACEMENT_ATR) // چک حالت ATR
      {
         // محاسبه مستقیم ATR بدون کش برای ثابت ماندن افست (یک بار محاسبه و ثابت می‌ماند)
         double atr[]; // آرایه ATR
         ArraySetAsSeries(atr, true); // تنظیم سری آرایه
         if(CopyBuffer(m_atrHandle, 0, 1, 1, atr) <= 0) // کپی بافر
         {
            Print("خطا در گرفتن ATR برای مسلح کردن رنج ", m_rangeIndex, ": ", GetLastError()); // چاپ خطا
            return; // خروج
         }
         offset = atr[0] * m_atrMultiplier; // محاسبه افست ATR
      }
      else // حالت درصد
      {
         offset = (m_rangeHigh - m_rangeLow) * m_atrMultiplier / 100.0; // محاسبه افست درصد
      }

      m_potentialBuyPrice = NormalizeDouble(m_rangeHigh + offset, _Digits); // سطح خرید نرمالایز شده
      m_potentialSellPrice = NormalizeDouble(m_rangeLow - offset, _Digits); // سطح فروش نرمالایز شده

      datetime currentTime = TimeCurrent(); // زمان فعلی
      if(!ObjectCreate(0, m_buyLineName, OBJ_HLINE, 0, currentTime, m_potentialBuyPrice)) // رسم خط خرید
      {
         Print("خطا در رسم خط BUY برای رنج ", m_rangeIndex); // چاپ خطا
      }
      else
      {
         ObjectSetInteger(0, m_buyLineName, OBJPROP_COLOR, clrGreen); // تنظیم رنگ سبز
         ObjectSetInteger(0, m_buyLineName, OBJPROP_STYLE, STYLE_DASH); // تنظیم استایل داش
      }
      if(!ObjectCreate(0, m_sellLineName, OBJ_HLINE, 0, currentTime, m_potentialSellPrice)) // رسم خط فروش
      {
         Print("خطا در رسم خط SELL برای رنج ", m_rangeIndex); // چاپ خطا
      }
      else
      {
         ObjectSetInteger(0, m_sellLineName, OBJPROP_COLOR, clrRed); // تنظیم رنگ قرمز
         ObjectSetInteger(0, m_sellLineName, OBJPROP_STYLE, STYLE_DASH); // تنظیم استایل داش
      }

      m_cleanupTime = CTimeHelper::CalculateCleanupTime(m_endHour, m_endMinute, m_cleanupHours); // محاسبه زمان پاکسازی

      if(InpDebugMode) Print("رنج ", m_rangeIndex, " مسلح شد. Potential Buy: ", m_potentialBuyPrice, ", Sell: ", m_potentialSellPrice); // چاپ دیباگ سطوح
      m_currentState = ARMED_AND_WAITING; // تغییر حالت به مسلح و انتظار
   }

   // انتظار برای کندل بریک: چک کلوز بالای/پایین افست برای شروع تایید ورود (بدون تایمر، فقط تنظیم حالت جدید)
   void WaitForBreakerCandle()
   {
      double close1 = iClose(_Symbol, m_timeframe, 1); // کلوز کندل قبلی
      if(close1 == 0) // چک مقدار معتبر
      {
         Print("خطا: iClose مقدار نامعتبر برای رنج ", m_rangeIndex); // چاپ خطا
         return; // خروج
      }

      if(close1 > m_potentialBuyPrice) // چک شکست خرید
      {
         m_breakerCandleLevel = iHigh(_Symbol, m_timeframe, 1); // سطح های کندل شکست
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " - BUY Breaker Candle detected! Level: ", m_breakerCandleLevel); // چاپ دیباگ
         m_currentState = AWAITING_ENTRY_CONFIRMATION_BUY; // تغییر حالت به انتظار ورود خرید
      }
      else if(close1 < m_potentialSellPrice) // چک شکست فروش
      {
         m_breakerCandleLevel = iLow(_Symbol, m_timeframe, 1); // سطح لو کندل شکست
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " - SELL Breaker Candle detected! Level: ", m_breakerCandleLevel); // چاپ دیباگ
         m_currentState = AWAITING_ENTRY_CONFIRMATION_SELL; // تغییر حالت به انتظار ورود فروش
      }
   }

   // فرآیند تلاش ورود: چک ابطال بر اساس بازگشت قیمت، تایید قیمت و فیلتر روند، اجرای معامله اگر تایید شد (بدون محدودیت زمانی)
   void ProcessEntryAttempt()
   {
      bool isBuyAttempt = (m_currentState == AWAITING_ENTRY_CONFIRMATION_BUY); // تشخیص جهت تلاش (خرید یا فروش)
      double close1 = iClose(_Symbol, m_timeframe, 1); // کلوز کندل قبلی برای چک ابطال و تایید
      bool isInvalid = false; // فلگ برای شرط ابطال (برای تمیزتر شدن کد)

      // ۱. شرط ابطال و ریست (بر اساس انتخاب کاربر از Inp_Invalidation_Mode)
      if (Inp_Invalidation_Mode == INVALIDATION_RANGE_REENTRY) // حالت صبور: بازگشت به داخل رنج اصلی
      {
         if (isBuyAttempt && close1 < m_rangeHigh) isInvalid = true; // ابطال خرید اگر کلوز زیر سقف رنج
         if (!isBuyAttempt && close1 > m_rangeLow) isInvalid = true; // ابطال فروش اگر کلوز بالای کف رنج
      }
      else // حالت تهاجمی: INVALIDATION_BREAKOUT_LINE_CROSS - عبور از خط شکست (افست)
      {
         if (isBuyAttempt && close1 < m_potentialBuyPrice) isInvalid = true; // ابطال خرید اگر کلوز زیر خط خرید
         if (!isBuyAttempt && close1 > m_potentialSellPrice) isInvalid = true; // ابطال فروش اگر کلوز بالای خط فروش
      }

      // اگر شرط ابطال برقرار بود، ریست کن و از تابع خارج شو
      if (isInvalid) // چک فلگ ابطال
      {
         ResetToArmedState(); // ریست به حالت مسلح بدون حذف مسیرها
         return; // خروج از تابع
      }

      // ۲. چک کردن شرایط ورود
      // الف) تاییدیه قیمت (اختیاری: چک کلوز بالای/پایین سطح بریک)
      bool priceConfirmed = !Inp_PriceConfirmation_Enabled || // اگر تایید قیمت خاموش، همیشه درست
                            (isBuyAttempt ? (close1 > m_breakerCandleLevel) : (close1 < m_breakerCandleLevel)); // چک تایید بر اساس جهت

      if(!priceConfirmed) return; // اگر تایید قیمت لازم بود و نگرفتیم، منتظر کندل بعدی بمون

      // ب) تاییدیه فیلتر ایچیموکو (به صورت دینامیک و بدون محدودیت زمانی)
      ENUM_TREND_DIRECTION currentTrend = g_trendFilter.GetTrendDirection(m_trendFilterTimeframe); // گرفتن جهت روند فعلی
      bool filterConfirmed = !Inp_IchimokuFilter_Enabled || // اگر فیلتر خاموش، همیشه درست
                             (isBuyAttempt && (currentTrend == TREND_BUY || currentTrend == TREND_NEUTRAL)) || // چک برای خرید
                             (!isBuyAttempt && (currentTrend == TREND_SELL || currentTrend == TREND_NEUTRAL)); // چک برای فروش

      // ۳. اجرای معامله اگر فیلتر تایید شد
      if(filterConfirmed) // چک تایید فیلتر
      {
         ExecuteTrade(isBuyAttempt); // اجرای معامله با پارامتر جهت (برای تشخیص خرید/فروش)
      }
   }

   // ریست به حالت مسلح: ریست سطح بریک بدون حذف خطوط گرافیکی یا مسیرها (برای حفظ فرصت‌ها)
   void ResetToArmedState()
   {
      if(InpDebugMode) Print("رنج ", m_rangeIndex, ": شرط ابطال رخ داد. ریست به حالت مسلح."); // چاپ دیباگ برای ابطال
      m_breakerCandleLevel = 0; // پاک کردن سطح کندل شکننده
      m_currentState = ARMED_AND_WAITING; // ریست حالت به مسلح و انتظار
      // نکته کلیدی: هیچ خط گرافیکی یا مسیری اینجا حذف نمی‌شود تا فرصت دوباره شکل بگیرد
   }

   // اجرای معامله: محاسبه SL بر اساس SL strategy جدید (base point + بافر)، TP، حجم و ارسال سفارش بازار (با پارامتر isBuy برای تشخیص جهت)
   void ExecuteTrade(bool isBuy)
   {
      double entryPrice = isBuy ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID); // قیمت ورود فعلی (ASK برای خرید، BID برای فروش)

      double adjustment; // بافر SL
      if(m_slCalcMode == SL_CALC_ATR) // چک حالت ATR برای بافر SL
      {
         // محاسبه مستقیم SL ATR بدون کش برای ثابت ماندن
         double atr[]; // آرایه ATR
         ArraySetAsSeries(atr, true); // تنظیم سری
         if(CopyBuffer(m_slAtrHandle, 0, 1, 1, atr) <= 0) // کپی بافر
         {
            Print("خطا در گرفتن ATR برای SL رنج ", m_rangeIndex, ": ", GetLastError()); // چاپ خطا
            return; // خروج
         }
         adjustment = atr[0] * m_slAtrMultiplier; // محاسبه بافر ATR
      }
      else // حالت درصد
      {
         adjustment = (m_rangeHigh - m_rangeLow) * m_slAtrMultiplier / 100.0; // محاسبه بافر درصد
      }

      // انتخاب base point بر اساس SL strategy
      double basePoint; // پایه SL
      if(m_slStrategy == SL_OPPOSITE_SIDE) // حالت مقابل رنج
      {
         basePoint = isBuy ? m_rangeLow : m_rangeHigh; // مقابل رنج برای BUY/SELL
      }
      else // SL_BREAKOUT_LEVEL - سطح شکست
      {
         basePoint = isBuy ? m_rangeHigh : m_rangeLow; // سطح شکست برای BUY/SELL
      }

      // محاسبه SL بر اساس base point
      double slPrice; // قیمت SL
      if(isBuy) // برای خرید
      {
         slPrice = NormalizeDouble(basePoint - adjustment, _Digits); // برای BUY: base - adjustment
      }
      else // برای فروش
      {
         slPrice = NormalizeDouble(basePoint + adjustment, _Digits); // برای SELL: base + adjustment
      }

      double slDistance = MathAbs(entryPrice - slPrice); // فاصله SL از ورود

      // چک ولید slDistance با بافر اضافی برای minStop (جلوگیری از رد سفارش توسط بروکر)
      long stops_level = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL); // سطح حداقل فاصله
      double minStop = stops_level * _Point + _Point; // حداقل فاصله با بافر
      if(slDistance <= 0 || slDistance < minStop) // چک فاصله معتبر
      {
         Print("خطا: slDistance نامعتبر یا کمتر از حداقل فاصله مجاز برای رنج ", m_rangeIndex, " (slDistance=", slDistance, ")"); // چاپ خطا
         m_currentState = RANGE_EXPIRED; // تنظیم به منقضی
         return; // خروج
      }

      if(InpDebugMode) Print("رنج ", m_rangeIndex, ": SL Strategy=", EnumToString(m_slStrategy), ", slDistance=", slDistance, ", slPrice=", slPrice); // چاپ دیباگ SL

      double tpDistance = slDistance * m_rrRatio; // فاصله TP بر اساس RR
      double tpPrice = isBuy ? NormalizeDouble(entryPrice + tpDistance, _Digits) : NormalizeDouble(entryPrice - tpDistance, _Digits); // قیمت TP

      double lotSize = CRiskManager::CalculateLotSize(InpRiskPercent, slDistance); // محاسبه حجم بر اساس ریسک
      if(lotSize == 0) // چک حجم معتبر
      {
         Print("خطا در محاسبه حجم برای رنج ", m_rangeIndex); // چاپ خطا
         m_currentState = RANGE_EXPIRED; // تنظیم به منقضی
         return; // خروج
      }

      if(InpDebugMode) Print("رنج ", m_rangeIndex, ": lotSize=", lotSize); // چاپ دیباگ حجم

      CTrade trade; // نمونه کلاس معامله
      MqlTradeRequest request; // درخواست معامله
      MqlTradeResult result; // نتیجه معامله
      ZeroMemory(request); // صفر کردن درخواست
      request.action = TRADE_ACTION_DEAL; // عمل معامله بازار
      request.symbol = _Symbol; // نماد
      request.volume = lotSize; // حجم
      request.type = isBuy ? ORDER_TYPE_BUY : ORDER_TYPE_SELL; // نوع سفارش
      request.price = entryPrice; // استفاده از قیمت لحظه‌ای برای سفارش بازار
      request.sl = slPrice; // SL
      request.tp = tpPrice; // TP
      request.magic = m_magicNumber; // مجیک
      request.comment = (isBuy ? "Buy" : "Sell") + " Range " + IntegerToString(m_rangeIndex); // کامنت
      request.deviation = 10; // انحراف مجاز
      if(!trade.OrderSend(request, result) || result.deal == 0) // ارسال سفارش
      {
         Print("خطا در باز کردن معامله برای رنج ", m_rangeIndex, ": ", result.retcode); // چاپ خطا
         m_currentState = RANGE_EXPIRED; // تنظیم به منقضی
         return; // خروج
      }
      m_activeTicket = result.deal; // ذخیره تیکت

      if(InpDebugMode) Print("رنج ", m_rangeIndex, " - ", (isBuy ? "BUY" : "SELL"), " Trade Opened! Ticket: ", m_activeTicket); // چاپ موفقیت

      DisableOppositePath(isBuy); // غیرفعال کردن مسیر مخالف برای OCO
      m_currentState = MANAGING_TRADE; // تغییر حالت به مدیریت
   }

   // غیرفعال کردن مسیر مخالف: حذف خط گرافیکی و ریست قیمت بالقوه برای جلوگیری از سیگنال دوگانه
   void DisableOppositePath(bool isBuy)
   {
      if(isBuy) // برای خرید
      {
         m_potentialSellPrice = 0; // ریست قیمت فروش
         ObjectDelete(0, m_sellLineName); // حذف خط فروش
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " - SELL path deactivated (OCO)."); // چاپ دیباگ
      }
      else // برای فروش
      {
         m_potentialBuyPrice = 0; // ریست قیمت خرید
         ObjectDelete(0, m_buyLineName); // حذف خط خرید
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " - BUY path deactivated (OCO)."); // چاپ دیباگ
      }
   }

   // پاکسازی نرم: ریست متغیرها و حذف اشیاء بدون بستن معامله برای آماده‌سازی رنج بعدی
   void SoftCleanup()
   {
      if(InpDebugMode) Print("پاکسازی نرم رنج ", m_rangeIndex, "..."); // چاپ دیباگ برای پاکسازی نرم

      m_potentialBuyPrice = 0; // ریست قیمت خرید
      m_potentialSellPrice = 0; // ریست قیمت فروش
      m_breakerCandleLevel = 0; // ریست سطح بریک
      m_lastFilterBarTime = 0; // ریست زمان فیلتر
      ObjectDelete(0, m_buyLineName); // حذف خط خرید
      ObjectDelete(0, m_sellLineName); // حذف خط فروش
      ObjectDelete(0, m_rangeObjectName); // حذف مستطیل رنج
      m_lastEndTime = 0; // ریست زمان پایان
      m_lastInvalid = false; // ریست فلگ نامعتبر

      ResetCaches(); // ریست کش‌ها برای جلوگیری از استفاده از داده‌های کهنه

      m_currentState = RANGE_WAITING; // تنظیم حالت به انتظار
      m_cleanupTime = 0; // ریست زمان پاکسازی
      if(InpDebugMode) Print("رنج ", m_rangeIndex, " برای روز بعد ریست شد (نرم)."); // چاپ موفقیت
   }

   // گرفتن ATR کش‌شده اصلی: اگر کش خالی باشد، از هندل کپی می‌گیرد (فقط برای ورود استفاده شود)
   double GetCachedATR()
   {
      if(m_cachedATR <= 0) // چک کش خالی
      {
         double atr[]; // آرایه ATR
         ArraySetAsSeries(atr, true); // تنظیم سری
         if(CopyBuffer(m_atrHandle, 0, 1, 1, atr) <= 0) // کپی بافر
         {
            Print("خطا در گرفتن ATR برای رنج ", m_rangeIndex, ": ", GetLastError()); // چاپ خطا
            return 0; // بازگشت صفر
         }
         m_cachedATR = atr[0]; // ذخیره در کش
      }
      return m_cachedATR; // بازگشت کش
   }

   // گرفتن ATR کش‌شده برای SL: مشابه برای بهینه‌سازی محاسبات SL (فقط برای ورود استفاده شود)
   double GetSlATR()
   {
      if(m_cachedSlATR <= 0) // چک کش خالی
      {
         double atr[]; // آرایه ATR
         ArraySetAsSeries(atr, true); // تنظیم سری
         if(CopyBuffer(m_slAtrHandle, 0, 1, 1, atr) <= 0) // کپی بافر
         {
            Print("خطا در گرفتن ATR برای SL رنج ", m_rangeIndex, ": ", GetLastError()); // چاپ خطا
            return 0; // بازگشت صفر
         }
         m_cachedSlATR = atr[0]; // ذخیره در کش
      }
      return m_cachedSlATR; // بازگشت کش
   }

   // گرفتن ATR کش‌شده برای تریلینگ: مشابه برای بهینه‌سازی تریلینگ (فقط برای ورود استفاده شود، برای مدیریت پویا استفاده نشود)
   double GetTrailingATR()
   {
      if(m_cachedTrailingATR <= 0) // چک کش خالی
      {
         double atr[]; // آرایه ATR
         ArraySetAsSeries(atr, true); // تنظیم سری
         if(CopyBuffer(m_trailingAtrHandle, 0, 1, 1, atr) <= 0) // کپی بافر
         {
            Print("خطا در گرفتن ATR برای تریلینگ رنج ", m_rangeIndex, ": ", GetLastError()); // چاپ خطا
            return 0; // بازگشت صفر
         }
         m_cachedTrailingATR = atr[0]; // ذخیره در کش
      }
      return m_cachedTrailingATR; // بازگشت کش
   }
};

#endif
```
```mql5
//+------------------------------------------------------------------+
//|                                                     TradeManager.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CTradeManager را تعریف می‌کند که عملیات معاملاتی پیشرفته را مدیریت می‌کند.
// استراتژی کلی اکسپرت: این کلاس بخشی از مدیریت معامله در استراتژی شکست رنج است، جایی که پس از باز شدن معامله، خروج پله‌ای (هنگام رسیدن به RR)، انتقال SL به ورود (برای حفظ سرمایه)، تریلینگ (برای قفل سود) و بستن کامل (در پاکسازی سخت) انجام می‌شود. این عملیات ریسک را کنترل و سود را به حداکثر می‌رساند.
// منطق فایل TradeManager.mqh: کلاس شامل متدهای استاتیک برای بستن جزئی (PartialClose با چک حجم مجاز)، انتقال SL به بریک‌اون (MoveSLToBreakEven با نرمالایز قیمت)، تریلینگ استاپ (TrailingStop با محاسبه فاصله ATR یا ساده و چک حداقل تغییر برای جلوگیری از به‌روزرسانی‌های بیهوده)، و بستن کامل (ClosePosition). تمام متدها PositionSelectByTicket را چک می‌کنند و از CTrade برای ارسال درخواست استفاده می‌کنند. این فایل توسط CRange برای مدیریت معاملات در ManageActiveTrade فراخوانی می‌شود و هیچ وابستگی خارجی ندارد جز Trade.mqh. تغییرات: هیچ تغییری لازم نبود، اما کامنت‌ها به‌روزرسانی شد.

#ifndef TRADE_MANAGER_MQH
#define TRADE_MANAGER_MQH

#include <Trade\Trade.mqh> // کلاس معامله برای عملیات

// کلاس CTradeManager برای عملیات معاملاتی استاتیک (بدون نیاز به نمونه‌سازی)
class CTradeManager
{
public:
   // بستن جزئی پوزیشن: محاسبه و بستن حجم مشخص با چک اضافی Magic برای امنیت
   static bool PartialClose(ulong ticket, double volume) // بستن جزئی با تیکت و حجم
   {
      if(!PositionSelectByTicket(ticket)) // چک انتخاب پوزیشن
      {
         Print("خطا: پوزیشن با تیکت ", ticket, " یافت نشد."); // چاپ خطا
         return false; // بازگشت شکست
      }

      CTrade trade; // نمونه کلاس معامله
      if(trade.PositionClose(ticket, volume)) // بستن جزئی
      {
         if(InpDebugMode) Print("بخشی از پوزیشن با تیکت ", ticket, " بسته شد."); // چاپ موفقیت
         return true; // بازگشت موفقیت
      }
      else
      {
         Print("خطا در بستن بخشی از پوزیشن با تیکت ", ticket, ": ", trade.ResultRetcode()); // چاپ خطا
         return false; // بازگشت شکست
      }
   }

   // انتقال SL به بریک‌اون: نرمالایز قیمت و تغییر SL به نقطه ورود
   static bool MoveSLToBreakEven(ulong ticket, double breakEvenPrice) // انتقال SL به ورود
   {
      if(!PositionSelectByTicket(ticket)) // چک انتخاب پوزیشن
      {
         Print("خطا: پوزیشن با تیکت ", ticket, " یافت نشد."); // چاپ خطا
         return false; // بازگشت شکست
      }

      CTrade trade; // نمونه کلاس معامله
      breakEvenPrice = NormalizeDouble(breakEvenPrice, _Digits); // نرمالایز قیمت
      if(trade.PositionModify(ticket, breakEvenPrice, PositionGetDouble(POSITION_TP))) // تغییر SL
      {
         if(InpDebugMode) Print("استاپ لاس پوزیشن ", ticket, " به نقطه ورود منتقل شد."); // چاپ موفقیت
         return true; // بازگشت موفقیت
      }
      else
      {
         Print("خطا در انتقال استاپ لاس پوزیشن ", ticket, ": ", trade.ResultRetcode()); // چاپ خطا
         return false; // بازگشت شکست
      }
   }

   // اعمال تریلینگ استاپ: محاسبه فاصله جدید، چک حداقل تغییر و تغییر SL (محاسبه پویا ATR هر بار)
   static bool TrailingStop(ulong ticket, ENUM_TRAILING_MODE mode, int atrPeriod, double atrMultiplier, ENUM_TIMEFRAMES timeframe, int atrHandle) // تریلینگ با پارامترها
   {
      if(!PositionSelectByTicket(ticket)) // چک انتخاب پوزیشن
      {
         Print("خطا: پوزیشن با تیکت ", ticket, " یافت نشد."); // چاپ خطا
         return false; // بازگشت شکست
      }

      double sl = PositionGetDouble(POSITION_SL); // SL فعلی
      if(sl == 0) // چک SL صفر
      {
         if(InpDebugMode) Print("هشدار: SL اولیه صفر است برای پوزیشن ", ticket, ". تریلینگ skip شد."); // چاپ هشدار
         return false; // بازگشت شکست
      }

      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE); // نوع پوزیشن
      double currentPrice = posType == POSITION_TYPE_BUY ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK); // قیمت فعلی

      double trailingDistance; // فاصله تریلینگ
      if(mode == TRAILING_ATR) // چک حالت ATR
      {
         double atr[]; // آرایه ATR
         ArraySetAsSeries(atr, true); // تنظیم سری
         if(CopyBuffer(atrHandle, 0, 1, 1, atr) <= 0) // کپی بافر
         {
            Print("خطا در گرفتن ATR برای تریلینگ: ", GetLastError()); // چاپ خطا
            return false; // بازگشت شکست
         }
         trailingDistance = atr[0] * atrMultiplier; // محاسبه پویا هر بار بدون کش
      }
      else // حالت ساده
      {
         trailingDistance = atrMultiplier * _Point; // فاصله ثابت
      }

      double newSL; // SL جدید
      if(posType == POSITION_TYPE_BUY) // برای خرید
      {
         newSL = NormalizeDouble(currentPrice - trailingDistance, _Digits); // محاسبه SL جدید
         if(newSL > sl) // چک بهبود SL
         {
            // چک حداقل تغییر برای جلوگیری از به‌روزرسانی‌های بیهوده و هزینه‌های اضافی
            if(MathAbs(newSL - sl) < _Point * 5) return true; // بدون تغییر اگر کم
            CTrade trade; // نمونه معامله
            if(trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP))) // تغییر SL
            {
               if(InpDebugMode) Print("تریلینگ استاپ برای پوزیشن ", ticket, " به‌روزرسانی شد. SL جدید=", newSL); // چاپ موفقیت
               return true; // بازگشت موفقیت
            }
            else
            {
               Print("خطا در به‌روزرسانی تریلینگ استاپ: ", trade.ResultRetcode()); // چاپ خطا
               return false; // بازگشت شکست
            }
         }
      }
      else // برای فروش
      {
         newSL = NormalizeDouble(currentPrice + trailingDistance, _Digits); // محاسبه SL جدید
         if(newSL < sl) // چک بهبود SL
         {
            // چک حداقل تغییر مشابه
            if(MathAbs(newSL - sl) < _Point * 5) return true; // بدون تغییر اگر کم
            CTrade trade; // نمونه معامله
            if(trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP))) // تغییر SL
            {
               if(InpDebugMode) Print("تریلینگ استاپ برای پوزیشن ", ticket, " به‌روزرسانی شد. SL جدید=", newSL); // چاپ موفقیت
               return true; // بازگشت موفقیت
            }
            else
            {
               Print("خطا در به‌روزرسانی تریلینگ استاپ: ", trade.ResultRetcode()); // چاپ خطا
               return false; // بازگشت شکست
            }
         }
      }
      return true; // بازگشت موفقیت پیش‌فرض
   }

   // بستن کامل پوزیشن: انتخاب و بستن با چک نتیجه
   static bool ClosePosition(ulong ticket) // بستن کامل با تیکت
   {
      if(!PositionSelectByTicket(ticket)) // چک انتخاب پوزیشن
      {
         Print("خطا: پوزیشن با تیکت ", ticket, " یافت نشد."); // چاپ خطا
         return false; // بازگشت شکست
      }

      CTrade trade; // نمونه معامله
      if(trade.PositionClose(ticket)) // بستن کامل
      {
         if(InpDebugMode) Print("پوزیشن با تیکت ", ticket, " بسته شد."); // چاپ موفقیت
         return true; // بازگشت موفقیت
      }
      else
      {
         Print("خطا در بستن پوزیشن با تیکت ", ticket, ": ", trade.ResultRetcode()); // چاپ خطا
         return false; // بازگشت شکست
      }
   }
};

#endif
```
```mql5
//+------------------------------------------------------------------+
//|                                                     RiskManager.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CRiskManager را تعریف می‌کند که محاسبه ریسک و حجم را مدیریت می‌کند.
// استراتژی کلی اکسپرت: ریسک هر معامله بر اساس درصد موجودی حساب و فاصله SL محاسبه می‌شود تا زیان محدود شود. این کلاس حجم را طوری تعیین می‌کند که زیان SL برابر درصد ریسک باشد، مستقل از نوع نماد (فارکس، شاخص، JPY).
// منطق فایل RiskManager.mqh: متد استاتیک CalculateLotSize فاصله SL (قیمت واقعی) را می‌گیرد، ریسک به ازای هر لات را با فرمول slDistance * (g_tickValue / g_tickSize) محاسبه می‌کند (برای سازگاری با نمادهای مختلف)، حجم را بر اساس ریسک مطلوب تعیین می‌کند و به گام حجم راند می‌کند. چک‌های ولید برای جلوگیری از حجم نامعتبر اضافه شده. این فایل توسط CRange برای محاسبه حجم در ExecuteTrade فراخوانی می‌شود. تغییرات: هیچ تغییری لازم نبود، اما کامنت‌ها به‌روزرسانی شد.

#ifndef RISK_MANAGER_MQH
#define RISK_MANAGER_MQH

extern double g_tickValue; // ارزش تیک خارجی
extern double g_tickSize; // اندازه تیک خارجی
extern double g_volumeStep; // گام حجم خارجی
extern double g_volumeMin; // حداقل حجم خارجی
extern double g_volumeMax; // حداکثر حجم خارجی

// کلاس CRiskManager برای محاسبه حجم معاملاتی بر اساس ریسک
class CRiskManager
{
public:
   // محاسبه حجم: بر اساس درصد ریسک و فاصله SL، با فرمول سازگار برای تمام نمادها
   static double CalculateLotSize(double riskPercent, double slDistance) // محاسبه لات با ریسک و فاصله SL
   {
      if(g_tickValue == 0 || g_tickSize == 0) // چک مقادیر کش معتبر
      {
         Print("خطا: tickValue یا tickSize صفر است. محاسبه حجم ممکن نیست."); // چاپ خطا
         return 0; // بازگشت صفر
      }

      // اگر g_tickSize صفر باشد (نادر)، default به _Point برای سازگاری
      if(g_tickSize == 0) g_tickSize = _Point; // تنظیم پیش‌فرض اندازه تیک

      double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE); // موجودی حساب
      double riskPerLot = slDistance * (g_tickValue / g_tickSize); // ریسک به ازای هر لات

      if (riskPerLot <= 0) // چک ریسک معتبر
      {
          Print("خطا: ریسک به ازای هر لات نامعتبر است. slDistance=", slDistance); // چاپ خطا
          return 0; // بازگشت صفر
      }

      double riskAmount = riskPercent / 100.0 * accountBalance; // مقدار ریسک مطلق
      double lotSize = riskAmount / riskPerLot; // حجم اولیه

      lotSize = MathRound(lotSize / g_volumeStep) * g_volumeStep; // راند به گام حجم
      lotSize = MathMax(g_volumeMin, MathMin(g_volumeMax, lotSize)); // محدود به min/max

      if(lotSize < g_volumeMin) // چک کمتر از حداقل
      {
         Print("خطا: حجم محاسبه شده (", lotSize, ") کمتر از حداقل (", g_volumeMin, ") است."); // چاپ خطا
         return 0; // بازگشت صفر
      }

      if(InpDebugMode) Print("حجم محاسبه شده: ", lotSize, ", slDistance=", slDistance, ", riskPerLot=", riskPerLot); // چاپ دیباگ
      return lotSize; // بازگشت حجم
   }
};

#endif
```
```mql5
//+------------------------------------------------------------------+
//|                                                      TimeHelper.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CTimeHelper را تعریف می‌کند که محاسبات زمانی را مدیریت می‌کند.
// استراتژی کلی اکسپرت: زمان‌های رنج و پاکسازی بر اساس ساعات محلی سرور محاسبه می‌شود تا رنج‌ها دقیقاً در بازه‌های تعریف‌شده عمل کنند و پس از انقضا پاک شوند.
// منطق فایل TimeHelper.mqh: متدهای استاتیک CalculateRangeTimes زمان شروع/پایان رنج را محاسبه می‌کند (با مدیریت رنج‌های شبانه و تنظیم بر اساس روز فعلی)، و CalculateCleanupTime زمان انقضا را بر اساس ساعت‌های پاکسازی اضافه می‌کند. این فایل توسط CRange برای تعیین زمان‌ها استفاده می‌شود و وابستگی به TimeCurrent دارد. تغییرات: هیچ تغییری لازم نبود، اما کامنت‌ها به‌روزرسانی شد.

#ifndef TIME_HELPER_MQH
#define TIME_HELPER_MQH

// کلاس CTimeHelper برای محاسبات زمانی رنج و پاکسازی
class CTimeHelper
{
public:
   // محاسبه زمان شروع و پایان رنج: تنظیم بر اساس روز فعلی و مدیریت رنج‌های عبور از نیمه‌شب
   static bool CalculateRangeTimes(int startHour, int startMinute, int endHour, int endMinute, datetime &startTime, datetime &endTime) // محاسبه زمان رنج
   {
      MqlDateTime dt; // ساختار زمان
      TimeToStruct(TimeCurrent(), dt); // تبدیل زمان فعلی به ساختار

      datetime today = TimeCurrent() - (dt.hour * 3600 + dt.min * 60 + dt.sec); // روز فعلی بدون زمان
      datetime start = today + startHour * 3600 + startMinute * 60; // زمان شروع
      datetime end = today + endHour * 3600 + endMinute * 60; // زمان پایان

      if(endHour < startHour || (endHour == startHour && endMinute <= startMinute)) // چک رنج شبانه
      {
         end += 86400; // اضافه روز برای عبور از نیمه‌شب
      }

      if(TimeCurrent() < start) // چک زمان فعلی قبل از شروع
      {
         start -= 86400; // تنظیم به روز قبل
         end -= 86400; // تنظیم به روز قبل
      }

      startTime = start; // ذخیره شروع
      endTime = end; // ذخیره پایان
      if(InpDebugMode) Print("محاسبه زمان رنج: Start=", TimeToString(startTime), ", End=", TimeToString(endTime)); // چاپ دیباگ
      return true; // بازگشت موفقیت
   }

   // محاسبه زمان پاکسازی: اضافه کردن ساعت‌های پاکسازی به زمان پایان برای انقضا
   static datetime CalculateCleanupTime(int endHour, int endMinute, int cleanupHours) // محاسبه زمان انقضا
   {
      MqlDateTime dt; // ساختار زمان
      TimeToStruct(TimeCurrent(), dt); // تبدیل زمان فعلی

      datetime today = TimeCurrent() - (dt.hour * 3600 + dt.min * 60 + dt.sec); // روز فعلی
      datetime end = today + endHour * 3600 + endMinute * 60; // زمان پایان
      if(endHour < dt.hour || (endHour == dt.hour && endMinute <= dt.min)) // چک پایان در روز بعد
      {
         end += 86400; // اضافه روز
      }

      datetime cleanupTime = end + cleanupHours * 3600; // اضافه ساعت‌های پاکسازی
      if(InpDebugMode) Print("زمان پاکسازی: ", TimeToString(cleanupTime)); // چاپ دیباگ
      return cleanupTime; // بازگشت زمان
   }
};

#endif
```
```mql5
//+------------------------------------------------------------------+
//|                                                     TrendFilter.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CTrendFilter را تعریف می‌کند که فیلتر روند بر اساس ایچیموکو را مدیریت می‌کند.
// استراتژی کلی اکسپرت: فیلتر روند برای جلوگیری از معاملات خلاف جهت استفاده می‌شود؛ اگر ابر ایچیموکو فلت (خنثی) یا هم‌جهت باشد، معامله مجاز است، иначе رد می‌شود.
// منطق فایل TrendFilter.mqh: enum ENUM_TREND_DIRECTION برای خروجی (BUY/SELL/NEUTRAL). تابع GetTrendDirection سنکو A/B را به طور دستی محاسبه می‌کند (با استفاده از iHigh/iLow برای دوره‌های تنکان، کیجون و سنکو B)، تفاوت را چک می‌کند (اگر کمتر از آستانه، خنثی)، و جهت را تعیین می‌کند (A > B برای BUY). این محاسبه دستی برای جلوگیری از مشکلات دسترسی به کندل‌های آینده در MT5 انجام می‌شود. Init/Deinit خالی هستند زیرا هیچ هندلی ثابت نیست. این فایل توسط CRange برای تأیید فیلتر مستقل فراخوانی می‌شود. تغییرات: محاسبه دستی سنکو A/B برای آپدیت دقیق با هر کندل جدید در تایم‌فریم فیلتر.

#ifndef TREND_FILTER_MQH
#define TREND_FILTER_MQH

// تعریف enum برای جهت روند (برای تصمیم‌گیری در فیلتر)
enum ENUM_TREND_DIRECTION
{
   TREND_BUY,     // روند صعودی (سنکو A بالای B) - جهت خرید مجاز
   TREND_SELL,    // روند نزولی (سنکو A پایین B) - جهت فروش مجاز
   TREND_NEUTRAL  // روند خنثی (ابر فلت یا فیلتر خاموش) - هر جهتی مجاز
};

// کلاس CTrendFilter برای فیلتر روند پویا بر اساس ایچیموکو
class CTrendFilter
{
public:
   CTrendFilter() {} // سازنده پیش‌فرض - هیچ مقداری اولیه ندارد

   // Init خالی (هیچ هندلی ثابت ساخته نمی‌شود، محاسبه دستی در GetTrendDirection)
   bool Init() { return true; } // مقداردهی - همیشه موفقیت

   // Deinit خالی (هیچ منبعی ثابت برای آزادسازی نیست)
   void Deinit() {} // دفع - هیچ عملی

   // گرفتن جهت روند: محاسبه دستی سنکو A/B بر اساس داده‌های گذشته (برای ابر آینده بدون نیاز به کندل آینده)
   ENUM_TREND_DIRECTION GetTrendDirection(ENUM_TIMEFRAMES timeframe) // گرفتن جهت با تایم‌فریم
   {
      if(!Inp_IchimokuFilter_Enabled) // چک فیلتر خاموش
      {
         return TREND_NEUTRAL; // اگر فیلتر خاموش باشد، همیشه خنثی فرض می‌شود
      }

      // محاسبه تنکان-سن (برای کندل بسته آخر، shift 1)
      int tenkanHighIdx = iHighest(_Symbol, timeframe, MODE_HIGH, Inp_Ichimoku_Tenkan, 1); // ایندکس سقف تنکان
      int tenkanLowIdx = iLowest(_Symbol, timeframe, MODE_LOW, Inp_Ichimoku_Tenkan, 1); // ایندکس کف تنکان
      double tenkanHigh = iHigh(_Symbol, timeframe, tenkanHighIdx); // های تنکان
      double tenkanLow = iLow(_Symbol, timeframe, tenkanLowIdx); // لو تنکان
      double tenkan = (tenkanHigh + tenkanLow) / 2.0; // تنکان-سن

      // محاسبه کیجون-سن
      int kijunHighIdx = iHighest(_Symbol, timeframe, MODE_HIGH, Inp_Ichimoku_Kijun, 1); // ایندکس سقف کیجون
      int kijunLowIdx = iLowest(_Symbol, timeframe, MODE_LOW, Inp_Ichimoku_Kijun, 1); // ایندکس کف کیجون
      double kijunHigh = iHigh(_Symbol, timeframe, kijunHighIdx); // های کیجون
      double kijunLow = iLow(_Symbol, timeframe, kijunLowIdx); // لو کیجون
      double kijun = (kijunHigh + kijunLow) / 2.0; // کیجون-سن

      // محاسبه سنکو اسپن A (برای ابر آینده)
      double senkouA = (tenkan + kijun) / 2.0; // سنکو A

      // محاسبه سنکو اسپن B (برای ابر آینده)
      int senkouBHighIdx = iHighest(_Symbol, timeframe, MODE_HIGH, Inp_Ichimoku_SenkouB, 1); // ایندکس سقف سنکو B
      int senkouBLowIdx = iLowest(_Symbol, timeframe, MODE_LOW, Inp_Ichimoku_SenkouB, 1); // ایندکس کف سنکو B
      double senkouBHigh = iHigh(_Symbol, timeframe, senkouBHighIdx); // های سنکو B
      double senkouBLow = iLow(_Symbol, timeframe, senkouBLowIdx); // لو سنکو B
      double senkouB = (senkouBHigh + senkouBLow) / 2.0; // سنکو B

      double diff = MathAbs(senkouA - senkouB) / _Point; // تفاوت به پوینت
      if(diff < Inp_Ichimoku_FlatThreshold_Points) // چک فلت بودن
      {
         if(InpDebugMode) Print("ابر ایچیموکو فلت است. جهت: NEUTRAL"); // چاپ دیباگ
         return TREND_NEUTRAL; // بازگشت خنثی
      }

      if(senkouA > senkouB) // چک صعودی
      {
         if(InpDebugMode) Print("جهت روند: BUY"); // چاپ دیباگ
         return TREND_BUY; // بازگشت خرید
      }
      else // چک نزولی
      {
         if(InpDebugMode) Print("جهت روند: SELL"); // چاپ دیباگ
         return TREND_SELL; // بازگشت فروش
      }
   }
};

#endif
```
```mql5
//+------------------------------------------------------------------+
//|                                                   VisualManager.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CVisualManager را تعریف می‌کند که نمایش بصری روی چارت را مدیریت می‌کند.
// استراتژی کلی اکسپرت: نمایش وضعیت روند (Bullish/Bearish/Neutral) برای هر رنج فعال به طور جداگانه برای کمک به کاربر در نظارت، بدون تأثیر بر منطق معاملاتی.
// منطق فایل VisualManager.mqh: کلاس شیء LABEL را برای نمایش متن کامل وضعیت هر رنج ایجاد می‌کند، موقعیت، فونت را تنظیم می‌کند. تابع UpdateTrendStatus متن چندخطی را به‌روزرسانی و چارت را redraw می‌کند. Init شیء را می‌سازد و Deinit حذف می‌کند. این فایل توسط Elemento.mq5 برای نمایش در OnTick فراخوانی می‌شود و اختیاری است (اگر Inp_Visual_ShowTrendStatus خاموش باشد، نادیده گرفته می‌شود). تغییرات جدید: پشتیبانی از متن چندخطی برای نمایش هر رنج جداگانه.

#ifndef VISUAL_MANAGER_MQH
#define VISUAL_MANAGER_MQH

// کلاس CVisualManager برای مدیریت نمایش متن روند هر رنج روی چارت
class CVisualManager
{
private:
   string m_trendStatusObjectName; // نام منحصربه‌فرد شیء LABEL برای نمایش - ثابت "TrendStatus"

public:
   CVisualManager() : m_trendStatusObjectName("TrendStatus") {} // سازنده - تنظیم نام شیء

   // مقداردهی: ایجاد شیء LABEL با تنظیمات فونت، رنگ و موقعیت اگر نمایش فعال باشد
   bool Init() // مقداردهی مدیر نمایش
   {
      if(InpDebugMode) Print("مقداردهی مدیر نمایش..."); // چاپ دیباگ برای شروع
      if(Inp_Visual_ShowTrendStatus) // چک فعال بودن نمایش
      {
         if(!ObjectCreate(0, m_trendStatusObjectName, OBJ_LABEL, 0, 0, 0)) // ایجاد LABEL
         {
            Print("خطا در ایجاد شیء نمایش روند: ", GetLastError()); // چاپ خطا
            return false; // بازگشت شکست
         }

         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_XDISTANCE, Inp_Visual_X_Offset); // تنظیم فاصله افقی
         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_YDISTANCE, Inp_Visual_Y_Offset); // تنظیم فاصله عمودی
         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_CORNER, CORNER_LEFT_UPPER); // تنظیم گوشه چپ بالا
         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_FONTSIZE, Inp_Visual_FontSize); // تنظیم اندازه فونت
         ObjectSetString(0, m_trendStatusObjectName, OBJPROP_FONT, "Arial"); // تنظیم فونت
         ObjectSetString(0, m_trendStatusObjectName, OBJPROP_TEXT, "Initializing..."); // متن اولیه
         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_COLOR, Inp_Visual_FontColor_Neutral); // رنگ خنثی
      }
      if(InpDebugMode) Print("مدیر نمایش با موفقیت مقداردهی شد."); // چاپ موفقیت
      return true; // بازگشت موفقیت
   }

   // دفع: حذف شیء LABEL برای پاکسازی چارت
   void Deinit() // دفع مدیر نمایش
   {
      ObjectDelete(0, m_trendStatusObjectName); // حذف شیء
      if(InpDebugMode) Print("شیء نمایش روند حذف شد."); // چاپ دیباگ
   }

   // به‌روزرسانی نمایش: تغییر متن کامل وضعیت روند هر رنج و redraw چارت
   void UpdateTrendStatus(string fullText) // به‌روزرسانی متن نمایش
   {
      if(!Inp_Visual_ShowTrendStatus) return; // خروج اگر نمایش خاموش

      ObjectSetString(0, m_trendStatusObjectName, OBJPROP_TEXT, fullText); // تنظیم متن جدید
      ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_COLOR, Inp_Visual_FontColor_Neutral); // رنگ خنثی برای متن چندخطی
      ChartRedraw(); // redraw چارت
   }
};

#endif
```
