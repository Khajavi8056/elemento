```mql5
//+------------------------------------------------------------------+
//|                                                     Settings.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل شامل تعریف ساختارهای پایه‌ای و پارامترهای ورودی (inputs) برای اکسپرت Elemento است.
// استراتژی کلی اکسپرت: Elemento یک سیستم معاملاتی مبتنی بر شکست رنج (Breakout Range) است که بر اساس زمان‌های مشخص (رنج‌های زمانی) عمل می‌کند. 
// این اکسپرت تا چهار رنج زمانی مختلف را تعریف می‌کند، هر رنج را بر اساس ارتفاع قیمت (High/Low) در بازه زمانی تعیین‌شده شناسایی می‌کند، 
// سپس منتظر شکست (Breakout) سقف یا کف رنج با افست (Offset) مبتنی بر ATR یا درصد ارتفاع رنج می‌ماند. 
// پس از شکست، با تأیید اختیاری قیمت (کندل تایید) و فیلتر روند ایچیموکو، معامله خرید یا فروش باز می‌کند. 
// مدیریت معامله شامل استاپ لاس (SL) مبتنی بر استراتژی جایگذاری (مقابل رنج یا سطح شکست) به علاوه تنظیم ATR یا درصد 
// (برای پوشش کامل رنج و جلوگیری از زیان زودرس)، خروج پله‌ای (Partial Close) در رسیدن به نسبت مشخص سود به ریسک بدون تارگت کل 
// (برای اجازه دادن به روند ادامه‌دار)، و تریلینگ استاپ (Trailing Stop) برای حفظ سود است. 
// پاکسازی رنج‌ها پس از انقضا یا بسته شدن بازار انجام می‌شود تا از تداخل جلوگیری شود.
// منطق فایل Settings.mqh: این فایل هیچ کدی اجرایی ندارد و فقط enums و گروه‌های input را تعریف می‌کند تا کاربر بتواند پارامترها را تنظیم کند. 
// enums برای حالت‌های مختلف (مانند PLACEMENT_MODE برای تعیین افست شکست، SL_STRATEGY برای استراتژی جایگذاری SL، 
// SL_CALC_MODE برای محاسبه بافر SL، TRAILING_MODE برای تریلینگ) استفاده می‌شوند. 
// گروه‌های input شامل تنظیمات عمومی (ریسک، دیباگ، تایید قیمت)، فیلتر ایچیموکو (برای جلوگیری از معاملات خلاف روند)، 
// نمایشگر چارت (برای نشان دادن وضعیت روند هر رنج به طور جداگانه)، و تنظیمات چهار رنج جداگانه (هر رنج می‌تواند تایم‌فریم، ساعات، 
// حداقل/حداکثر ارتفاع، دوره‌های ATR، ضرایب، نسبت R:R، درصد خروج پله‌ای، ساعت پاکسازی و رنگ داشته باشد) است. 
// این ساختار اجازه می‌دهد اکسپرت برای بازارهای مختلف (مانند فارکس یا شاخص‌ها) سفارشی‌سازی شود و استراتژی شکست رنج را با فیلتر روند ترکیب کند 
// تا سیگنال‌های معتبرتری تولید شود. فایل توسط سایر فایل‌ها include می‌شود تا به inputs دسترسی داشته باشند. 
// تغییرات جدید در نسخه 2.00: به‌روزرسانی کامنت‌ها برای دقت بیشتر، بدون تغییر در enums یا inputs، اما اضافه شدن توضیحات دقیق‌تر برای هر پارامتر 
// به منظور راهنمایی بهتر کاربر در تنظیمات.

#ifndef SETTINGS_MQH  // چک وجود فایل برای جلوگیری از include مکرر
#define SETTINGS_MQH  // تعریف ماکرو برای جلوگیری از include مجدد

// تعریف enum برای حالت‌های مختلف قرارگیری سفارش (تعیین افست شکست رنج با ATR یا درصد ارتفاع رنج برای جلوگیری از شکست‌های کاذب)
// این enum اجازه می‌دهد کاربر بین محاسبه پویا (ATR) یا ثابت (درصد) برای افست شکست انتخاب کند
enum ENUM_PLACEMENT_MODE
{
   PLACEMENT_ATR,    // استفاده از ATR برای محاسبه افست ثبت سفارش (پویا بر اساس نوسان بازار، مناسب برای بازارهای متغیر)
   PLACEMENT_PERCENT // استفاده از درصد ارتفاع رنج برای محاسبه افست ثبت سفارش (ثابت بر اساس اندازه رنج، مناسب برای رنج‌های پایدار)
};

// تعریف enum برای استراتژی جایگذاری استاپ لاس (تعیین پایه SL: مقابل رنج یا سطح شکست)
// این enum به کاربر اجازه می‌دهد بین استراتژی محافظه‌کارانه (مقابل رنج) یا تهاجمی (سطح شکست) انتخاب کند
enum ENUM_SL_STRATEGY
{
   SL_OPPOSITE_SIDE,  // استاپ لاس در سمت مقابل رنج (قبلی: برای BUY در کف - بافر، برای SELL در سقف + بافر، محافظه‌کارانه‌تر)
   SL_BREAKOUT_LEVEL  // استاپ لاس در سطح شکست (جدید: برای BUY در سقف - بافر، برای SELL در کف + بافر، ریسک بالاتر اما سود بالقوه بیشتر)
};

// تعریف enum برای حالت محاسبه بافر استاپ لاس (تعیین فاصله بافر SL با ATR یا درصد ارتفاع رنج)
// این enum برای تطبیق بافر SL با نوسان یا اندازه رنج استفاده می‌شود
enum ENUM_SL_CALC_MODE
{
   SL_CALC_ATR,    // استفاده از ATR برای محاسبه بافر استاپ لاس (پویا و تطبیقی با نوسان بازار، توصیه‌شده)
   SL_CALC_PERCENT // استفاده از درصد ارتفاع رنج برای محاسبه بافر استاپ لاس (ثابت و ساده، برای رنج‌های کوچک)
};

// تعریف enum برای حالت‌های تریلینگ استاپ (تعیین فاصله تریلینگ با ATR یا Senkou Span B برای حفظ سود)
// این enum گزینه‌های پویا (ATR) یا مبتنی بر ابر ایچیموکو (Senkou B) را فراهم می‌کند
enum ENUM_TRAILING_MODE
{
   TRAILING_ATR,   // استفاده از ATR برای محاسبه فاصله تریلینگ استاپ (پویا و مبتنی بر نوسان اخیر)
   TRAILING_ICHIMOKU_B  // استفاده از Senkou Span B برای تریلینگ استاپ (بر اساس ابر ایچیموکو، برای روندهای بلندمدت)
};

// (جدید) تعریف enum برای استراتژی ابطال تلاش برای ورود (انتخاب بین حالت صبور یا تهاجمی برای ابطال فرصت ورود)
// این enum انعطاف‌پذیری در رفتار ابطال سیگنال را افزایش می‌دهد
enum ENUM_INVALIDATION_MODE
{
   INVALIDATION_RANGE_REENTRY,     // حالت صبور: فرصت ورود فقط در صورت بازگشت قیمت به داخل رنج اصلی باطل می‌شود (فرصت‌های بیشتر)
   INVALIDATION_BREAKOUT_LINE_CROSS  // حالت تهاجمی: فرصت ورود به محض بازگشت قیمت به زیر خط شکست باطل می‌شود (ریسک کمتر)
};

// (جدید) تعریف enum برای استراتژی تایید/ابطال (انتخاب بین حالت قدیمی با تایمر کندلی و جدید با ابطال قیمت)
// این enum به کاربر اجازه می‌دهد بین رویکرد زمانی یا قیمتی انتخاب کند
enum ENUM_CONFIRMATION_STRATEGY
{
   CONFIRMATION_TIMEOUT,           // حالت قدیمی: مهلت تایید با تعداد کندل (Inp_Confirmation_Timeout، محدودکننده)
   CONFIRMATION_PRICE_INVALIDATION // حالت جدید: ابطال بر اساس بازگشت قیمت بدون محدودیت زمانی (انعطاف‌پذیرتر)
};

// گروه ورودی برای تنظیمات عمومی (پارامترهای پایه‌ای که بر تمام رنج‌ها تأثیر می‌گذارند)
// این گروه شامل تنظیمات ریسک، دیباگ و استراتژی‌های عمومی است
input group "تنظیمات عمومی"  // عنوان گروه در تنظیمات MT5
input long InpBaseMagicNumber = 123456; // مجیک نامبر پایه (برای تمایز معاملات رنج‌های مختلف و جلوگیری از تداخل با دیگر اکسپرت‌ها، منحصربه‌فرد باشد)
input double InpRiskPercent = 1.0; // درصد ریسک (0.1 تا 5.0) - مقدار ریسک هر معامله بر اساس موجودی حساب برای کنترل زیان کلی (توصیه: 1-2%)
input bool InpDebugMode = true; // حالت دیباگ (چاپ پیام‌های اضافی برای عیب‌یابی و نظارت بر عملکرد اکسپرت، خاموش برای لایو)
// (جدید) انتخاب‌گر استراتژی ابطال تلاش ورود (برای انعطاف‌پذیری در رفتار اکسپرت: صبور یا تهاجمی)
input ENUM_INVALIDATION_MODE Inp_Invalidation_Mode = INVALIDATION_RANGE_REENTRY; // استراتژی ابطال: بازگشت به رنج (صبور، فرصت بیشتر) یا عبور از خط شکست (تهاجمی، ایمن‌تر)
// (جدید) انتخاب‌گر استراتژی تایید/ابطال (انتخاب بین قدیمی با تایمر و جدید با قیمت)
input ENUM_CONFIRMATION_STRATEGY Inp_Confirmation_Strategy = CONFIRMATION_PRICE_INVALIDATION; // استراتژی تایید: تایمر کندلی (قدیمی، محدود) یا ابطال قیمت (جدید، انعطاف‌پذیر)
input int Inp_Confirmation_Timeout = 3; // مهلت تأیید قیمت و فیلتر (تعداد کندل) - فقط اگر CONFIRMATION_TIMEOUT انتخاب شود (1-10 توصیه‌شده)
input bool Inp_PriceConfirmation_Enabled = true; // فعال کردن تأیید قیمت پس از کندل شکننده (اگر خاموش باشد، مستقیم به فیلتر روند می‌رود یا ورود، برای سرعت بیشتر)

// گروه ورودی برای فیلتر روند ایچیموکو (برای اطمینان از معامله در جهت روند یا خنثی و جلوگیری از معاملات خلاف روند)
// این گروه پارامترهای ایچیموکو را برای فیلتر دینامیک تنظیم می‌کند
input group "فیلتر روند ایچیموکو"  // عنوان گروه
input bool Inp_IchimokuFilter_Enabled = true; // فعال کردن فیلتر روند ایچیموکو (اگر خاموش باشد، همیشه خنثی فرض می‌شود و همه سیگنال‌ها مجاز)
input int Inp_Ichimoku_Tenkan = 9; // دوره تنکان-سن (خط سریع ایچیموکو برای تشخیص روند کوتاه‌مدت، پیش‌فرض استاندارد)
input int Inp_Ichimoku_Kijun = 26; // دوره کیجون-سن (خط کند ایچیموکو برای تشخیص روند میان‌مدت، پیش‌فرض استاندارد)
input int Inp_Ichimoku_SenkouB = 52; // دوره سنکو اسپن B (ابر ایچیموکو برای تشخیص حمایت/مقاومت آینده، پیش‌فرض استاندارد)
input int Inp_Ichimoku_FlatThreshold_Points = 90; // آستانه تشخیص ابر فلت به پوینت (برای تعیین روند خنثی اگر تفاوت سنکو A و B کمتر باشد، بر اساس نماد تنظیم شود)

// گروه ورودی برای تنظیمات نمایشگر چارت (برای نمایش بصری وضعیت روند هر رنج به طور جداگانه روی چارت به کاربر)
// این گروه برای نظارت بصری کاربر است و عملکرد را تحت تأثیر قرار نمی‌دهد
input group "تنظیمات نمایشگر چارت"  // عنوان گروه
input bool Inp_Visual_ShowTrendStatus = true; // فعال کردن نمایش وضعیت روند (روی چارت برای نظارت بصری هر رنج، خاموش برای چارت تمیزتر)
input int Inp_Visual_FontSize = 12; // اندازه فونت نمایشگر (برای خوانایی بهتر، 8-16 مناسب)
input color Inp_Visual_FontColor_Buy = clrGreen; // رنگ متن برای روند BUY (سبز برای مثبت، قابل تغییر)
input color Inp_Visual_FontColor_Sell = clrRed; // رنگ متن برای روند SELL (قرمز برای منفی، قابل تغییر)
input color Inp_Visual_FontColor_Neutral = clrGray; // رنگ متن برای روند NEUTRAL (خاکستری برای خنثی، قابل تغییر)
input int Inp_Visual_X_Offset = 10; // فاصله افقی از لبه چارت (پیکسل برای موقعیت مناسب، 0-50)
input int Inp_Visual_Y_Offset = 10; // فاصله عمودی از لبه چارت (پیکسل برای موقعیت مناسب، 0-50)

// گروه ورودی برای تنظیمات رنج ۱ (اولین رنج زمانی، معمولاً برای سشن آسیا یا شبانه)
// این گروه پارامترهای اختصاصی رنج 1 را شامل می‌شود
input group "تنظیمات رنج 1"  // عنوان گروه
input bool InpRange1_Enabled = true; // فعال کردن رنج 1 (اگر خاموش باشد، این رنج نادیده گرفته می‌شود و منابع صرفه‌جویی می‌شود)
input ENUM_TIMEFRAMES InpRange1_Execution_Timeframe = PERIOD_M5; // تایم‌فریم اجرا رنج 1 (برای اجرای منطق رنج و محاسبات، M1-M30 توصیه‌شده)
input ENUM_TIMEFRAMES InpRange1_TrendFilter_Timeframe = PERIOD_H1; // تایم‌فریم فیلتر روند رنج 1 (برای فیلتر ایچیموکو، می‌تواند متفاوت باشد، H1-H4 مناسب)
input int InpRange1_Start_Hour = 22; // ساعت شروع رنج 1 (0-23 برای تعریف بازه زمانی، بر اساس GMT سرور)
input int InpRange1_Start_Minute = 0; // دقیقه شروع رنج 1 (0-59 برای دقت زمانی، 0 برای شروع ساعتی)
input int InpRange1_End_Hour = 9; // ساعت پایان رنج 1 (0-23، اگر کمتر از شروع باشد، رنج شبانه فرض می‌شود)
input int InpRange1_End_Minute = 30; // دقیقه پایان رنج 1 (0-59، برای پایان دقیق)
input int InpRange1_MinRangePoints = 200; // حداقل ارتفاع رنج 1 به پوینت (برای فیلتر رنج‌های کوچک و بی‌کیفیت، بر اساس نماد تنظیم شود)
input int InpRange1_MaxRangePoints = 1500; // حداکثر ارتفاع رنج 1 به پوینت (برای فیلتر رنج‌های بزرگ و پرریسک، بر اساس نوسان تنظیم شود)
input ENUM_PLACEMENT_MODE InpRange1_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 1 (افست شکست، ATR برای پویایی)
input int InpRange1_ATR_Period = 122; // دوره ATR برای ثبت سفارش رنج 1 (برای محاسبه افست پویا، 14-200)
input double InpRange1_ATR_Multiplier = 2.3; // ضریب ATR برای ثبت سفارش رنج 1 (برای تنظیم حساسیت افست، 1.0-3.0)
input ENUM_SL_STRATEGY InpRange1_SL_Strategy = SL_BREAKOUT_LEVEL; // استراتژی جایگذاری استاپ لاس رنج 1 (مقابل یا سطح شکست، BREAKOUT برای تهاجمی)
input ENUM_SL_CALC_MODE InpRange1_SL_Calc_Mode = SL_CALC_ATR; // حالت محاسبه بافر استاپ لاس رنج 1 (ATR برای تطبیق)
input int InpRange1_SL_ATR_Period = 62; // دوره ATR برای بافر استاپ لاس رنج 1 (14-100)
input double InpRange1_SL_ATR_Multiplier = 1.3; // ضریب ATR برای بافر استاپ لاس رنج 1 (0.5-2.0)
input ENUM_TRAILING_MODE InpRange1_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 1 (ATR برای پویایی)
input int InpRange1_Trailing_ATR_Period = 43; // دوره ATR برای تریلینگ رنج 1 (14-100)
input double InpRange1_Trailing_ATR_Multiplier = 1.4; // ضریب ATR برای تریلینگ رنج 1 (1.0-2.0)
input double InpRange1_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 1 (سود به ریسک برای خروج پله‌ای، 1.0-3.0)
input double InpRange1_PartialClosePercent = 60.0; // درصد بستن پله‌ای رنج 1 (هنگام رسیدن به RR، 30-70%)
input int InpRange1_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج 1 (0-24، زمان انقضای رنج پس از پایان، 1-12 مناسب)
input color InpRange1_Color = clrBlue; // رنگ مستطیل رنج 1 (برای نمایش گرافیکی روی چارت، آبی برای تمایز)

// گروه ورودی برای تنظیمات رنج ۲ (دومین رنج، معمولاً برای سشن اروپا)
// مشابه رنج 1، اما با پارامترهای بهینه‌شده برای سشن اروپا
input group "تنظیمات رنج 2"  // عنوان گروه
input bool InpRange2_Enabled = true; // فعال کردن رنج 2 (خاموش برای غیرفعال کردن)
input ENUM_TIMEFRAMES InpRange2_Execution_Timeframe = PERIOD_M15; // تایم‌فریم اجرا رنج 2 (M5-M30)
input ENUM_TIMEFRAMES InpRange2_TrendFilter_Timeframe = PERIOD_M15; // تایم‌فریم فیلتر روند رنج 2 (M15-H1)
input int InpRange2_Start_Hour = 5; // ساعت شروع رنج 2 (0-23)
input int InpRange2_Start_Minute = 0; // دقیقه شروع رنج 2 (0-59)
input int InpRange2_End_Hour = 13; // ساعت پایان رنج 2 (0-23)
input int InpRange2_End_Minute = 0; // دقیقه پایان رنج 2 (0-59)
input int InpRange2_MinRangePoints = 200; // حداقل ارتفاع رنج 2 به پوینت
input int InpRange2_MaxRangePoints = 3500; // حداکثر ارتفاع رنج 2 به پوینت
input ENUM_PLACEMENT_MODE InpRange2_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 2
input int InpRange2_ATR_Period = 27; // دوره ATR برای ثبت سفارش رنج 2
input double InpRange2_ATR_Multiplier = 2.8; // ضریب ATR برای ثبت سفارش رنج 2
input ENUM_SL_STRATEGY InpRange2_SL_Strategy = SL_OPPOSITE_SIDE; // استراتژی جایگذاری استاپ لاس رنج 2
input ENUM_SL_CALC_MODE InpRange2_SL_Calc_Mode = SL_CALC_ATR; // حالت محاسبه بافر استاپ لاس رنج 2
input int InpRange2_SL_ATR_Period = 86; // دوره ATR برای بافر استاپ لاس رنج 2
input double InpRange2_SL_ATR_Multiplier = 1.56; // ضریب ATR برای بافر استاپ لاس رنج 2
input ENUM_TRAILING_MODE InpRange2_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 2
input int InpRange2_Trailing_ATR_Period = 101; // دوره ATR برای تریلینگ رنج 2
input double InpRange2_Trailing_ATR_Multiplier = 1.58; // ضریب ATR برای تریلینگ رنج 2
input double InpRange2_RR_Ratio = 2.8; // نسبت R:R برای خروج پله‌ای رنج 2
input double InpRange2_PartialClosePercent = 26; // درصد بستن پله‌ای رنج 2
input int InpRange2_Cleanup_Hours = 4; // ساعت‌های پاکسازی رنج 2 (0-24)
input color InpRange2_Color = clrRed; // رنگ مستطیل رنج 2

// گروه ورودی برای تنظیمات رنج ۳ (سومین رنج، معمولاً برای سشن آمریکا)
// پارامترهای بهینه‌شده برای سشن آمریکا با رنج کوچک‌تر
input group "تنظیمات رنج 3"  // عنوان گروه
input bool InpRange3_Enabled = false; // فعال کردن رنج 3 (پیش‌فرض خاموش برای سادگی)
input ENUM_TIMEFRAMES InpRange3_Execution_Timeframe = PERIOD_M5; // تایم‌فریم اجرا رنج 3
input ENUM_TIMEFRAMES InpRange3_TrendFilter_Timeframe = PERIOD_M30; // تایم‌فریم فیلتر روند رنج 3
input int InpRange3_Start_Hour = 15; // ساعت شروع رنج 3 (0-23)
input int InpRange3_Start_Minute = 0; // دقیقه شروع رنج 3 (0-59)
input int InpRange3_End_Hour = 18; // ساعت پایان رنج 3 (0-23)
input int InpRange3_End_Minute = 0; // دقیقه پایان رنج 3 (0-59)
input int InpRange3_MinRangePoints = 100; // حداقل ارتفاع رنج 3 به پوینت
input int InpRange3_MaxRangePoints = 2110; // حداکثر ارتفاع رنج 3 به پوینت
input ENUM_PLACEMENT_MODE InpRange3_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 3
input int InpRange3_ATR_Period = 14; // دوره ATR برای ثبت سفارش رنج 3
input double InpRange3_ATR_Multiplier = 1.2; // ضریب ATR برای ثبت سفارش رنج 3
input ENUM_SL_STRATEGY InpRange3_SL_Strategy = SL_OPPOSITE_SIDE; // استراتژی جایگذاری استاپ لاس رنج 3
input ENUM_SL_CALC_MODE InpRange3_SL_Calc_Mode = SL_CALC_ATR; // حالت محاسبه بافر استاپ لاس رنج 3
input int InpRange3_SL_ATR_Period = 14; // دوره ATR برای بافر استاپ لاس رنج 3
input double InpRange3_SL_ATR_Multiplier = 1.5; // ضریب ATR برای بافر استاپ لاس رنج 3
input ENUM_TRAILING_MODE InpRange3_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 3
input int InpRange3_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج 3
input double InpRange3_Trailing_ATR_Multiplier = 1.0; // ضریب ATR برای تریلینگ رنج 3
input double InpRange3_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 3
input double InpRange3_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج 3
input int InpRange3_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج 3 (0-24)
input color InpRange3_Color = clrGreen; // رنگ مستطیل رنج 3

// گروه ورودی برای تنظیمات رنج ۴ (چهارمین رنج، برای سفارشی‌سازی اضافی یا تست)
// رنج پیش‌فرض خاموش برای جلوگیری از تداخل
input group "تنظیمات رنج 4"  // عنوان گروه
input bool InpRange4_Enabled = false; // فعال کردن رنج 4 (خاموش پیش‌فرض)
input ENUM_TIMEFRAMES InpRange4_Execution_Timeframe = PERIOD_CURRENT; // تایم‌فریم اجرا رنج 4 (CURRENT برای همخوانی با چارت)
input ENUM_TIMEFRAMES InpRange4_TrendFilter_Timeframe = PERIOD_CURRENT; // تایم‌فریم فیلتر روند رنج 4
input int InpRange4_Start_Hour = 0; // ساعت شروع رنج 4 (0-23)
input int InpRange4_Start_Minute = 0; // دقیقه شروع رنج 4 (0-59)
input int InpRange4_End_Hour = 0; // ساعت پایان رنج 4 (0-23)
input int InpRange4_End_Minute = 0; // دقیقه پایان رنج 4 (0-59)
input int InpRange4_MinRangePoints = 50; // حداقل ارتفاع رنج 4 به پوینت
input int InpRange4_MaxRangePoints = 500; // حداکثر ارتفاع رنج 4 به پوینت
input ENUM_PLACEMENT_MODE InpRange4_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 4
input int InpRange4_ATR_Period = 14; // دوره ATR برای ثبت سفارش رنج 4
input double InpRange4_ATR_Multiplier = 1.2; // ضریب ATR برای ثبت سفارش رنج 4
input ENUM_SL_STRATEGY InpRange4_SL_Strategy = SL_OPPOSITE_SIDE; // استراتژی جایگذاری استاپ لاس رنج 4
input ENUM_SL_CALC_MODE InpRange4_SL_Calc_Mode = SL_CALC_ATR; // حالت محاسبه بافر استاپ لاس رنج 4
input int InpRange4_SL_ATR_Period = 14; // دوره ATR برای بافر استاپ لاس رنج 4
input double InpRange4_SL_ATR_Multiplier = 1.5; // ضریب ATR برای بافر استاپ لاس رنج 4
input ENUM_TRAILING_MODE InpRange4_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 4
input int InpRange4_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج 4
input double InpRange4_Trailing_ATR_Multiplier = 1.0; // ضریب ATR برای تریلینگ رنج 4
input double InpRange4_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 4
input double InpRange4_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج 4
input int InpRange4_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج 4 (0-24)
input color InpRange4_Color = clrYellow; // رنگ مستطیل رنج 4

#endif  // پایان چک include
```

```mql5
//+------------------------------------------------------------------+
//|                                                       Elemento.mq5 |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل اصلی اکسپرت Elemento است و نقطه ورود برنامه (OnInit, OnDeinit, OnTick, OnTimer) را مدیریت می‌کند.
// استراتژی کلی اکسپرت: Elemento بر اساس استراتژی شکست رنج عمل می‌کند که رنج‌های زمانی را شناسایی می‌کند، 
// منتظر شکست با افست می‌ماند، با تایید اختیاری قیمت و فیلتر ایچیموکو تأیید می‌کند، معامله باز می‌کند 
// و سپس معامله را با خروج پله‌ای و تریلینگ مدیریت می‌کند. 
// این استراتژی برای بازارهای رنجی مانند سشن آسیا مناسب است و با فیلتر روند از معاملات خلاف جهت جلوگیری می‌کند تا ریسک کاهش یابد. 
// اکسپرت از چهار رنج همزمان پشتیبانی می‌کند تا پوشش کامل بازار را فراهم کند.
// منطق فایل Elemento.mq5: این فایل هماهنگ‌کننده اصلی است. 
// در OnInit اطلاعات نماد را کش می‌کند، ورودی‌ها را ولید می‌کند، چهار نمونه CRange را مقداردهی می‌کند، 
// هندل‌های ATR را ایجاد می‌کند، فیلتر روند و مدیر نمایش را راه‌اندازی می‌کند. 
// در OnDeinit تمام منابع را آزاد و پاکسازی سخت انجام می‌دهد. 
// در OnTick کندل‌های جدید را تشخیص می‌دهد، رنج‌ها را به‌روزرسانی می‌کند، وضعیت روند هر رنج را به طور جداگانه نمایش می‌دهد 
// و در صورت بسته بودن بازار پاکسازی می‌کند. 
// در OnTimer (هر ۶۰ ثانیه) معاملات فعال را مدیریت می‌کند تا بار OnTick کاهش یابد. 
// متغیرهای جهانی مانند g_ranges برای نگهداری رنج‌ها، g_lastBarTime برای تشخیص کندل جدید، و g_trendFilter برای فیلتر روند استفاده می‌شوند. 
// تغییرات جدید در نسخه 2.00: اضافه کردن include Logger.mqh برای لاگ هوشمند، جایگزینی Print ها با CLogger::Log، 
// اضافه متغیر lastTrendStatusText در OnTick برای جلوگیری از لاگ تکراری روند، به‌روزرسانی نسخه به 2.00، 
// کامنت‌گذاری دقیق‌تر هر خط، و حفظ منطق بازیابی حافظه در OnInit. 
// این تغییرات عملکرد را بهبود می‌بخشد و لاگ را تمیزتر می‌کند بدون تغییر در استراتژی اصلی.
// تغییرات جدید در نسخه 2.1: اعمال اصلاحات بلوپرینت برای رفع باگ‌های پاکسازی، ریس کاندیشن، DST و بازیابی وضعیت. نسخه به 2.1 به‌روزرسانی شد.

#property copyright "Copyright 2025, Hipoalgorithm Team"  // کپی‌رایت فایل
#property link      "https://hipoalgorithm.com"  // لینک وب‌سایت تیم
#property version   "2.1"  // ورژن نهایی با تغییرات مدیریت معامله و لاگ هوشمند
#property strict  // حالت厳格 برای جلوگیری از خطاهای کامپایل

#include "Settings.mqh"  // فایل تنظیمات برای دسترسی به ورودی‌ها و enums
#include "Logger.mqh"  // کتابخانه جدید لاگ هوشمند برای چاپ پیام‌های کنترل‌شده
#include "CRange.mqh"  // کلاس مدیریت رنج برای هر رنج جداگانه
#include "TrendFilter.mqh"  // کلاس فیلتر روند برای تعیین جهت روند
#include "VisualManager.mqh"  // کلاس مدیر نمایش برای نمایش بصری روی چارت

// آرایه برای ذخیره ۴ رنج (هر کدام یک نمونه از کلاس CRange برای مدیریت مستقل رنج‌ها)
// این آرایه اجازه می‌دهد چهار رنج همزمان بدون تداخل کار کنند
CRange g_ranges[4];  // آرایه رنج‌ها

// آرایه برای ذخیره زمان آخرین کندل هر تایم‌فریم (برای تشخیص کندل جدید و جلوگیری از اجرای مکرر)
// هر ایندکس مربوط به یک رنج است
datetime g_lastBarTime[4];  // آرایه زمان آخرین بار

// آرایه برای هندل‌های ATR shared (برای هر رنج یک هندل ATR برای محاسبات افست، SL و تریلینگ)
// هندل‌ها برای بهینه‌سازی محاسبات اندیکاتور استفاده می‌شوند
int g_atrHandles[4];  // آرایه هندل‌های ATR

// متغیرهای کش‌شده برای بهینه‌سازی (اطلاعات نماد برای محاسبه ریسک، حجم و فاصله‌ها به طور دقیق و مستقل از نوع نماد)
// کش کردن این مقادیر از فراخوانی مکرر SymbolInfoDouble جلوگیری می‌کند
double g_tickValue;  // ارزش تیک برای محاسبات ریسک (دلار به ازای هر تیک)
double g_tickSize;  // اندازه تیک برای دقت محاسبات (فاصله بین تیک‌ها)
double g_volumeStep;  // گام حجم برای راند کردن لات (مثلاً 0.01)
double g_volumeMin;  // حداقل حجم مجاز (مثلاً 0.01)
double g_volumeMax;  // حداکثر حجم مجاز (مثلاً 100)

// فلگ برای تشخیص حالت tester (برای رفتار متفاوت مانند نادیده گرفتن چک بازار بسته در بک‌تست)
// این فلگ عملکرد را در بک‌تست و لایو متمایز می‌کند
bool g_isTester = false;  // فلگ تستر

// فیلتر روند جهانی (نمونه‌ای از CTrendFilter برای استفاده مشترک در تمام رنج‌ها و تعیین جهت روند)
// این نمونه برای فیلتر دینامیک در هر رنج استفاده می‌شود
CTrendFilter g_trendFilter;  // فیلتر روند جهانی

// مدیر نمایش جهانی (نمونه‌ای از CVisualManager برای نمایش بصری وضعیت روند هر رنج روی چارت)
// این نمونه برای به‌روزرسانی متن نمایش استفاده می‌شود
CVisualManager g_visualManager;  // مدیر نمایش جهانی

// تابع شروع اکسپرت (OnInit): مقداردهی اولیه، چک ولیدیشن و راه‌اندازی تایمر
// این تابع در شروع اکسپرت فراخوانی می‌شود و تمام منابع را آماده می‌کند
int OnInit()  // تابع مقداردهی اولیه
{
   // تشخیص حالت تستر برای تنظیم رفتار خاص (مانند نادیده گرفتن چک بازار بسته در بک‌تست)
   // MQLInfoInteger اطلاعات محیط را برمی‌گرداند
   g_isTester = MQLInfoInteger(MQL_TESTER);  // تنظیم فلگ تستر
   
   // چاپ پیام دیباگ برای شروع مقداردهی با استفاده از Print (چون فقط یکبار اجرا می‌شود)
   // این پیام فقط در حالت دیباگ چاپ می‌شود
   if(InpDebugMode) Print("شروع مقداردهی اکسپرت Elemento نسخه 2.1...");  // چاپ شروع مقداردهی

   // کش اطلاعات سیمبل (نماد) برای استفاده در محاسبه ریسک، حجم و فاصله‌ها
   // SymbolInfoDouble اطلاعات معاملاتی نماد را برمی‌گرداند
   g_tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);  // کش ارزش تیک برای محاسبات ریسک
   g_tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);  // کش اندازه تیک برای دقت محاسبات
   g_volumeStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);  // کش گام حجم برای راند کردن لات
   g_volumeMin = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);  // کش حداقل حجم مجاز برای معاملات
   g_volumeMax = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);  // کش حداکثر حجم مجاز برای معاملات

   // چک ولید بودن اطلاعات نماد (اگر صفر یا نامعتبر باشد، اکسپرت متوقف می‌شود برای جلوگیری از محاسبات اشتباه)
   // این چک از خطاهای runtime جلوگیری می‌کند
   if(g_tickValue <= 0 || g_tickSize <= 0 || g_volumeStep <= 0)  // شرط چک مقادیر کش
   {
      // چاپ خطا و توقف اکسپرت با استفاده از Print (چون خطای مرگبار است)
      Print("خطای مرگبار: اطلاعات نماد نامعتبر است (tickValue/tickSize/volumeStep). اکسپرت متوقف می‌شود.");  // چاپ خطا و توقف اکسپرت
      return(INIT_FAILED);  // بازگشت شکست مقداردهی
   }

   // ولیدیشن ورودی‌های عمومی (اطمینان از محدوده مجاز برای جلوگیری از خطاهای منطقی)
   // این چک‌ها از اجرای نادرست جلوگیری می‌کنند
   if(InpRiskPercent <= 0 || InpRiskPercent > 5.0)  // چک محدوده ریسک
   {
      Print("خطا: RiskPercent باید بین 0.1 تا 5.0 باشد.");  // چاپ خطا برای ریسک نامعتبر
      return(INIT_PARAMETERS_INCORRECT);  // بازگشت شکست پارامترها
   }

   // ولیدیشن Inp_Confirmation_Timeout اگر حالت قدیمی انتخاب شده باشد
   // این چک فقط در حالت تایمر اعمال می‌شود
   if(Inp_Confirmation_Strategy == CONFIRMATION_TIMEOUT && (Inp_Confirmation_Timeout < 1 || Inp_Confirmation_Timeout > 10))  // چک محدوده تایم‌اوت
   {
      Print("خطا: Confirmation_Timeout باید بین 1 تا 10 باشد (برای حالت تایمر).");  // چاپ خطا برای تایم‌اوت نامعتبر
      return(INIT_PARAMETERS_INCORRECT);  // بازگشت شکست پارامترها
   }

   // مقداردهی ۴ رنج (برای هر رنج فعال، پارامترها را از ورودی‌ها گرفته، هندل ATR می‌سازد و Init می‌کند)
   // حلقه برای مقداردهی چهار رنج به صورت جداگانه
   for(int i = 0; i < 4; i++)  // حلقه برای مقداردهی چهار رنج
   {
      // چک فعال بودن رنج بر اساس ورودی مربوطه (استفاده از شرط سه‌تایی برای سادگی)
      bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;  // چک فعال بودن رنج بر اساس ورودی
      if(!enabled)  // شرط غیرفعال
      {
         // چاپ دیباگ برای رنج غیرفعال با استفاده از CLogger (برای لاگ هوشمند)
         CLogger::Log("رنج " + IntegerToString(i + 1) + " غیرفعال است. رد می‌شود.", i + 1);  // چاپ دیباگ برای رنج غیرفعال
         continue;  // پرش به رنج بعدی
      }

      // مجیک نامبر منحصربه‌فرد برای هر رنج جهت تمایز معاملات
      long magic = InpBaseMagicNumber + i;  // مجیک نامبر منحصربه‌فرد برای هر رنج جهت تمایز معاملات
      // استخراج ساعت و دقیقه شروع از ورودی مربوطه
      int startHour = i == 0 ? InpRange1_Start_Hour : i == 1 ? InpRange2_Start_Hour : i == 2 ? InpRange3_Start_Hour : InpRange4_Start_Hour;  // ساعت شروع رنج
      int startMinute = i == 0 ? InpRange1_Start_Minute : i == 1 ? InpRange2_Start_Minute : i == 2 ? InpRange3_Start_Minute : InpRange4_Start_Minute;  // دقیقه شروع رنج
      // استخراج ساعت و دقیقه پایان از ورودی مربوطه
      int endHour = i == 0 ? InpRange1_End_Hour : i == 1 ? InpRange2_End_Hour : i == 2 ? InpRange3_End_Hour : InpRange4_End_Hour;  // ساعت پایان رنج
      int endMinute = i == 0 ? InpRange1_End_Minute : i == 1 ? InpRange2_End_Minute : i == 2 ? InpRange3_End_Minute : InpRange4_End_Minute;  // دقیقه پایان رنج

      // چک ولید بودن ساعات و دقیقه‌ها (برای جلوگیری از زمان‌های نامعتبر)
      // این چک از خطاهای زمانی جلوگیری می‌کند
      if(startHour < 0 || startHour > 23 || startMinute < 0 || startMinute > 59 ||  // شرط چک شروع
         endHour < 0 || endHour > 23 || endMinute < 0 || endMinute > 59)  // شرط چک پایان
      {
         Print("خطا: ساعات یا دقیقه‌های رنج " + IntegerToString(i + 1) + " نامعتبر است.");  // چاپ خطا برای زمان نامعتبر
         return(INIT_PARAMETERS_INCORRECT);  // بازگشت شکست پارامترها
      }

      // استخراج تایم‌فریم اجرا از ورودی مربوطه
      ENUM_TIMEFRAMES timeframe = i == 0 ? InpRange1_Execution_Timeframe : i == 1 ? InpRange2_Execution_Timeframe : i == 2 ? InpRange3_Execution_Timeframe : InpRange4_Execution_Timeframe;  // تایم‌فریم اجرا رنج
      // استخراج دوره ATR از ورودی مربوطه
      int atrPeriod = i == 0 ? InpRange1_ATR_Period : i == 1 ? InpRange2_ATR_Period : i == 2 ? InpRange3_ATR_Period : InpRange4_ATR_Period;  // دوره ATR برای افست
      // ایجاد هندل ATR برای محاسبات پویا با استفاده از iATR
      g_atrHandles[i] = iATR(_Symbol, timeframe, atrPeriod);  // ایجاد هندل ATR برای محاسبات پویا
      if(g_atrHandles[i] == INVALID_HANDLE)  // چک هندل معتبر
      {
         Print("خطا در ایجاد هندل ATR برای رنج " + IntegerToString(i + 1));  // چاپ خطا برای هندل نامعتبر
         return(INIT_FAILED);  // بازگشت شکست مقداردهی
      }

      // استخراج استراتژی SL از ورودی مربوطه
      ENUM_SL_STRATEGY slStrategy = i == 0 ? InpRange1_SL_Strategy : i == 1 ? InpRange2_SL_Strategy : i == 2 ? InpRange3_SL_Strategy : InpRange4_SL_Strategy;  // استراتژی SL
      // استخراج حالت محاسبه بافر SL از ورودی مربوطه
      ENUM_SL_CALC_MODE slCalcMode = i == 0 ? InpRange1_SL_Calc_Mode : i == 1 ? InpRange2_SL_Calc_Mode : i == 2 ? InpRange3_SL_Calc_Mode : InpRange4_SL_Calc_Mode;  // حالت محاسبه بافر SL
      // استخراج دوره ATR برای SL از ورودی مربوطه
      int slAtrPeriod = i == 0 ? InpRange1_SL_ATR_Period : i == 1 ? InpRange2_SL_ATR_Period : i == 2 ? InpRange3_SL_ATR_Period : InpRange4_SL_ATR_Period;  // دوره ATR برای SL
      // استخراج ضریب ATR برای SL از ورودی مربوطه
      double slAtrMultiplier = i == 0 ? InpRange1_SL_ATR_Multiplier : i == 1 ? InpRange2_SL_ATR_Multiplier : i == 2 ? InpRange3_SL_ATR_Multiplier : InpRange4_SL_ATR_Multiplier;  // ضریب ATR برای SL

      // فراخوانی Init برای هر رنج با پارامترهای مربوطه (مقداردهی کامل رنج، شامل SL strategy جدید)
      // استفاده از شرط سه‌تایی برای استخراج پارامترهای دیگر
      if(!g_ranges[i].Init(  // فراخوانی Init رنج
         i + 1, magic, timeframe, startHour, startMinute, endHour, endMinute,  // پارامترهای پایه
         i == 0 ? InpRange1_MinRangePoints : i == 1 ? InpRange2_MinRangePoints : i == 2 ? InpRange3_MinRangePoints : InpRange4_MinRangePoints,  // حداقل ارتفاع
         i == 0 ? InpRange1_MaxRangePoints : i == 1 ? InpRange2_MaxRangePoints : i == 2 ? InpRange3_MaxRangePoints : InpRange4_MaxRangePoints,  // حداکثر ارتفاع
         i == 0 ? InpRange1_Placement_Mode : i == 1 ? InpRange2_Placement_Mode : i == 2 ? InpRange3_Placement_Mode : InpRange4_Placement_Mode,  // حالت افست
         atrPeriod,  // دوره ATR
         i == 0 ? InpRange1_ATR_Multiplier : i == 1 ? InpRange2_ATR_Multiplier : i == 2 ? InpRange3_ATR_Multiplier : InpRange4_ATR_Multiplier,  // ضریب ATR
         slStrategy, slCalcMode, slAtrPeriod, slAtrMultiplier,  // پارامترهای SL
         i == 0 ? InpRange1_Trailing_Mode : i == 1 ? InpRange2_Trailing_Mode : i == 2 ? InpRange3_Trailing_Mode : InpRange4_Trailing_Mode,  // حالت تریلینگ
         i == 0 ? InpRange1_Trailing_ATR_Period : i == 1 ? InpRange2_Trailing_ATR_Period : i == 2 ? InpRange3_Trailing_ATR_Period : InpRange4_Trailing_ATR_Period,  // دوره تریلینگ
         i == 0 ? InpRange1_Trailing_ATR_Multiplier : i == 1 ? InpRange2_Trailing_ATR_Multiplier : i == 2 ? InpRange3_Trailing_ATR_Multiplier : InpRange4_Trailing_ATR_Multiplier,  // ضریب تریلینگ
         i == 0 ? InpRange1_RR_Ratio : i == 1 ? InpRange2_RR_Ratio : i == 2 ? InpRange3_RR_Ratio : InpRange4_RR_Ratio,  // نسبت RR
         i == 0 ? InpRange1_PartialClosePercent : i == 1 ? InpRange2_PartialClosePercent : i == 2 ? InpRange3_PartialClosePercent : InpRange4_PartialClosePercent,  // درصد پله‌ای
         i == 0 ? InpRange1_Cleanup_Hours : i == 1 ? InpRange2_Cleanup_Hours : i == 2 ? InpRange3_Cleanup_Hours : InpRange4_Cleanup_Hours,  // ساعت پاکسازی
         i == 0 ? InpRange1_Color : i == 1 ? InpRange2_Color : i == 2 ? InpRange3_Color : InpRange4_Color,  // رنگ
         i == 0 ? InpRange1_TrendFilter_Timeframe : i == 1 ? InpRange2_TrendFilter_Timeframe : i == 2 ? InpRange3_TrendFilter_Timeframe : InpRange4_TrendFilter_Timeframe,  // تایم‌فریم فیلتر
         g_atrHandles[i]  // هندل ATR
      ))  // پایان فراخوانی Init
      {
         Print("خطا در مقداردهی رنج " + IntegerToString(i + 1) + ": " + IntegerToString(GetLastError()));  // چاپ خطا برای شکست Init
         return(INIT_PARAMETERS_INCORRECT);  // بازگشت شکست پارامترها
      }
   }

   // (جدید) اضافه کردن حافظه: چک معاملات باز برای هر رنج و بازگردانی حالت اگر معامله‌ای باز باشد (برای مقاومت در برابر ری‌استارت)
   // این حلقه معاملات باز را بازیابی می‌کند
   for(int i = 0; i < 4; i++)  // حلقه برای هر رنج
   {
      // چک فعال بودن رنج
      bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;  // چک فعال بودن
      if(!enabled) continue;  // پرش اگر غیرفعال

      long magic = InpBaseMagicNumber + i;  // مجیک رنج
      // جستجو در پوزیشن‌های باز از انتها به ابتدا برای کارایی
      for(int pos = PositionsTotal() - 1; pos >= 0; pos--)  // جستجو در پوزیشن‌های باز
      {
         // چک نماد و مجیک برای تطبیق
         if(PositionGetSymbol(pos) == _Symbol && PositionGetInteger(POSITION_MAGIC) == magic)  // چک نماد و مجیک
         {
            ulong ticket = PositionGetInteger(POSITION_TICKET);  // گرفتن تیکت
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);  // قیمت ورود
            double sl = PositionGetDouble(POSITION_SL);  // SL فعلی

            g_ranges[i].SetActiveTicket(ticket);  // تنظیم تیکت فعال در رنج
            g_ranges[i].SetCurrentState(MANAGING_TRADE);  // تغییر حالت به مدیریت معامله

            // چک اگر SL به نقطه ورود منتقل شده (ریسک-فری شده) با تلرانس کوچک
            if (MathAbs(sl - openPrice) < _Point)  // چک نزدیکی SL به ورود (با تلرانس کوچک)
            {
               g_ranges[i].SetPartialClosedFlag(true);  // تنظیم فلگ پله‌ای انجام شده
               CLogger::Log("معامله رنج " + IntegerToString(i+1) + " قبلاً ریسک-فری شده. حالت بازیابی شد.", i + 1);  // چاپ دیباگ
            }

            // بازیابی اطلاعات اضافی از کامنت معامله (برای اصلاح باگ بازیابی ناقص)
            string comment = PositionGetString(POSITION_COMMENT);  // گرفتن کامنت معامله
            string parts[];  // آرایه برای پارس کامنت
            if(StringSplit(comment, ';', parts) >= 4)  // پارس کامنت با جداکننده ';'
            {
               double rec_high = StringToDouble(StringSubstr(parts[1], 2));  // استخراج High
               double rec_low = StringToDouble(StringSubstr(parts[2], 2));  // استخراج Low
               double rec_sl_dist = StringToDouble(StringSubstr(parts[3], 4));  // استخراج SL Distance
               g_ranges[i].RestoreState(rec_high, rec_low, rec_sl_dist);  // فراخوانی RestoreState برای بازیابی
            }
            else
            {
               CLogger::Log("کامنت معامله برای بازیابی وضعیت نامعتبر است.", i+1);  // لاگ خطا در پارس کامنت
            }

            CLogger::Log("معامله باز برای رنج " + IntegerToString(i+1) + " بازیابی شد. تیکت: " + (string)ticket, i + 1);  // چاپ دیباگ
            break;  // خروج از حلقه داخلی
         }
      }
   }

   // مقداردهی فیلتر روند جهانی (برای تعیین جهت روند در تمام رنج‌ها)
   // فراخوانی Init فیلتر (که خالی است اما برای سازگاری)
   if(!g_trendFilter.Init())  // چک موفقیت Init
   {
      Print("خطا در مقداردهی فیلتر روند.");  // چاپ خطا برای شکست Init فیلتر
      return(INIT_FAILED);  // بازگشت شکست مقداردهی
   }
   // مقداردهی مدیر نمایش جهانی (برای نمایش وضعیت روند هر رنج روی چارت)
   // فراخوانی Init نمایشگر
   if(!g_visualManager.Init())  // چک موفقیت Init
   {
      Print("خطا در مقداردهی مدیر نمایش.");  // چاپ خطا برای شکست Init نمایشگر
      return(INIT_FAILED);  // بازگشت شکست مقداردهی
   }

   // مقداردهی اولیه زمان آخرین کندل‌ها (برای تشخیص کندل جدید در OnTick)
   // حلقه برای ریست زمان‌ها به صفر
   for(int i = 0; i < 4; i++)  // حلقه برای ریست زمان‌ها
   {
      g_lastBarTime[i] = 0;  // تنظیم زمان اولیه به صفر
   }

   // راه‌اندازی تایمر برای مدیریت معاملات هر ۶۰ ثانیه (بهینه‌سازی عملکرد OnTick)
   // EventSetTimer تایمر را فعال می‌کند
   EventSetTimer(60);  // تنظیم تایمر ۶۰ ثانیه

   // چاپ موفقیت مقداردهی با Print (چون نهایی است)
   Print("مقداردهی اکسپرت Elemento نسخه 2.1 با موفقیت انجام شد.");  // چاپ موفقیت مقداردهی
   return(INIT_SUCCEEDED);  // بازگشت موفقیت
}

// تابع پایان اکسپرت (OnDeinit): پاکسازی منابع و پاکسازی سخت تمام رنج‌ها
// این تابع در پایان اکسپرت فراخوانی می‌شود و منابع را آزاد می‌کند
void OnDeinit(const int reason)  // تابع دفع با دلیل
{
   // چاپ دیباگ برای دلیل دفع با Print (چون فقط یکبار)
   if(InpDebugMode) Print("دفع مقداردهی اکسپرت Elemento نسخه 2.1. دلیل: " + IntegerToString(reason));  // چاپ دیباگ برای دلیل دفع

   // پاکسازی سخت تمام رنج‌ها برای بستن معاملات باقی‌مانده و ریست (در صورت کرش یا خروج)
   // حلقه برای پاکسازی سخت هر رنج
   for(int i = 0; i < 4; i++)  // حلقه برای پاکسازی سخت هر رنج
   {
      g_ranges[i].HardCleanup();  // فراخوانی پاکسازی سخت
   }

   // دفع هر رنج و آزادسازی هندل ATR مربوطه
   // حلقه برای دفع رنج‌ها و هندل‌ها
   for(int i = 0; i < 4; i++)  // حلقه برای دفع رنج‌ها
   {
      g_ranges[i].Deinit();  // دفع رنج
      if(g_atrHandles[i] != INVALID_HANDLE)  // چک هندل معتبر
      {
         IndicatorRelease(g_atrHandles[i]);  // آزادسازی هندل ATR
      }
   }

   // دفع فیلتر روند و مدیر نمایش
   g_trendFilter.Deinit();  // دفع فیلتر روند
   g_visualManager.Deinit();  // دفع مدیر نمایش
   // حذف تمام اشیاء گرافیکی با پیشوند Range_ برای پاکسازی چارت
   ObjectsDeleteAll(0, "Range_");  // حذف تمام اشیاء گرافیکی با پیشوند Range_ برای پاکسازی چارت
   Print("تمامی اشیاء گرافیکی پاکسازی شدند.");  // چاپ موفقیت پاکسازی اشیاء

   // خاموش کردن تایمر
   EventKillTimer();  // خاموش کردن تایمر
}

// تابع اصلی هر تیک (OnTick): تشخیص کندل جدید، به‌روزرسانی رنج‌ها و چک بازار
// این تابع در هر تیک قیمت فراخوانی می‌شود و منطق اصلی را اجرا می‌کند
void OnTick()  // تابع اصلی هر تیک
{
   // چک روز جدید برای به‌روزرسانی کش اطلاعات نماد (در صورت تغییر مشخصات بروکر)
   // متغیر استاتیک برای ذخیره روز آخرین به‌روزرسانی
   static datetime lastDay = 0;  // متغیر استاتیک برای ذخیره روز آخرین
   datetime currentDay = TimeCurrent() / 86400;  // محاسبه روز فعلی (ثانیه‌ها به روز)
   if(currentDay != lastDay)  // چک تغییر روز
   {
      // به‌روزرسانی کش اطلاعات نماد با فراخوانی مجدد SymbolInfoDouble
      g_tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);  // به‌روزرسانی ارزش تیک
      g_tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);  // به‌روزرسانی اندازه تیک
      g_volumeStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);  // به‌روزرسانی گام حجم
      g_volumeMin = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);  // به‌روزرسانی حداقل حجم
      g_volumeMax = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);  // به‌روزرسانی حداکثر حجم
      // چاپ دیباگ برای به‌روزرسانی با CLogger
      CLogger::Log("به‌روزرسانی کش اطلاعات نماد در روز جدید.");  // چاپ دیباگ برای به‌روزرسانی
      lastDay = currentDay;  // ذخیره روز جدید
   }

   // اگر تستر نیست و بازار بسته است یا یک ساعت قبل از بسته شدن، پاکسازی سخت انجام می‌شود
   // این شرط از معاملات در تعطیلات جلوگیری می‌کند
   if(!g_isTester && (IsMarketClosed() || IsOneHourBeforeMarketClose()))  // چک شرایط بازار بسته
   {
      // حلقه برای هر رنج فعال
      for(int i = 0; i < 4; i++)  // حلقه برای هر رنج
      {
         // چک فعال بودن رنج
         bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;  // چک فعال بودن
         if(enabled)  // شرط فعال
         {
            g_ranges[i].HardCleanup();  // پاکسازی سخت رنج (بستن معاملات و ریست برای جلوگیری از معاملات باز در تعطیلات)
         }
      }
      return;  // خروج از تابع
   }

   // فلگ برای تشخیص کندل جدید و به‌روزرسانی نمایش
   bool newBarDetected = false;  // فلگ برای تشخیص کندل جدید و به‌روزرسانی نمایش
   string trendDisplayText = "";  // متن کامل نمایش وضعیت روند هر رنج
   // متغیر استاتیک برای جلوگیری از لاگ تکراری وضعیت روند
   static string lastTrendStatusText = "";  // متغیر استاتیک برای جلوگیری از لاگ تکراری

   // حلقه برای هر رنج فعال
   for(int i = 0; i < 4; i++)  // حلقه برای هر رنج
   {
      // چک فعال بودن رنج
      bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;  // چک فعال بودن رنج
      if(!enabled) continue;  // پرش اگر غیرفعال

      // گرفتن تایم‌فریم اجرا رنج از کلاس CRange
      ENUM_TIMEFRAMES timeframe = g_ranges[i].GetTimeframe();  // گرفتن تایم‌فریم اجرا رنج

      // چک لود کافی تاریخچه برای هر رنج جداگانه (بر اساس تایم‌فریم اجرای رنج برای جلوگیری از اجرای زودرس)
      // Bars تعداد کندل‌های لودشده را برمی‌گرداند
      if(Bars(_Symbol, timeframe) < 200)  // چک تعداد بارها
      {
         CLogger::Log("تاریخچه کافی برای رنج " + IntegerToString(i + 1) + " لود نشده است. رد می‌شود.", i + 1);  // چاپ دیباگ برای تاریخچه ناکافی
         continue;  // پرش به رنج بعدی
      }

      // زمان کندل فعلی برای تشخیص جدید بودن با iTime
      datetime currentBarTime = iTime(_Symbol, timeframe, 0);  // زمان کندل فعلی برای تشخیص جدید بودن
      if(currentBarTime == 0)  // چک زمان معتبر
      {
         CLogger::Log("خطا: iTime مقدار نامعتبر برای رنج " + IntegerToString(i + 1), i + 1);  // چاپ خطا
         continue;  // پرش
      }

      // تشخیص کندل جدید و به‌روزرسانی رنج (فقط در کندل جدید اجرا می‌شود تا بار کاهش یابد)
      if(currentBarTime > g_lastBarTime[i])  // چک کندل جدید
      {
         // چاپ دیباگ برای کندل جدید با CLogger
         CLogger::Log("کندل جدید برای رنج " + IntegerToString(i + 1) + " در تایم‌فریم " + EnumToString(timeframe), i + 1);  // چاپ دیباگ برای کندل جدید
         g_ranges[i].UpdateOnNewBar();  // به‌روزرسانی ماشین حالت رنج
         g_lastBarTime[i] = currentBarTime;  // ذخیره زمان جدید
         newBarDetected = true;  // تنظیم فلگ برای به‌روزرسانی نمایش
      }

      // جمع‌آوری متن وضعیت روند برای نمایش (حتی بدون کندل جدید، برای ثبات)
      ENUM_TREND_DIRECTION trend = g_trendFilter.GetTrendDirection(g_ranges[i].GetTrendFilterTimeframe());  // گرفتن جهت روند رنج
      string trendStr = trend == TREND_BUY ? "Bullish" : trend == TREND_SELL ? "Bearish" : "Neutral";  // تبدیل به متن
      trendDisplayText += "Range " + IntegerToString(i + 1) + ": " + trendStr + "\n";  // اضافه به متن کامل
   }

   // اگر کندل جدید تشخیص داده شد، نمایش را به‌روزرسانی و لاگ اگر تغییر کند
   if(newBarDetected)  // شرط به‌روزرسانی
   {
      if(trendDisplayText != lastTrendStatusText)  // چک تغییر متن
      {
         CLogger::Log("وضعیت روند تغییر کرد: \n" + trendDisplayText);  // لاگ وضعیت جدید
         lastTrendStatusText = trendDisplayText;  // ذخیره متن جدید
      }
      g_visualManager.UpdateTrendStatus(trendDisplayText);  // به‌روزرسانی نمایشگر
   }
}

// تابع تایمر (OnTimer): مدیریت معاملات فعال هر ۶۰ ثانیه برای بهینه‌سازی
// این تابع برای جلوگیری از بار سنگین OnTick استفاده می‌شود
void OnTimer()  // تابع تایمر
{
   // حلقه برای هر رنج فعال
   for(int i = 0; i < 4; i++)  // حلقه برای هر رنج
   {
      // چک فعال بودن رنج
      bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;  // چک فعال بودن
      if(!enabled) continue;  // پرش اگر غیرفعال

      // چک و مدیریت پاکسازی رنج
      g_ranges[i].CheckCleanup();  // چک زمان انقضا و پاکسازی اگر لازم

      // مدیریت معامله فعال اگر وجود داشته باشد
      if(g_ranges[i].GetCurrentState() == MANAGING_TRADE)  // چک حالت مدیریت معامله
      {
         g_ranges[i].ManageActiveTrade();  // مدیریت خروج پله‌ای و تریلینگ
      }
   }
}

// چک بازار بسته: بررسی اگر بازار تعطیل باشد (برای جلوگیری از معاملات نامعتبر)
// SymbolInfoSessionTrade جلسه معاملاتی را چک می‌کند
bool IsMarketClosed()  // چک بازار بسته
{
   MqlDateTime dt;  // ساختار زمان
   TimeToStruct(TimeCurrent(), dt);  // تبدیل زمان فعلی
   datetime from, to;  // زمان‌های جلسه
   return !SymbolInfoSessionTrade(_Symbol, (ENUM_DAY_OF_WEEK)dt.day_of_week, 0, from, to);  // بازگشت بسته اگر جلسه نباشد
}

// چک یک ساعت قبل از بسته شدن بازار: برای جلوگیری از ورود نزدیک به تعطیلی
// این تابع زمان باقی‌مانده تا بسته شدن را چک می‌کند
bool IsOneHourBeforeMarketClose()  // چک یک ساعت قبل بسته شدن
{
   MqlDateTime dt;  // ساختار زمان
   TimeToStruct(TimeCurrent(), dt);  // تبدیل زمان فعلی
   datetime from, to;  // زمان‌های جلسه
   if(SymbolInfoSessionTrade(_Symbol, (ENUM_DAY_OF_WEEK)dt.day_of_week, 0, from, to))  // چک جلسه
   {
      datetime closeTime = from + to;  // زمان بسته شدن
      return (closeTime - TimeCurrent()) <= 3600;  // چک کمتر از یک ساعت
   }
   return true;  // اگر جلسه نباشد، بسته فرض شود
}
```

```mql5
//+------------------------------------------------------------------+
//|                                                     Logger.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// یک کتابخانه ساده و استاتیک برای مدیریت لاگ‌نویسی هوشمند
// این فایل برای جلوگیری از لاگ تکراری و نویز طراحی شده است.
// تغییرات نسخه 2.00: فایل جدید با CLogger استاتیک، m_lastMessage برای جلوگیری از تکرار، 
// فرمت استاندارد با پیشوند [Elemento] [Range X] >> پیام.

#ifndef LOGGER_MQH  // چک وجود
#define LOGGER_MQH  // تعریف ماکرو

// کلاس CLogger استاتیک برای لاگ بدون نمونه‌سازی
class CLogger  // کلاس لاگ
{
private:
   static string m_lastMessage;  // برای ذخیره آخرین پیام و جلوگیری از تکرار (استاتیک برای اشتراک)

public:
   // تابع اصلی لاگ‌نویسی
   // این تابع پیام را با چک تکرار چاپ می‌کند
   static void Log(string message, int rangeIndex = 0)  // تابع لاگ با پیام و ایندکس اختیاری
   {
      // فقط اگر حالت دیباگ فعال باشد لاگ می‌نویسد
      if(!InpDebugMode)  // شرط دیباگ
         return;  // خروج بدون چاپ
         
      // اگر پیام جدید با پیام قبلی یکی باشد، آن را نادیده می‌گیرد
      if(message == m_lastMessage)  // چک تکرار
         return;  // خروج

      string prefix = "[Elemento]";  // پیشوند کلی
      
      if(rangeIndex > 0)  // اگر مربوط به یک رنج خاص باشد
      {
         prefix += " [Range " + IntegerToString(rangeIndex) + "]";  // اضافه ایندکس
      }
      
      Print(prefix + " >> " + message);  // چاپ پیام نهایی با Print (MT5 استاندارد)
      
      m_lastMessage = message;  // ذخیره پیام فعلی برای مقایسه بعدی
   }
};

// مقداردهی اولیه متغیر استاتیک (خارج از کلاس)
string CLogger::m_lastMessage = "";  // مقداردهی اولیه متغیر استاتیک

#endif  // پایان
```

```mql5
//+------------------------------------------------------------------+
//|                                                      CRange.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CRange را تعریف می‌کند که مدیریت مستقل هر رنج را بر عهده دارد.
// استراتژی کلی اکسپرت: هر رنج یک ماشین حالت (state machine) است که مراحل شناسایی رنج، انتظار شکست، 
// تایید قیمت، فیلتر روند، ورود معامله، و مدیریت معامله (خروج پله‌ای و تریلینگ) را مدیریت می‌کند. 
// این کلاس اجازه می‌دهد چهار رنج همزمان بدون تداخل کار کنند.
// منطق فایل CRange.mqh: کلاس شامل متغیرهای خصوصی (مانند m_rangeHigh/Low برای سطوح رنج، m_potentialBuy/SellPrice برای سطوح شکست، 
// m_activeTicket برای معامله فعال، m_partialClosed برای خروج پله‌ای) و public (برای دسترسی خارجی مانند GetTimeframe). 
// enums برای حالت‌های رنج (مانند RANGE_WAITING، RANGE_IDENTIFIED، AWAITING_BREAKOUT) استفاده می‌شود. 
// توابع کلیدی: Init/Deinit برای مقداردهی/دفع، UpdateOnNewBar برای به‌روزرسانی ماشین حالت در کندل جدید، 
// IdentifyRange برای شناسایی رنج، CalculatePlacementOffset برای افست شکست، CalculateSL برای SL، 
// ExecuteTrade برای ورود معامله، ManageActiveTrade برای مدیریت (با خروج پله‌ای و تریلینگ)، 
// Soft/HardCleanup برای پاکسازی. 
// تغییرات جدید در نسخه 2.00: تغییر PartialClose به روش مخالف برای سازگاری، محاسبه سود بر اساس قیمت، 
// مدیریت مرحله‌ای در ManageActiveTrade، اضافه INVALIDATION_MODE و CONFIRMATION_STRATEGY، 
// به‌روزرسانی کامنت‌ها. 
// این تغییرات سیستم را مقاوم‌تر و انعطاف‌پذیرتر می‌کند بدون تغییر استراتژی اصلی.
// تغییرات جدید در نسخه 2.1: حذف CleanupPaths() و ادغام در SoftCleanup() هوشمند، اصلاح CheckCleanup()، 
// فراخوانی SoftCleanup() در ManageActiveTrade() هنگام بسته شدن موقعیت، اصلاح Race Condition با ریست m_slToBeMoved حتی در شکست، 
// اضافه m_initialSlDistance و RestoreState() برای بازیابی کامل وضعیت.

#ifndef C_RANGE_MQH  // چک وجود فایل برای جلوگیری از include مکرر
#define C_RANGE_MQH  // تعریف ماکرو برای جلوگیری از include مجدد

#include "Settings.mqh"  // فایل تنظیمات برای enums و ورودی‌ها
#include "Logger.mqh"  // لاگ هوشمند برای چاپ دیباگ
#include "TradeManager.mqh"  // کلاس مدیریت معامله برای خروج پله‌ای و تریلینگ
#include "RiskManager.mqh"  // کلاس ریسک برای محاسبه حجم
#include "TimeHelper.mqh"  // کلاس زمان برای محاسبات رنج و پاکسازی
#include <Trade\Trade.mqh>  // کلاس معامله استاندارد MT5

// تعریف enum برای حالت‌های ماشین رنج (برای مدیریت چرخه رنج از شناسایی تا مدیریت معامله)
// این enum جریان منطقی هر رنج را کنترل می‌کند
enum ENUM_RANGE_STATE
{
   RANGE_WAITING,       // انتظار برای شناسایی رنج جدید (حالت اولیه یا پس از پاکسازی)
   RANGE_IDENTIFIED,    // رنج شناسایی شده، منتظر شکست (پس از شناسایی High/Low)
   AWAITING_BREAKOUT,   // منتظر شکست با افست (پس از رسم سطوح)
   AWAITING_CONFIRMATION, // منتظر تایید قیمت و فیلتر روند (پس از شکست اولیه)
   MANAGING_TRADE,      // مدیریت معامله فعال (پس از ورود)
   RANGE_EXPIRED        // رنج منقضی شده، منتظر پاکسازی (پس از پایان زمان یا معامله بسته)
};

// کلاس CRange برای مدیریت مستقل هر رنج (شناسایی، شکست، ورود، مدیریت و پاکسازی)
// هر نمونه یک رنج را کنترل می‌کند
class CRange  // کلاس رنج
{
private:
   int m_rangeIndex;  // ایندکس رنج (1-4 برای لاگ و تمایز)
   long m_magic;  // مجیک نامبر منحصربه‌فرد برای معاملات این رنج
   ENUM_TIMEFRAMES m_timeframe;  // تایم‌فریم اجرا رنج (برای محاسبات)
   ENUM_TIMEFRAMES m_trendFilterTimeframe;  // تایم‌فریم فیلتر روند (برای ایچیموکو)
   int m_startHour, m_startMinute;  // ساعت/دقیقه شروع رنج
   int m_endHour, m_endMinute;  // ساعت/دقیقه پایان رنج
   int m_minRangePoints, m_maxRangePoints;  // حداقل/حداکثر ارتفاع رنج به پوینت
   ENUM_PLACEMENT_MODE m_placementMode;  // حالت افست شکست (ATR/درصد)
   int m_atrPeriod;  // دوره ATR برای افست
   double m_atrMultiplier;  // ضریب ATR برای افست
   ENUM_SL_STRATEGY m_slStrategy;  // استراتژی جایگذاری SL (مقابل/سطح شکست)
   ENUM_SL_CALC_MODE m_slCalcMode;  // حالت محاسبه بافر SL (ATR/درصد)
   int m_slAtrPeriod;  // دوره ATR برای SL
   double m_slAtrMultiplier;  // ضریب ATR برای SL
   ENUM_TRAILING_MODE m_trailingMode;  // حالت تریلینگ (ATR/ایچیموکو B)
   int m_trailingAtrPeriod;  // دوره ATR برای تریلینگ
   double m_trailingAtrMultiplier;  // ضریب ATR برای تریلینگ
   double m_rrRatio;  // نسبت R:R برای خروج پله‌ای
   double m_partialClosePercent;  // درصد خروج پله‌ای
   int m_cleanupHours;  // ساعت‌های انقضا پس از پایان رنج
   color m_color;  // رنگ گرافیکی رنج
   int m_atrHandle;  // هندل ATR برای افست (shared از Elemento)
   int m_slAtrHandle;  // هندل ATR برای SL (ایجاد در Init)
   int m_trailingAtrHandle;  // هندل ATR برای تریلینگ (ایجاد در Init)
   double m_rangeHigh, m_rangeLow;  // سطوح High/Low رنج شناسایی‌شده
   datetime m_rangeStartTime, m_rangeEndTime;  // زمان شروع/پایان رنج محاسبه‌شده
   datetime m_lastEndTime;  // زمان پایان آخرین رنج برای جلوگیری از پردازش مجدد
   bool m_lastInvalid;  // فلگ رنج نامعتبر قبلی برای جلوگیری از لاگ تکراری
   double m_potentialBuyPrice, m_potentialSellPrice;  // سطوح شکست خرید/فروش با افست
   double m_breakerCandleLevel;  // سطح کندل شکننده برای تایید قیمت
   int m_waitCounter;  // شمارنده برای تایم‌اوت تایید (اگر CONFIRMATION_TIMEOUT)
   datetime m_lastFilterBarTime;  // زمان آخرین چک فیلتر برای جلوگیری از چک مکرر
   ENUM_RANGE_STATE m_currentState;  // حالت فعلی ماشین رنج
   ulong m_activeTicket;  // تیکت معامله فعال (برای مدیریت)
   bool m_partialClosed;  // فلگ خروج پله‌ای انجام شده
   bool m_slToBeMoved;  // فلگ انتقال SL به ورود (ریسک-فری)
   double m_cachedATR;  // کش ATR برای افست (ریست در SoftCleanup)
   double m_cachedSlATR;  // کش ATR برای SL (ریست در SoftCleanup)
   double m_cachedTrailingATR;  // کش ATR برای تریلینگ (ریست در SoftCleanup)
   string m_rangeObjectName;  // نام مستطیل رنج برای گرافیک
   string m_buyLineName, m_sellLineName;  // نام خطوط شکست برای گرافیک
   datetime m_cleanupTime;  // زمان محاسبه‌شده پاکسازی (برای CheckCleanup)
   double m_initialSlDistance;  // فاصله SL اولیه (برای بازیابی وضعیت پس از ری‌استارت)

public:
   // سازنده: مقداردهی اولیه متغیرها به مقادیر پیش‌فرض برای ایمنی
   CRange() : m_rangeIndex(0), m_magic(0), m_timeframe(PERIOD_CURRENT), m_trendFilterTimeframe(PERIOD_CURRENT), 
              m_startHour(0), m_startMinute(0), m_endHour(0), m_endMinute(0), 
              m_minRangePoints(0), m_maxRangePoints(0), m_placementMode(PLACEMENT_ATR), m_atrPeriod(14), m_atrMultiplier(1.0), 
              m_slStrategy(SL_OPPOSITE_SIDE), m_slCalcMode(SL_CALC_ATR), m_slAtrPeriod(14), m_slAtrMultiplier(1.0), 
              m_trailingMode(TRAILING_ATR), m_trailingAtrPeriod(14), m_trailingAtrMultiplier(1.0), 
              m_rrRatio(1.5), m_partialClosePercent(50.0), m_cleanupHours(5), m_color(clrBlue), 
              m_atrHandle(INVALID_HANDLE), m_slAtrHandle(INVALID_HANDLE), m_trailingAtrHandle(INVALID_HANDLE), 
              m_rangeHigh(0), m_rangeLow(0), m_rangeStartTime(0), m_rangeEndTime(0), m_lastEndTime(0), m_lastInvalid(false), 
              m_potentialBuyPrice(0), m_potentialSellPrice(0), m_breakerCandleLevel(0), m_waitCounter(0), m_lastFilterBarTime(0), 
              m_currentState(RANGE_WAITING), m_activeTicket(0), m_partialClosed(false), m_slToBeMoved(false), 
              m_cachedATR(0), m_cachedSlATR(0), m_cachedTrailingATR(0), m_rangeObjectName(""), m_buyLineName(""), m_sellLineName(""), 
              m_cleanupTime(0), m_initialSlDistance(0) {}  // سازنده پیش‌فرض

   // دفع: آزادسازی هندل‌های ATR و حذف اشیاء گرافیکی
   void Deinit()  // تابع دفع رنج
   {
      if(m_slAtrHandle != INVALID_HANDLE) IndicatorRelease(m_slAtrHandle);  // آزادسازی هندل SL ATR
      if(m_trailingAtrHandle != INVALID_HANDLE) IndicatorRelease(m_trailingAtrHandle);  // آزادسازی هندل تریلینگ ATR
      ObjectDelete(0, m_rangeObjectName);  // حذف مستطیل رنج
      ObjectDelete(0, m_buyLineName);  // حذف خط خرید
      ObjectDelete(0, m_sellLineName);  // حذف خط فروش
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " دفع شد.", m_rangeIndex);  // چاپ دیباگ
   }

   // مقداردهی: تنظیم پارامترها، ایجاد هندل‌های ATR و نام اشیاء
   // این تابع در OnInit Elemento فراخوانی می‌شود
   bool Init(int index, long magic, ENUM_TIMEFRAMES timeframe, int startHour, int startMinute, int endHour, int endMinute, 
             int minRangePoints, int maxRangePoints, ENUM_PLACEMENT_MODE placementMode, int atrPeriod, double atrMultiplier, 
             ENUM_SL_STRATEGY slStrategy, ENUM_SL_CALC_MODE slCalcMode, int slAtrPeriod, double slAtrMultiplier, 
             ENUM_TRAILING_MODE trailingMode, int trailingAtrPeriod, double trailingAtrMultiplier, 
             double rrRatio, double partialClosePercent, int cleanupHours, color col, ENUM_TIMEFRAMES trendTf, int atrHandle)  // Init با پارامترها
   {
      m_rangeIndex = index;  // تنظیم ایندکس
      m_magic = magic;  // تنظیم مجیک
      m_timeframe = timeframe;  // تنظیم تایم‌فریم اجرا
      m_trendFilterTimeframe = trendTf;  // تنظیم تایم‌فریم فیلتر
      m_startHour = startHour; m_startMinute = startMinute;  // تنظیم شروع
      m_endHour = endHour; m_endMinute = endMinute;  // تنظیم پایان
      m_minRangePoints = minRangePoints; m_maxRangePoints = maxRangePoints;  // تنظیم حداقل/حداکثر
      m_placementMode = placementMode; m_atrPeriod = atrPeriod; m_atrMultiplier = atrMultiplier;  // تنظیم افست
      m_slStrategy = slStrategy; m_slCalcMode = slCalcMode; m_slAtrPeriod = slAtrPeriod; m_slAtrMultiplier = slAtrMultiplier;  // تنظیم SL
      m_trailingMode = trailingMode; m_trailingAtrPeriod = trailingAtrPeriod; m_trailingAtrMultiplier = trailingAtrMultiplier;  // تنظیم تریلینگ
      m_rrRatio = rrRatio; m_partialClosePercent = partialClosePercent;  // تنظیم خروج پله‌ای
      m_cleanupHours = cleanupHours;  // تنظیم پاکسازی
      m_color = col;  // تنظیم رنگ
      m_atrHandle = atrHandle;  // هندل ATR shared

      // ایجاد هندل‌های ATR اختصاصی برای SL و تریلینگ
      m_slAtrHandle = iATR(_Symbol, m_timeframe, m_slAtrPeriod);  // هندل SL ATR
      m_trailingAtrHandle = iATR(_Symbol, m_timeframe, m_trailingAtrPeriod);  // هندل تریلینگ ATR
      if(m_slAtrHandle == INVALID_HANDLE || m_trailingAtrHandle == INVALID_HANDLE)  // چک هندل‌ها
      {
         CLogger::Log("خطا در ایجاد هندل‌های ATR برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);  // چاپ خطا
         return false;  // بازگشت شکست
      }

      // تنظیم نام اشیاء گرافیکی منحصربه‌فرد
      m_rangeObjectName = "Range_" + IntegerToString(m_rangeIndex);  // نام مستطیل
      m_buyLineName = "BuyLine_" + IntegerToString(m_rangeIndex);  // نام خط خرید
      m_sellLineName = "SellLine_" + IntegerToString(m_rangeIndex);  // نام خط فروش

      m_currentState = RANGE_WAITING;  // حالت اولیه انتظار
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " مقداردهی شد.", m_rangeIndex);  // چاپ موفقیت
      return true;  // بازگشت موفقیت
   }

   // گرفتن تایم‌فریم اجرا (برای دسترسی خارجی مانند OnTick)
   ENUM_TIMEFRAMES GetTimeframe() const { return m_timeframe; }  // بازگشت تایم‌فریم اجرا

   // گرفتن تایم‌فریم فیلتر روند (برای فیلتر ایچیموکو)
   ENUM_TIMEFRAMES GetTrendFilterTimeframe() const { return m_trendFilterTimeframe; }  // بازگشت تایم‌فریم فیلتر

   // تنظیم تیکت فعال (برای بازیابی در OnInit)
   void SetActiveTicket(ulong ticket) { m_activeTicket = ticket; }  // تنظیم تیکت

   // تنظیم حالت فعلی (برای بازیابی یا کنترل خارجی)
   void SetCurrentState(ENUM_RANGE_STATE state) { m_currentState = state; }  // تنظیم حالت

   // گرفتن حالت فعلی (برای چک خارجی مانند OnTimer)
   ENUM_RANGE_STATE GetCurrentState() const { return m_currentState; }  // بازگشت حالت

   // تنظیم فلگ خروج پله‌ای (برای بازیابی)
   void SetPartialClosedFlag(bool flag) { m_partialClosed = flag; }  // تنظیم فلگ پله‌ای

   // (جدید) بازیابی وضعیت رنج (برای اصلاح باگ بازیابی ناقص پس از ری‌استارت)
   // این تابع سطوح رنج و فاصله SL اولیه را بازگردانی می‌کند
   void RestoreState(double range_high, double range_low, double initial_sl_distance)
   {
      m_rangeHigh = range_high;  // بازگردانی High
      m_rangeLow = range_low;  // بازگردانی Low
      m_initialSlDistance = initial_sl_distance;  // بازگردانی فاصله SL اولیه
      CLogger::Log("وضعیت رنج " + IntegerToString(m_rangeIndex) + " با موفقیت بازیابی شد.", m_rangeIndex);  // لاگ موفقیت
   }

   // به‌روزرسانی ماشین حالت در کندل جدید: چک زمان، شناسایی رنج، شکست، تایید و غیره
   // این تابع قلب ماشین حالت است
   void UpdateOnNewBar()  // به‌روزرسانی در کندل جدید
   {
      // چک پاکسازی ابتدا (برای انقضا)
      CheckCleanup();  // چک و پاکسازی اگر زمان رسیده

      // محاسبه زمان رنج فعلی (با مدیریت DST و روزهای غیر معاملاتی)
      if(!CTimeHelper::CalculateRangeTimes(m_startHour, m_startMinute, m_endHour, m_endMinute, m_rangeStartTime, m_rangeEndTime))  // محاسبه زمان
      {
         CLogger::Log("خطا در محاسبه زمان رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);  // چاپ خطا
         return;  // خروج
      }

      // چک اگر رنج فعلی قبلاً پردازش شده (برای جلوگیری از تکرار)
      if(m_rangeEndTime == m_lastEndTime)  // چک پایان قبلی
      {
         return;  // خروج اگر تکراری
      }

      datetime now = TimeCurrent();  // زمان فعلی
      switch(m_currentState)  // سوئیچ ماشین حالت
      {
         case RANGE_WAITING:  // انتظار شناسایی
            if(now >= m_rangeStartTime && now < m_rangeEndTime)  // چک داخل رنج
            {
               if(IdentifyRange())  // شناسایی رنج
               {
                  m_currentState = RANGE_IDENTIFIED;  // تغییر به شناسایی شده
                  DrawRangeRectangle();  // رسم مستطیل
               }
            }
            break;

         case RANGE_IDENTIFIED:  // شناسایی شده، منتظر شکست
            if(now >= m_rangeEndTime)  // چک پایان رنج
            {
               m_currentState = AWAITING_BREAKOUT;  // تغییر به انتظار شکست
               m_cleanupTime = CTimeHelper::CalculateCleanupTime(m_rangeEndTime, m_cleanupHours);  // محاسبه پاکسازی
               CalculatePlacementLines();  // محاسبه و رسم سطوح شکست
            }
            else  // هنوز داخل رنج
            {
               UpdateRangeLevels();  // به‌روزرسانی High/Low اگر لازم
            }
            break;

         case AWAITING_BREAKOUT:  // انتظار شکست
            if(CheckBreakout())  // چک شکست
            {
               m_currentState = AWAITING_CONFIRMATION;  // تغییر به انتظار تایید
               m_waitCounter = 0;  // ریست شمارنده
               m_breakerCandleLevel = GetBreakerLevel();  // سطح بریک
            }
            break;

         case AWAITING_CONFIRMATION:  // انتظار تایید
            if(ConfirmPriceAndFilter())  // تایید قیمت و فیلتر
            {
               if(ExecuteTrade())  // ورود معامله
               {
                  m_currentState = MANAGING_TRADE;  // تغییر به مدیریت
               }
               else  // ورود شکست
               {
                  m_currentState = RANGE_EXPIRED;  // به منقضی
               }
            }
            else if(CheckInvalidation())  // چک ابطال
            {
               m_currentState = RANGE_EXPIRED;  // به منقضی
            }
            break;

         case MANAGING_TRADE:  // مدیریت معامله
            // مدیریت در OnTimer انجام می‌شود
            break;

         case RANGE_EXPIRED:  // منقضی، منتظر پاکسازی
            // پاکسازی در CheckCleanup مدیریت می‌شود
            break;
      }
   }

   // شناسایی رنج: پیدا کردن High/Low در بازه زمانی و چک حداقل/حداکثر
   // iHighest/iLowest ایندکس‌ها را پیدا می‌کنند
   bool IdentifyRange()  // شناسایی رنج
   {
      int startIdx = iBarShift(_Symbol, m_timeframe, m_rangeStartTime);  // ایندکس شروع
      int endIdx = iBarShift(_Symbol, m_timeframe, m_rangeEndTime);  // ایندکس پایان
      if(startIdx == -1 || endIdx == -1)  // چک ایندکس معتبر
      {
         CLogger::Log("خطا در پیدا کردن ایندکس بارها برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);  // چاپ خطا
         return false;  // شکست
      }

      int highIdx = iHighest(_Symbol, m_timeframe, MODE_HIGH, startIdx - endIdx + 1, endIdx);  // ایندکس سقف
      int lowIdx = iLowest(_Symbol, m_timeframe, MODE_LOW, startIdx - endIdx + 1, endIdx);  // ایندکس کف
      m_rangeHigh = iHigh(_Symbol, m_timeframe, highIdx);  // سقف
      m_rangeLow = iLow(_Symbol, m_timeframe, lowIdx);  // کف

      double rangeHeight = (m_rangeHigh - m_rangeLow) / _Point;  // ارتفاع به پوینت
      if(rangeHeight < m_minRangePoints || rangeHeight > m_maxRangePoints)  // چک محدوده
      {
         if(!m_lastInvalid)  // جلوگیری از لاگ تکراری
         {
            CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " نامعتبر: ارتفاع=" + DoubleToString(rangeHeight, 0) + " پوینت", m_rangeIndex);  // لاگ نامعتبر
            m_lastInvalid = true;  // تنظیم فلگ
         }
         return false;  // شکست
      }

      m_lastInvalid = false;  // ریست فلگ
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " شناسایی شد: High=" + DoubleToString(m_rangeHigh, _Digits) + ", Low=" + DoubleToString(m_rangeLow, _Digits), m_rangeIndex);  // لاگ موفقیت
      return true;  // موفقیت
   }

   // به‌روزرسانی سطوح رنج: چک کندل جدید برای به‌روزرسانی High/Low داخل رنج
   void UpdateRangeLevels()  // به‌روزرسانی سطوح
   {
      double currentHigh = iHigh(_Symbol, m_timeframe, 1);  // های کندل قبلی
      double currentLow = iLow(_Symbol, m_timeframe, 1);  // لو کندل قبلی
      if(currentHigh > m_rangeHigh) m_rangeHigh = currentHigh;  // به‌روزرسانی سقف
      if(currentLow < m_rangeLow) m_rangeLow = currentLow;  // به‌روزرسانی کف
      DrawRangeRectangle();  // بازرسم مستطیل
   }

   // رسم مستطیل رنج: نمایش گرافیکی رنج با ObjectCreate
   void DrawRangeRectangle()  // رسم مستطیل
   {
      ObjectCreate(0, m_rangeObjectName, OBJ_RECTANGLE, 0, m_rangeStartTime, m_rangeHigh, m_rangeEndTime, m_rangeLow);  // ایجاد مستطیل
      ObjectSetInteger(0, m_rangeObjectName, OBJPROP_COLOR, m_color);  // رنگ
      ObjectSetInteger(0, m_rangeObjectName, OBJPROP_STYLE, STYLE_SOLID);  // استایل
      ObjectSetInteger(0, m_rangeObjectName, OBJPROP_FILL, true);  // پر کردن
      ChartRedraw();  // redraw چارت
   }

   // محاسبه سطوح شکست: افست بر اساس ATR یا درصد و رسم خطوط
   void CalculatePlacementLines()  // محاسبه سطوح شکست
   {
      double offset = CalculatePlacementOffset();  // محاسبه افست
      if(offset <= 0) return;  // خروج اگر نامعتبر

      m_potentialBuyPrice = m_rangeHigh + offset;  // سطح خرید
      m_potentialSellPrice = m_rangeLow - offset;  // سطح فروش

      // رسم خطوط افقی برای سطوح شکست
      ObjectCreate(0, m_buyLineName, OBJ_HLINE, 0, 0, m_potentialBuyPrice);  // خط خرید
      ObjectSetInteger(0, m_buyLineName, OBJPROP_COLOR, clrGreen);  // رنگ سبز
      ObjectCreate(0, m_sellLineName, OBJ_HLINE, 0, 0, m_potentialSellPrice);  // خط فروش
      ObjectSetInteger(0, m_sellLineName, OBJPROP_COLOR, clrRed);  // رنگ قرمز
      ChartRedraw();  // redraw
      CLogger::Log("سطوح شکست برای رنج " + IntegerToString(m_rangeIndex) + " محاسبه شد: Buy=" + DoubleToString(m_potentialBuyPrice, _Digits) + ", Sell=" + DoubleToString(m_potentialSellPrice, _Digits), m_rangeIndex);  // لاگ
   }

   // محاسبه افست شکست: بر اساس حالت (ATR یا درصد ارتفاع رنج)
   double CalculatePlacementOffset()  // محاسبه افست
   {
      if(m_placementMode == PLACEMENT_ATR)  // حالت ATR
      {
         double atr = GetCachedATR();  // ATR کش‌شده
         return atr * m_atrMultiplier;  // افست
      }
      else  // حالت درصد
      {
         double rangeHeight = m_rangeHigh - m_rangeLow;  // ارتفاع
         return rangeHeight * (m_atrMultiplier / 100.0);  // افست درصد (توجه: atrMultiplier به عنوان درصد استفاده می‌شود)
      }
   }

   // چک شکست: بررسی قیمت فعلی برای عبور از سطوح شکست
   bool CheckBreakout()  // چک شکست
   {
      double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);  // قیمت Bid
      double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);  // قیمت Ask

      if(bid > m_potentialBuyPrice)  // شکست خرید
      {
         DeactivateSellPath();  // غیرفعال فروش (OCO)
         CLogger::Log("شکست خرید شناسایی شد برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);  // لاگ
         return true;  // موفقیت
      }
      else if(ask < m_potentialSellPrice)  // شکست فروش
      {
         DeactivateBuyPath();  // غیرفعال خرید (OCO)
         CLogger::Log("شکست فروش شناسایی شد برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);  // لاگ
         return true;  // موفقیت
      }
      return false;  // بدون شکست
   }

   // گرفتن سطح کندل شکننده: برای تایید قیمت (های/لو کندل قبلی)
   double GetBreakerLevel()  // سطح بریک
   {
      if(m_potentialBuyPrice > 0)  // خرید
         return iHigh(_Symbol, m_timeframe, 1);  // های قبلی
      else  // فروش
         return iLow(_Symbol, m_timeframe, 1);  // لو قبلی
   }

   // تایید قیمت و فیلتر روند: چک بسته شدن بالای/پایین سطح بریک و هم‌جهت بودن روند
   bool ConfirmPriceAndFilter()  // تایید
   {
      if(!Inp_PriceConfirmation_Enabled)  // اگر تایید خاموش
         return CheckTrendFilter();  // مستقیم به فیلتر

      double close = iClose(_Symbol, m_timeframe, 1);  // کلوز قبلی
      if(m_potentialBuyPrice > 0 && close > m_breakerCandleLevel)  // تایید خرید
         return CheckTrendFilter();  // به فیلتر
      else if(m_potentialSellPrice > 0 && close < m_breakerCandleLevel)  // تایید فروش
         return CheckTrendFilter();  // به فیلتر

      if(Inp_Confirmation_Strategy == CONFIRMATION_TIMEOUT)  // حالت تایمر
      {
         m_waitCounter++;  // افزایش شمارنده
         if(m_waitCounter > Inp_Confirmation_Timeout)  // تایم‌اوت
         {
            CLogger::Log("تایم‌اوت تایید برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);  // لاگ
            return false;  // شکست
         }
      }
      return false;  // بدون تایید
   }

   // چک فیلتر روند: اگر فیلتر فعال، چک جهت یا خنثی
   bool CheckTrendFilter()  // فیلتر روند
   {
      if(!Inp_IchimokuFilter_Enabled) return true;  // اگر خاموش، مجاز

      datetime currentBarTime = iTime(_Symbol, m_trendFilterTimeframe, 0);  // زمان بار فیلتر
      if(currentBarTime == m_lastFilterBarTime) return false;  // جلوگیری از چک تکراری
      m_lastFilterBarTime = currentBarTime;  // ذخیره زمان

      ENUM_TREND_DIRECTION trend = g_trendFilter.GetTrendDirection(m_trendFilterTimeframe);  // جهت
      if(m_potentialBuyPrice > 0)  // خرید
         return (trend == TREND_BUY || trend == TREND_NEUTRAL);  // مجاز اگر خرید یا خنثی
      else if(m_potentialSellPrice > 0)  // فروش
         return (trend == TREND_SELL || trend == TREND_NEUTRAL);  // مجاز اگر فروش یا خنثی

      CLogger::Log("فیلتر روند رد کرد برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);  // لاگ رد
      return false;  // رد
   }

   // چک ابطال: بر اساس استراتژی (بازگشت به رنج یا عبور از خط شکست)
   bool CheckInvalidation()  // ابطال
   {
      double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);  // Bid
      double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);  // Ask

      if(Inp_Invalidation_Mode == INVALIDATION_RANGE_REENTRY)  // حالت صبور
      {
         if(m_potentialBuyPrice > 0 && bid < m_rangeHigh) return true;  // بازگشت به رنج خرید
         if(m_potentialSellPrice > 0 && ask > m_rangeLow) return true;  // بازگشت به رنج فروش
      }
      else  // حالت تهاجمی
      {
         if(m_potentialBuyPrice > 0 && bid < m_potentialBuyPrice) return true;  // عبور از خط خرید
         if(m_potentialSellPrice > 0 && ask > m_potentialSellPrice) return true;  // عبور از خط فروش
      }
      return false;  // بدون ابطال
   }

   // ورود معامله: محاسبه حجم، SL و ارسال معامله
   bool ExecuteTrade()  // ورود
   {
      ENUM_POSITION_TYPE tradeType = m_potentialBuyPrice > 0 ? POSITION_TYPE_BUY : POSITION_TYPE_SELL;  // نوع معامله
      double entryPrice = tradeType == POSITION_TYPE_BUY ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);  // قیمت ورود
      double sl = CalculateSL(tradeType, entryPrice);  // محاسبه SL
      double slDistance = MathAbs(entryPrice - sl);  // فاصله SL
      m_initialSlDistance = slDistance;  // ذخیره فاصله اولیه برای بازیابی
      double lotSize = CRiskManager::CalculateLotSize(InpRiskPercent, slDistance);  // حجم بر اساس ریسک
      if(lotSize <= 0) return false;  // خروج اگر حجم نامعتبر

      CTrade trade;  // نمونه معامله
      trade.SetExpertMagicNumber(m_magic);  // تنظیم مجیک

      string trade_comment = StringFormat("R%d;H:%.5f;L:%.5f;SLD:%.5f", 
                                          m_rangeIndex, m_rangeHigh, m_rangeLow, m_initialSlDistance);  // کامنت با اطلاعات برای بازیابی

      if(tradeType == POSITION_TYPE_BUY)  // خرید
      {
         if(!trade.PositionOpen(_Symbol, ORDER_TYPE_BUY, lotSize, 0, sl, 0, trade_comment))  // باز کردن خرید
         {
            CLogger::Log("خطا در باز کردن خرید برای رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(trade.ResultRetcode()), m_rangeIndex);  // لاگ خطا
            return false;  // شکست
         }
      }
      else  // فروش
      {
         if(!trade.PositionOpen(_Symbol, ORDER_TYPE_SELL, lotSize, 0, sl, 0, trade_comment))  // باز کردن فروش
         {
            CLogger::Log("خطا در باز کردن فروش برای رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(trade.ResultRetcode()), m_rangeIndex);  // لاگ خطا
            return false;  // شکست
         }
      }

      m_activeTicket = trade.ResultDeal();  // ذخیره تیکت (توجه: در MT5 تیکت POSITION_TICKET است)
      m_slToBeMoved = false;  // ریست فلگ SL
      m_partialClosed = false;  // ریست فلگ پله‌ای
      CLogger::Log("معامله باز شد برای رنج " + IntegerToString(m_rangeIndex) + ". تیکت: " + (string)m_activeTicket, m_rangeIndex);  // لاگ موفقیت
      return true;  // موفقیت
   }

   // محاسبه SL: بر اساس استراتژی و حالت بافر
   double CalculateSL(ENUM_POSITION_TYPE type, double entry)  // محاسبه SL
   {
      double baseSL = (type == POSITION_TYPE_BUY) ? 
                      (m_slStrategy == SL_OPPOSITE_SIDE ? m_rangeLow : m_rangeHigh) : 
                      (m_slStrategy == SL_OPPOSITE_SIDE ? m_rangeHigh : m_rangeLow);  // پایه SL

      double buffer = (m_slCalcMode == SL_CALC_ATR) ? GetSlATR() * m_slAtrMultiplier : (m_rangeHigh - m_rangeLow) * (m_slAtrMultiplier / 100.0);  // بافر

      return (type == POSITION_TYPE_BUY) ? NormalizeDouble(baseSL - buffer, _Digits) : NormalizeDouble(baseSL + buffer, _Digits);  // SL نهایی
   }

   // غیرفعال کردن مسیر فروش (OCO): ریست قیمت و حذف خط
   void DeactivateSellPath()  // غیرفعال فروش
   {
      m_potentialSellPrice = 0;  // ریست قیمت فروش
      ObjectDelete(0, m_sellLineName);  // حذف خط فروش
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " - SELL path deactivated (OCO).", m_rangeIndex);  // لاگ
   }

   // غیرفعال کردن مسیر خرید (OCO): ریست قیمت و حذف خط
   void DeactivateBuyPath()  // غیرفعال خرید
   {
      m_potentialBuyPrice = 0;  // ریست قیمت خرید
      ObjectDelete(0, m_buyLineName);  // حذف خط خرید
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " - BUY path deactivated (OCO).", m_rangeIndex);  // لاگ
   }

   // مدیریت معامله فعال: چک سود برای خروج پله‌ای، انتقال SL به ورود و اعمال تریلینگ (فقط اگر پله‌ای انجام شده)
   // تغییرات نسخه 2.00: محاسبه سود بر اساس قیمت، بافر در ریسک-فری، اجرای مرحله‌ای با return
   // تغییرات نسخه 2.1: اصلاح Race Condition با ریست m_slToBeMoved حتی در شکست، استفاده از m_initialSlDistance برای riskDistance
   void ManageActiveTrade()  // مدیریت معامله
   {
      if(!PositionSelectByTicket(m_activeTicket))  // چک انتخاب پوزیشن
      {
         CLogger::Log("پوزیشن با تیکت " + (string)m_activeTicket + " بسته شده یا یافت نشد. ریست رنج.", m_rangeIndex);  // لاگ بسته شدن
         m_activeTicket = 0;  // ریست تیکت
         m_partialClosed = false;  // ریست فلگ پله‌ای
         m_slToBeMoved = false;  // ریست فلگ SL
         SoftCleanup();  // ریست فوری با منطق جدید (اصلاح بلوپرینت)
         return;  // خروج
      }

      // --- محاسبات اولیه ---
      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);  // نوع پوزیشن
      double entryPrice = PositionGetDouble(POSITION_PRICE_OPEN);  // قیمت ورود
      double sl = PositionGetDouble(POSITION_SL);  // SL فعلی
      // قیمت فعلی بر اساس نوع
      double currentPrice = (posType == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);  // قیمت فعلی

      // --- مرحله 1: چک خروج پله‌ای ---
      if(!m_partialClosed)  // چک فلگ پله‌ای
      {
         // محاسبه صحیح سود بر اساس حرکت قیمت (نه دلار، برای دقت)
         double currentProfitInPrice = (posType == POSITION_TYPE_BUY) ? (currentPrice - entryPrice) : (entryPrice - currentPrice);  // محاسبه سود
         if(m_initialSlDistance == 0) return;  // جلوگیری از خطای تقسیم بر صفر (اصلاح بازیابی)
         double targetProfitInPrice = m_initialSlDistance * m_rrRatio;  // سود هدف برای پله‌ای

         if(currentProfitInPrice >= targetProfitInPrice)  // چک رسیدن به RR
         {
            double volume = PositionGetDouble(POSITION_VOLUME);  // حجم فعلی
            double closeVolume = MathFloor((volume * m_partialClosePercent / 100.0) / g_volumeStep) * g_volumeStep;  // حجم پله‌ای راند پایین
            
            if(closeVolume >= g_volumeMin && closeVolume < volume)  // چک حجم معتبر
            {
               CLogger::Log("رسیدن به RR. تلاش برای خروج پله‌ای با حجم " + DoubleToString(closeVolume, 2), m_rangeIndex);  // لاگ تلاش
               if(CTradeManager::PartialClose(m_activeTicket, closeVolume))  // بستن پله‌ای
               {
                  m_partialClosed = true;  // تنظیم فلگ
                  m_slToBeMoved = true;  // تنظیم فلگ برای انتقال SL
               }
               return;  // خروج برای اجرای مرحله بعدی در تیک بعدی تایمر
            }
         }
      }

      // --- مرحله 2: انتقال SL به نقطه ورود (ریسک-فری) ---
      if(m_partialClosed && m_slToBeMoved)  // چک فلگ‌ها
      {
         // اضافه کردن بافر برای پوشش هزینه‌ها و جلوگیری از خطای Invalid Stops
         double breakEvenBuffer = _Point * 3;  // بافر 3 پوینتی (قابل تنظیم)
         double newSL = (posType == POSITION_TYPE_BUY) ? entryPrice + breakEvenBuffer : entryPrice - breakEvenBuffer;  // SL جدید با بافر
         
         CLogger::Log("تلاش برای ریسک-فری کردن معامله. SL جدید: " + DoubleToString(newSL, _Digits), m_rangeIndex);  // لاگ تلاش
         if(!CTradeManager::MoveSLToBreakEven(m_activeTicket, newSL))  // انتقال به ورود با بافر (اگر شکست)
         {
            CLogger::Log("انتقال SL به نقطه ورود ناموفق بود. ادامه به مرحله تریلینگ...", m_rangeIndex);  // لاگ شکست (اصلاح Race Condition)
         }
         m_slToBeMoved = false;  // فلگ را در هر صورت ریست کن (اصلاح Race Condition)
         return;  // خروج برای اجرای مرحله بعدی در تیک بعدی تایمر
      }

      // --- مرحله 3: فعال‌سازی تریلینگ استاپ ---
      if(m_partialClosed && !m_slToBeMoved)  // چک پس از پله‌ای و BE
      {
         // فراخوانی تریلینگ با تمام پارامترها
         CTradeManager::TrailingStop(m_activeTicket, m_trailingMode, m_trailingAtrPeriod, m_trailingAtrMultiplier, m_timeframe, m_trailingAtrHandle, m_trendFilterTimeframe);  // تریلینگ
      }
   }

   // پاکسازی نرم: ریست متغیرها و حذف اشیاء بدون بستن معامله برای آماده‌سازی رنج بعدی
   // این تابع برای ریست روزانه بدون بستن معامله است
   // تغییرات نسخه 2.1: ادغام منطق CleanupPaths، ریست m_lastEndTime برای حل قفل شدن، شرطی برای حفظ حالت MANAGING_TRADE
   void SoftCleanup()  // تابع پاکسازی نرم
   {
      CLogger::Log("پاکسازی نرم رنج " + IntegerToString(m_rangeIndex) + "...", m_rangeIndex);  // لاگ شروع

      // ۱. پاکسازی متغیرهای مربوط به تلاش برای ورود
      m_potentialBuyPrice = 0;
      m_potentialSellPrice = 0;
      m_breakerCandleLevel = 0;
      m_waitCounter = 0;

      // ۲. حذف تمام اشیاء گرافیکی مربوط به رنج
      ObjectDelete(0, m_buyLineName);
      ObjectDelete(0, m_sellLineName);
      ObjectDelete(0, m_rangeObjectName);

      // ۳. ریست کردن متغیرهای کنترلی برای شناسایی رنج بعدی
      m_lastEndTime = 0; // << بسیار مهم: این خط باگ اصلی قفل شدن را حل می‌کند
      m_lastInvalid = false;

      // ۴. ریست کردن کش‌ها
      ResetCaches();

      // ۵. اگر معامله‌ای در حال مدیریت نیست، حالت را به انتظار برگردان
      if(m_currentState != MANAGING_TRADE)
      {
         m_currentState = RANGE_WAITING;
      }

      m_cleanupTime = 0; // ساعت پاکسازی را صفر کن تا این فرآیند تکرار نشود
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " پاکسازی نرم شد.", m_rangeIndex);  // لاگ موفقیت
   }

   // پاکسازی سخت: بستن معامله اگر باز باشد و سپس پاکسازی نرم (برای تعطیلات یا دفع)
   // تغییرات 2.00: ریست دستی فلگ‌ها قبل از SoftCleanup
   void HardCleanup()  // تابع پاکسازی سخت
   {
      CLogger::Log("پاکسازی سخت رنج " + IntegerToString(m_rangeIndex) + "...", m_rangeIndex);  // لاگ شروع

      if(m_activeTicket != 0)  // چک معامله باز
      {
         if(CTradeManager::ClosePosition(m_activeTicket))  // بستن کامل معامله
         {
            CLogger::Log("معامله با تیکت " + (string)m_activeTicket + " بسته شد (سخت).", m_rangeIndex);  // لاگ موفقیت
         }
         // ریست کردن متغیرهای مربوط به معامله باز قبل از SoftCleanup
         m_activeTicket = 0;  // ریست تیکت پس از بستن
         m_partialClosed = false;  // ریست فلگ پله‌ای
         m_slToBeMoved = false;  // ریست فلگ SL
      }

      SoftCleanup();  // فراخوانی پاکسازی نرم پس از بستن و ریست متغیرها
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " پاکسازی سخت شد.", m_rangeIndex);  // لاگ موفقیت
   }

   // چک پاکسازی: چک زمان انقضا و فراخوانی پاکسازی مناسب بر اساس حالت (با معامله: فقط مسیرها، بدون: نرم)
   // این تابع در OnTimer و OnTick فراخوانی می‌شود
   // تغییرات نسخه 2.1: ساده‌سازی به فراخوانی SoftCleanup() (چون هوشمند شده)
   void CheckCleanup()  // تابع چک پاکسازی
   {
      // اگر زمان پاکسازی نرسیده یا قبلاً انجام شده، خارج شو
      if(m_cleanupTime == 0 || TimeCurrent() < m_cleanupTime) return;

      CLogger::Log("زمان پاکسازی فرا رسید...", m_rangeIndex);  // لاگ رسیدن زمان
      SoftCleanup(); // << فقط تابع هوشمند جدید را فراخوانی کن
   }

   // ریست کش‌ها: صفر کردن کش ATRها برای رنج جدید (برای جلوگیری از استفاده از داده‌های کهنه)
   // این تابع کش‌ها را صفر می‌کند
   void ResetCaches()  // تابع ریست کش
   {
      m_cachedATR = 0;  // ریست کش ATR افست
      m_cachedSlATR = 0;  // ریست کش ATR SL
      m_cachedTrailingATR = 0;  // ریست کش ATR تریلینگ
      CLogger::Log("کش‌های ATR برای رنج " + IntegerToString(m_rangeIndex) + " ریست شدند.", m_rangeIndex);  // لاگ ریست
   }

   // گرفتن ATR کش‌شده اصلی: اگر کش خالی باشد، از هندل کپی می‌گیرد (فقط برای ورود استفاده شود)
   // CopyBuffer بافر را کپی می‌کند
   double GetCachedATR()  // تابع گرفتن ATR
   {
      if(m_cachedATR <= 0)  // چک کش خالی
      {
         double atr[];  // آرایه ATR (دینامیک بدون اندازه ثابت)
         ArraySetAsSeries(atr, true);  // تنظیم سری
         if(CopyBuffer(m_atrHandle, 0, 1, 1, atr) <= 0)  // کپی بافر
         {
            CLogger::Log("خطا در گرفتن ATR برای رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(GetLastError()), m_rangeIndex);  // لاگ خطا
            return 0;  // بازگشت صفر
         }
         m_cachedATR = atr[0];  // ذخیره در کش
      }
      return m_cachedATR;  // بازگشت کش
   }

   // گرفتن ATR کش‌شده برای SL: مشابه برای بهینه‌سازی محاسبات SL (فقط برای ورود استفاده شود)
   double GetSlATR()  // تابع گرفتن SL ATR
   {
      if(m_cachedSlATR <= 0)  // چک کش خالی
      {
         double atr[];  // آرایه ATR (دینامیک بدون اندازه ثابت)
         ArraySetAsSeries(atr, true);  // تنظیم سری
         if(CopyBuffer(m_slAtrHandle, 0, 1, 1, atr) <= 0)  // کپی بافر
         {
            CLogger::Log("خطا در گرفتن ATR برای SL رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(GetLastError()), m_rangeIndex);  // لاگ خطا
            return 0;  // بازگشت صفر
         }
         m_cachedSlATR = atr[0];  // ذخیره در کش
      }
      return m_cachedSlATR;  // بازگشت کش
   }

   // گرفتن ATR کش‌شده برای تریلینگ: مشابه برای بهینه‌سازی تریلینگ (فقط برای ورود استفاده شود، برای مدیریت پویا استفاده نشود)
   double GetTrailingATR()  // تابع گرفتن تریلینگ ATR
   {
      if(m_cachedTrailingATR <= 0)  // چک کش خالی
      {
         double atr[];  // آرایه ATR (دینامیک بدون اندازه ثابت)
         ArraySetAsSeries(atr, true);  // تنظیم سری
         if(CopyBuffer(m_trailingAtrHandle, 0, 1, 1, atr) <= 0)  // کپی بافر
         {
            CLogger::Log("خطا در گرفتن ATR برای تریلینگ رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(GetLastError()), m_rangeIndex);  // لاگ خطا
            return 0;  // بازگشت صفر
         }
         m_cachedTrailingATR = atr[0];  // ذخیره در کش
      }
      return m_cachedTrailingATR;  // بازگشت کش
   }
};

#endif  // پایان چک include
```

```mql5
//+------------------------------------------------------------------+
//|                                                     TradeManager.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CTradeManager را تعریف می‌کند که عملیات معاملاتی پیشرفته را مدیریت می‌کند.
// استراتژی کلی اکسپرت: این کلاس بخشی از مدیریت معامله در استراتژی شکست رنج است، 
// جایی که پس از باز شدن معامله، خروج پله‌ای (هنگام رسیدن به RR)، انتقال SL به ورود (برای حفظ سرمایه)، 
// تریلینگ (برای قفل سود) و بستن کامل (در پاکسازی سخت) انجام می‌شود. 
// این عملیات ریسک را کنترل و سود را به حداکثر می‌رساند.
// منطق فایل TradeManager.mqh: کلاس شامل متدهای استاتیک برای بستن جزئی (PartialClose با چک حجم مجاز)، 
// انتقال SL به بریک‌اون (MoveSLToBreakEven با نرمالایز قیمت)، 
// تریلینگ استاپ (TrailingStop با محاسبه فاصله ATR یا Senkou Span B و چک حداقل تغییر برای جلوگیری از به‌روزرسانی‌های بیهوده)، 
// و بستن کامل (ClosePosition). 
// تمام متدها PositionSelectByTicket را چک می‌کنند و از CTrade برای ارسال درخواست استفاده می‌کنند. 
// این فایل توسط CRange برای مدیریت معاملات در ManageActiveTrade فراخوانی می‌شود و هیچ وابستگی خارجی ندارد جز Trade.mqh. 
// تغییرات جدید: اضافه منطق TRAILING_ICHIMOKU_B در TrailingStop با استفاده از GetSenkouSpanB و بافر ثابت (10 * _Point). 
// همچنین تغییر PartialClose به روش بستن مخالف برای سازگاری با بروکرها.
// تغییرات نسخه 2.00: جایگزینی Print با CLogger::Log، کامنت‌گذاری دقیق هر خط، بدون تغییر در منطق.
// تغییرات نسخه 2.1: هیچ تغییری لازم نبود، اما کامنت‌ها برای سازگاری به‌روزرسانی شد.

#ifndef TRADE_MANAGER_MQH  // چک وجود
#define TRADE_MANAGER_MQH  // تعریف ماکرو

#include <Trade\Trade.mqh>  // کلاس معامله برای عملیات

// کلاس CTradeManager برای عملیات معاملاتی استاتیک (بدون نیاز به نمونه‌سازی)
// تمام متدها استاتیک هستند برای سادگی فراخوانی
class CTradeManager  // کلاس مدیریت معامله
{
public:
   // بستن جزئی پوزیشن: محاسبه و بستن حجم مشخص با چک اضافی Magic برای امنیت
   // این متد با معامله مخالف جزئی می‌بندد
   static bool PartialClose(ulong ticket, double volume)  // بستن جزئی با تیکت و حجم
   {
      if(!PositionSelectByTicket(ticket))  // چک انتخاب پوزیشن
      {
         CLogger::Log("خطا: پوزیشن با تیکت " + (string)ticket + " برای بستن جزئی یافت نشد.");  // لاگ خطا
         return false;  // بازگشت شکست
      }

      // گرفتن اطلاعات ضروری از پوزیشن اصلی
      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);  // نوع پوزیشن
      string symbolName = PositionGetString(POSITION_SYMBOL);  // نماد

      // آماده کردن درخواست معامله جدید (مخالف پوزیشن اصلی)
      CTrade trade;  // نمونه کلاس معامله
      MqlTradeRequest request;  // درخواست معامله
      MqlTradeResult result;  // نتیجه معامله
      ZeroMemory(request);  // صفر کردن درخواست
      ZeroMemory(result);  // صفر کردن نتیجه

      request.action   = TRADE_ACTION_DEAL;              // نوع عملیات: معامله
      request.symbol   = symbolName;                     // نماد معامله
      request.volume   = volume;                         // حجمی که می‌خواهیم ببندیم
      request.deviation = 10;                            // انحراف مجاز قیمت
      request.magic    = (long)PositionGetInteger(POSITION_MAGIC); // مجیک نامبر باید یکی باشه

      // لینک کردن این درخواست به پوزیشن باز موجود
      request.position = ticket; // لینک به پوزیشن برای بستن جزئی

      // تعیین نوع معامله مخالف
      if(posType == POSITION_TYPE_BUY)  // اگر پوزیشن خرید، برای بستن جزئی فروش می‌زنیم
      {
         request.price = SymbolInfoDouble(symbolName, SYMBOL_BID);  // برای بستن خرید، با قیمت BID می‌فروشیم
         request.type = ORDER_TYPE_SELL;  // نوع فروش
      }
      else  // اگر پوزیشن فروش، برای بستن جزئی خرید می‌زنیم
      {
         request.price = SymbolInfoDouble(symbolName, SYMBOL_ASK);  // برای بستن فروش، با قیمت ASK می‌خریم
         request.type = ORDER_TYPE_BUY;  // نوع خرید
      }

      // ارسال درخواست و بررسی نتیجه
      if(trade.OrderSend(request, result))  // ارسال درخواست معامله مخالف
      {
         if(result.retcode == TRADE_RETCODE_DONE || result.retcode == TRADE_RETCODE_PLACED)  // چک موفقیت
         {
            if(InpDebugMode) CLogger::Log("بخشی از پوزیشن با تیکت " + (string)ticket + " (حجم " + DoubleToString(volume, 2) + ") با موفقیت بسته شد.");  // لاگ موفقیت
            return true;  // بازگشت موفقیت
         }
      }

      CLogger::Log("خطا در بستن بخشی از پوزیشن با تیکت " + (string)ticket + ": " + IntegerToString(result.retcode) + " - " + result.comment);  // لاگ خطا
      return false;  // بازگشت شکست
   }

   // انتقال SL به بریک‌اون: نرمالایز قیمت و تغییر SL به نقطه ورود
   // NormalizeDouble قیمت را نرمال می‌کند
   static bool MoveSLToBreakEven(ulong ticket, double breakEvenPrice)  // انتقال SL به ورود
   {
      if(!PositionSelectByTicket(ticket))  // چک انتخاب پوزیشن
      {
         CLogger::Log("خطا: پوزیشن با تیکت " + (string)ticket + " یافت نشد.");  // لاگ خطا
         return false;  // بازگشت شکست
      }

      CTrade trade;  // نمونه کلاس معامله
      breakEvenPrice = NormalizeDouble(breakEvenPrice, _Digits);  // نرمالایز قیمت
      if(trade.PositionModify(ticket, breakEvenPrice, PositionGetDouble(POSITION_TP)))  // تغییر SL
      {
         CLogger::Log("استاپ لاس پوزیشن " + (string)ticket + " به نقطه ورود منتقل شد.");  // لاگ موفقیت
         return true;  // بازگشت موفقیت
      }
      else  // شرط شکست
      {
         CLogger::Log("خطا در انتقال استاپ لاس پوزیشن " + (string)ticket + ": " + IntegerToString(trade.ResultRetcode()));  // لاگ خطا
         return false;  // بازگشت شکست
      }
   }

   // اعمال تریلینگ استاپ: محاسبه فاصله جدید، چک حداقل تغییر و تغییر SL (محاسبه پویا ATR یا Senkou Span B هر بار)
   // این متد پویا محاسبه می‌کند
   static bool TrailingStop(ulong ticket, ENUM_TRAILING_MODE mode, int atrPeriod, double atrMultiplier, ENUM_TIMEFRAMES timeframe, int atrHandle, ENUM_TIMEFRAMES trendTf)  // تریلینگ با پارامترها و تایم‌فریم فیلتر
   {
      if(!PositionSelectByTicket(ticket))  // چک انتخاب پوزیشن
      {
         CLogger::Log("خطا: پوزیشن با تیکت " + (string)ticket + " یافت نشد.");  // لاگ خطا
         return false;  // بازگشت شکست
      }

      double sl = PositionGetDouble(POSITION_SL);  // SL فعلی
      if(sl == 0)  // چک SL صفر
      {
         CLogger::Log("هشدار: SL اولیه صفر است برای پوزیشن " + (string)ticket + ". تریلینگ skip شد.");  // لاگ هشدار
         return false;  // بازگشت شکست
      }

      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);  // نوع پوزیشن
      double currentPrice = posType == POSITION_TYPE_BUY ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);  // قیمت فعلی

      double trailingDistance;  // فاصله تریلینگ
      if(mode == TRAILING_ATR)  // چک حالت ATR
      {
         double atr[];  // آرایه ATR (دینامیک بدون اندازه ثابت)
         ArraySetAsSeries(atr, true);  // تنظیم سری
         if(CopyBuffer(atrHandle, 0, 1, 1, atr) <= 0)  // کپی بافر
         {
            CLogger::Log("خطا در گرفتن ATR برای تریلینگ: " + IntegerToString(GetLastError()));  // لاگ خطا
            return false;  // بازگشت شکست
         }
         trailingDistance = atr[0] * atrMultiplier;  // محاسبه پویا هر بار بدون کش
      }
      else if(mode == TRAILING_ICHIMOKU_B)  // حالت جدید: TRIALING بر اساس Senkou Span B
      {
         double senkouB = g_trendFilter.GetSenkouSpanB(trendTf);  // گرفتن Senkou Span B از فیلتر روند
         if(senkouB == 0)  // چک مقدار معتبر
         {
            CLogger::Log("خطا در گرفتن Senkou Span B برای تریلینگ.");  // لاگ خطا
            return false;  // بازگشت شکست
         }
         double buffer = 10 * _Point;  // بافر ثابت (10 پوینت) برای فاصله از خط
         trailingDistance = buffer;  // فاصله بر اساس بافر (برای تنظیم SL نسبت به Senkou B)
         // برای خرید: SL کمی پایین‌تر از Senkou B
         // برای فروش: SL کمی بالاتر از Senkou B
      }
      else  // حالت نامعتبر (برای ایمنی)
      {
         return false;  // بازگشت شکست
      }

      double newSL;  // SL جدید
      if(posType == POSITION_TYPE_BUY)  // برای خرید
      {
         if(mode == TRAILING_ICHIMOKU_B)  // حالت ایچیموکو
         {
            newSL = NormalizeDouble(g_trendFilter.GetSenkouSpanB(trendTf) - trailingDistance, _Digits);  // SL پایین‌تر از Senkou B
         }
         else  // ATR
         {
            newSL = NormalizeDouble(currentPrice - trailingDistance, _Digits);  // محاسبه SL جدید
         }
         if(newSL > sl)  // چک بهبود SL (بالاتر برای خرید)
         {
            // چک حداقل تغییر برای جلوگیری از به‌روزرسانی‌های بیهوده و هزینه‌های اضافی
            if(MathAbs(newSL - sl) < _Point * 5) return true;  // بدون تغییر اگر کم
            CTrade trade;  // نمونه معامله
            if(trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP)))  // تغییر SL
            {
               CLogger::Log("تریلینگ استاپ برای پوزیشن " + (string)ticket + " به‌روزرسانی شد. SL جدید=" + DoubleToString(newSL, _Digits));  // لاگ موفقیت
               return true;  // بازگشت موفقیت
            }
            else  // شرط شکست
            {
               CLogger::Log("خطا در به‌روزرسانی تریلینگ استاپ: " + IntegerToString(trade.ResultRetcode()));  // لاگ خطا
               return false;  // بازگشت شکست
            }
         }
      }
      else  // برای فروش
      {
         if(mode == TRAILING_ICHIMOKU_B)  // حالت ایچیموکو
         {
            newSL = NormalizeDouble(g_trendFilter.GetSenkouSpanB(trendTf) + trailingDistance, _Digits);  // SL بالاتر از Senkou B
         }
         else  // ATR
         {
            newSL = NormalizeDouble(currentPrice + trailingDistance, _Digits);  // محاسبه SL جدید
         }
         if(newSL < sl)  // چک بهبود SL (پایین‌تر برای فروش)
         {
            // چک حداقل تغییر مشابه
            if(MathAbs(newSL - sl) < _Point * 5) return true;  // بدون تغییر اگر کم
            CTrade trade;  // نمونه معامله
            if(trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP)))  // تغییر SL
            {
               CLogger::Log("تریلینگ استاپ برای پوزیشن " + (string)ticket + " به‌روزرسانی شد. SL جدید=" + DoubleToString(newSL, _Digits));  // لاگ موفقیت
               return true;  // بازگشت موفقیت
            }
            else  // شرط شکست
            {
               CLogger::Log("خطا در به‌روزرسانی تریلینگ استاپ: " + IntegerToString(trade.ResultRetcode()));  // لاگ خطا
               return false;  // بازگشت شکست
            }
         }
      }
      return true;  // بازگشت موفقیت پیش‌فرض
   }

   // بستن کامل پوزیشن: انتخاب و بستن با چک نتیجه
   // PositionClose پوزیشن را می‌بندد
   static bool ClosePosition(ulong ticket)  // بستن کامل با تیکت
   {
      if(!PositionSelectByTicket(ticket))  // چک انتخاب پوزیشن
      {
         CLogger::Log("خطا: پوزیشن با تیکت " + (string)ticket + " یافت نشد.");  // لاگ خطا
         return false;  // بازگشت شکست
      }

      CTrade trade;  // نمونه معامله
      if(trade.PositionClose(ticket))  // بستن کامل
      {
         CLogger::Log("پوزیشن با تیکت " + (string)ticket + " بسته شد.");  // لاگ موفقیت
         return true;  // بازگشت موفقیت
      }
      else  // شرط شکست
      {
         CLogger::Log("خطا در بستن پوزیشن با تیکت " + (string)ticket + ": " + IntegerToString(trade.ResultRetcode()));  // لاگ خطا
         return false;  // بازگشت شکست
      }
   }
};

#endif  // پایان
```

```mql5
//+------------------------------------------------------------------+
//|                                                     RiskManager.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CRiskManager را تعریف می‌کند که محاسبه ریسک و حجم را مدیریت می‌کند.
// استراتژی کلی اکسپرت: ریسک هر معامله بر اساس درصد موجودی حساب و فاصله SL محاسبه می‌شود تا زیان محدود شود. 
// این کلاس حجم را طوری تعیین می‌کند که زیان SL برابر درصد ریسک باشد، مستقل از نوع نماد (فارکس، شاخص، JPY).
// منطق فایل RiskManager.mqh: متد استاتیک CalculateLotSize فاصله SL (قیمت واقعی) را می‌گیرد، 
// ریسک به ازای هر لات را با فرمول slDistance * (g_tickValue / g_tickSize) محاسبه می‌کند 
// (برای سازگاری با نمادهای مختلف)، حجم را بر اساس ریسک مطلوب تعیین می‌کند و به گام حجم راند می‌کند. 
// چک‌های ولید برای جلوگیری از حجم نامعتبر اضافه شده. 
// این فایل توسط CRange برای محاسبه حجم در ExecuteTrade فراخوانی می‌شود. 
// تغییرات: هیچ تغییری لازم نبود، اما کامنت‌ها به‌روزرسانی شد.
// تغییرات نسخه 2.00: جایگزینی Print با CLogger::Log، کامنت‌گذاری دقیق.
// تغییرات نسخه 2.1: هیچ تغییری لازم نبود.

#ifndef RISK_MANAGER_MQH  // چک
#define RISK_MANAGER_MQH  // تعریف

extern double g_tickValue;  // ارزش تیک خارجی (از Elemento کش‌شده)
extern double g_tickSize;  // اندازه تیک خارجی
extern double g_volumeStep;  // گام حجم خارجی
extern double g_volumeMin;  // حداقل حجم خارجی
extern double g_volumeMax;  // حداکثر حجم خارجی

// کلاس CRiskManager برای محاسبه حجم معاملاتی بر اساس ریسک
// متد استاتیک برای سادگی
class CRiskManager  // کلاس ریسک
{
public:
   // محاسبه حجم: بر اساس درصد ریسک و فاصله SL، با فرمول سازگار برای تمام نمادها
   static double CalculateLotSize(double riskPercent, double slDistance)  // محاسبه لات با ریسک و فاصله SL
   {
      if(g_tickValue == 0 || g_tickSize == 0)  // چک مقادیر کش معتبر
      {
         CLogger::Log("خطا: tickValue یا tickSize صفر است. محاسبه حجم ممکن نیست.");  // لاگ خطا
         return 0;  // بازگشت صفر
      }

      // اگر g_tickSize صفر باشد (نادر)، default به _Point برای سازگاری
      if(g_tickSize == 0) g_tickSize = _Point;  // تنظیم پیش‌فرض اندازه تیک

      double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);  // موجودی حساب
      double riskPerLot = slDistance * (g_tickValue / g_tickSize);  // ریسک به ازای هر لات

      if (riskPerLot <= 0)  // چک ریسک معتبر
      {
          CLogger::Log("خطا: ریسک به ازای هر لات نامعتبر است. slDistance=" + DoubleToString(slDistance, _Digits));  // لاگ خطا
          return 0;  // بازگشت صفر
      }

      double riskAmount = riskPercent / 100.0 * accountBalance;  // مقدار ریسک مطلق
      double lotSize = riskAmount / riskPerLot;  // حجم اولیه

      lotSize = MathRound(lotSize / g_volumeStep) * g_volumeStep;  // راند به گام حجم
      lotSize = MathMax(g_volumeMin, MathMin(g_volumeMax, lotSize));  // محدود به min/max

      if(lotSize < g_volumeMin)  // چک کمتر از حداقل
      {
         CLogger::Log("خطا: حجم محاسبه شده (" + DoubleToString(lotSize, 2) + ") کمتر از حداقل (" + DoubleToString(g_volumeMin, 2) + ") است.");  // لاگ خطا
         return 0;  // بازگشت صفر
      }

      if(InpDebugMode) CLogger::Log("حجم محاسبه شده: " + DoubleToString(lotSize, 2) + ", slDistance=" + DoubleToString(slDistance, _Digits) + ", riskPerLot=" + DoubleToString(riskPerLot, 2));  // لاگ دیباگ
      return lotSize;  // بازگشت حجم
   }
};

#endif  // پایان
```

```mql5
//+------------------------------------------------------------------+
//|                                                      TimeHelper.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CTimeHelper را تعریف می‌کند که محاسبات زمانی را مدیریت می‌کند.
// استراتژی کلی اکسپرت: زمان‌های رنج و پاکسازی بر اساس ساعات محلی سرور محاسبه می‌شود تا رنج‌ها دقیقاً در بازه‌های تعریف‌شده عمل کنند و پس از انقضا پاک شوند.
// منطق فایل TimeHelper.mqh: متدهای استاتیک CalculateRangeTimes زمان شروع/پایان رنج را محاسبه می‌کند 
// (با مدیریت رنج‌های شبانه و تنظیم بر اساس روز فعلی)، 
// و CalculateCleanupTime زمان انقضا را بر اساس ساعت‌های پاکسازی اضافه می‌کند. 
// این فایل توسط CRange برای تعیین زمان‌ها استفاده می‌شود و وابستگی به TimeCurrent دارد. 
// تغییرات: هیچ تغییری لازم نبود، اما کامنت‌ها به‌روزرسانی شد.
// تغییرات جدید: اصلاح CalculateCleanupTime برای پذیرش datetime rangeEndTime و محاسبه ساده cleanupTime = rangeEndTime + cleanupHours * 3600 
// برای جلوگیری از باگ محاسبه در رنج‌های شبانه.
// تغییرات نسخه 2.00: کامنت‌گذاری دقیق، بدون Print (استاتیک).
// تغییرات نسخه 2.1: اصلاح باگ DST با نسخه هوشمند و مقاوم، مدیریت GMT Offset و روزهای غیر معاملاتی.

#ifndef TIME_HELPER_MQH  // چک
#define TIME_HELPER_MQH  // تعریف

// کلاس CTimeHelper برای محاسبات زمانی رنج و پاکسازی
// متدها استاتیک برای سادگی
class CTimeHelper  // کلاس زمان
{
public:
   // محاسبه زمان شروع و پایان رنج: تنظیم بر اساس روز فعلی و مدیریت رنج‌های عبور از نیمه‌شب
   // TimeToStruct زمان را به ساختار تبدیل می‌کند
   // تغییرات نسخه 2.1: نسخه هوشمند با مدیریت GMT، DST و روزهای غیر معاملاتی
   static bool CalculateRangeTimes(int startHour, int startMinute, int endHour, int endMinute, datetime &startTime, datetime &endTime)
   {
      long server_gmt_offset = SymbolInfoInteger(_Symbol, SYMBOL_TIME_GMT_OFFSET);  // افست سرور با GMT
      datetime gmt_now = TimeGMT();  // زمان GMT فعلی
      MqlDateTime dt_gmt;  // ساختار GMT
      TimeToStruct(gmt_now, dt_gmt);  // تبدیل

      datetime gmt_today_start = gmt_now - (dt_gmt.hour * 3600 + dt_gmt.min * 60 + dt_gmt.sec);  // شروع روز GMT

      datetime gmt_start_time = gmt_today_start + startHour * 3600 + startMinute * 60;  // زمان شروع GMT
      datetime gmt_end_time = gmt_today_start + endHour * 3600 + endMinute * 60;  // زمان پایان GMT

      if(gmt_end_time <= gmt_start_time)  // چک رنج شبانه
      {
         gmt_end_time += 86400;  // اضافه روز
      }

      // حلقه هوشمند برای پیدا کردن آخرین روز معاملاتی (برای آخر هفته‌ها و کریپتو)
      while(gmt_now < gmt_start_time)
      {
         gmt_start_time -= 86400;  // عقب بردن
         gmt_end_time -= 86400;

         MqlDateTime check_day_dt;  // ساختار چک روز
         TimeToStruct(gmt_start_time, check_day_dt);  // تبدیل
         datetime session_from, session_to;  // جلسه معاملاتی

         // اگر این روز جلسه معاملاتی ندارد (مثل شنبه برای فارکس)، یک روز دیگر عقب برو
         if(!SymbolInfoSessionTrade(_Symbol, (ENUM_DAY_OF_WEEK)check_day_dt.day_of_week, 0, session_from, session_to))
         {
            CLogger::Log("روز غیر معاملاتی شناسایی شد: " + TimeToString(gmt_start_time, TIME_DATE) + ". بررسی روز قبل...", 0);  // لاگ روز غیر معاملاتی
            continue;  // ادامه حلقه
         }
         break; // روز معاملاتی پیدا شد
      }

      startTime = gmt_start_time + server_gmt_offset;  // تبدیل به زمان سرور
      endTime = gmt_end_time + server_gmt_offset;  // تبدیل به زمان سرور

      if(InpDebugMode) CLogger::Log("محاسبه زمان رنج (GMT Aware): Start=" + TimeToString(startTime) + ", End=" + TimeToString(endTime));  // لاگ دیباگ
      return true;  // موفقیت
   }

   // محاسبه زمان پاکسازی: اضافه کردن ساعت‌های پاکسازی به زمان پایان برای انقضا (نسخه اصلاح شده)
   // محاسبه ساده برای دقت
   static datetime CalculateCleanupTime(datetime rangeEndTime, int cleanupHours)  // محاسبه زمان پاکسازی
   {
      datetime cleanupTime = rangeEndTime + cleanupHours * 3600;  // به همین سادگی!
      if(InpDebugMode) CLogger::Log("زمان پاکسازی محاسبه شد: " + TimeToString(cleanupTime));  // لاگ دیباگ
      return cleanupTime;  // بازگشت زمان
   }
};

#endif  // پایان
```

```mql5
//+------------------------------------------------------------------+
//|                                                     TrendFilter.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CTrendFilter را تعریف می‌کند که فیلتر روند بر اساس ایچیموکو را مدیریت می‌کند.
// استراتژی کلی اکسپرت: فیلتر روند برای جلوگیری از معاملات خلاف جهت استفاده می‌شود؛ 
// اگر ابر ایچیموکو فلت (خنثی) یا هم‌جهت باشد، معامله مجاز است، иначе رد می‌شود.
// منطق فایل TrendFilter.mqh: enum ENUM_TREND_DIRECTION برای خروجی (BUY/SELL/NEUTRAL). 
// تابع GetTrendDirection سنکو A/B را به طور دستی محاسبه می‌کند 
// (با استفاده از iHigh/iLow برای دوره‌های تنکان، کیجون و سنکو B)، 
// تفاوت را چک می‌کند (اگر کمتر از آستانه، خنثی)، 
// و جهت را تعیین می‌کند (A > B برای BUY). 
// این محاسبه دستی برای جلوگیری از مشکلات دسترسی به کندل‌های آینده در MT5 انجام می‌شود. 
// Init/Deinit خالی هستند زیرا هیچ هندلی ثابت نیست. 
// این فایل توسط CRange برای تأیید فیلتر مستقل فراخوانی می‌شود. 
// تغییرات جدید: اضافه تابع GetSenkouSpanB برای بازگشت مقدار Senkou Span B برای استفاده در تریلینگ.
// تغییرات نسخه 2.00: جایگزینی Print با CLogger::Log، کامنت‌گذاری دقیق.
// تغییرات نسخه 2.1: هیچ تغییری لازم نبود.

#ifndef TREND_FILTER_MQH  // چک
#define TREND_FILTER_MQH  // تعریف

// تعریف enum برای جهت روند (برای تصمیم‌گیری در فیلتر)
// این enum خروجی فیلتر را استاندارد می‌کند
enum ENUM_TREND_DIRECTION
{
   TREND_BUY,     // روند صعودی (سنکو A بالای B) - جهت خرید مجاز
   TREND_SELL,    // روند نزولی (سنکو A پایین B) - جهت فروش مجاز
   TREND_NEUTRAL  // روند خنثی (ابر فلت یا فیلتر خاموش) - هر جهتی مجاز
};

// کلاس CTrendFilter برای فیلتر روند پویا بر اساس ایچیموکو
// محاسبات دستی بدون هندل
class CTrendFilter  // کلاس فیلتر روند
{
public:
   CTrendFilter() {}  // سازنده پیش‌فرض - هیچ مقداری اولیه ندارد

   // Init خالی (هیچ هندلی ثابت ساخته نمی‌شود، محاسبه دستی در GetTrendDirection)
   bool Init() { return true; }  // مقداردهی - همیشه موفقیت

   // Deinit خالی (هیچ منبعی ثابت برای آزادسازی نیست)
   void Deinit() {}  // دفع - هیچ عملی

   // گرفتن جهت روند: محاسبه دستی سنکو A/B بر اساس داده‌های گذشته (برای ابر آینده بدون نیاز به کندل آینده)
   // iHighest/iLowest ایندکس‌ها را پیدا می‌کنند
   ENUM_TREND_DIRECTION GetTrendDirection(ENUM_TIMEFRAMES timeframe)  // گرفتن جهت با تایم‌فریم
   {
      if(!Inp_IchimokuFilter_Enabled)  // چک فیلتر خاموش
      {
         return TREND_NEUTRAL;  // اگر فیلتر خاموش باشد، همیشه خنثی فرض می‌شود
      }

      // محاسبه تنکان-سن (برای کندل بسته آخر، shift 1)
      int tenkanHighIdx = iHighest(_Symbol, timeframe, MODE_HIGH, Inp_Ichimoku_Tenkan, 1);  // ایندکس سقف تنکان
      int tenkanLowIdx = iLowest(_Symbol, timeframe, MODE_LOW, Inp_Ichimoku_Tenkan, 1);  // ایندکس کف تنکان
      double tenkanHigh = iHigh(_Symbol, timeframe, tenkanHighIdx);  // های تنکان
      double tenkanLow = iLow(_Symbol, timeframe, tenkanLowIdx);  // لو تنکان
      double tenkan = (tenkanHigh + tenkanLow) / 2.0;  // تنکان-سن

      // محاسبه کیجون-سن
      int kijunHighIdx = iHighest(_Symbol, timeframe, MODE_HIGH, Inp_Ichimoku_Kijun, 1);  // ایندکس سقف کیجون
      int kijunLowIdx = iLowest(_Symbol, timeframe, MODE_LOW, Inp_Ichimoku_Kijun, 1);  // ایندکس کف کیجون
      double kijunHigh = iHigh(_Symbol, timeframe, kijunHighIdx);  // های کیجون
      double kijunLow = iLow(_Symbol, timeframe, kijunLowIdx);  // لو کیجون
      double kijun = (kijunHigh + kijunLow) / 2.0;  // کیجون-سن

      // محاسبه سنکو اسپن A (برای ابر آینده)
      double senkouA = (tenkan + kijun) / 2.0;  // سنکو A

      // محاسبه سنکو اسپن B (برای ابر آینده)
      int senkouBHighIdx = iHighest(_Symbol, timeframe, MODE_HIGH, Inp_Ichimoku_SenkouB, 1);  // ایندکس سقف سنکو B
      int senkouBLowIdx = iLowest(_Symbol, timeframe, MODE_LOW, Inp_Ichimoku_SenkouB, 1);  // ایندکس کف سنکو B
      double senkouBHigh = iHigh(_Symbol, timeframe, senkouBHighIdx);  // های سنکو B
      double senkouBLow = iLow(_Symbol, timeframe, senkouBLowIdx);  // لو سنکو B
      double senkouB = (senkouBHigh + senkouBLow) / 2.0;  // سنکو B

      double diff = MathAbs(senkouA - senkouB) / _Point;  // تفاوت به پوینت
      if(diff < Inp_Ichimoku_FlatThreshold_Points)  // چک فلت بودن
      {
         if(InpDebugMode) CLogger::Log("ابر ایچیموکو فلت است. جهت: NEUTRAL");  // لاگ دیباگ
         return TREND_NEUTRAL;  // بازگشت خنثی
      }

      if(senkouA > senkouB)  // چک صعودی
      {
         if(InpDebugMode) CLogger::Log("جهت روند: BUY");  // لاگ دیباگ
         return TREND_BUY;  // بازگشت خرید
      }
      else  // چک نزولی
      {
         if(InpDebugMode) CLogger::Log("جهت روند: SELL");  // لاگ دیباگ
         return TREND_SELL;  // بازگشت فروش
      }
   }

   // (جدید) گرفتن Senkou Span B: محاسبه دستی و بازگشت مقدار برای استفاده در تریلینگ
   // مشابه محاسبه در GetTrendDirection
   double GetSenkouSpanB(ENUM_TIMEFRAMES timeframe)  // گرفتن Senkou B با تایم‌فریم
   {
      // محاسبه سنکو اسپن B (برای ابر آینده)
      int senkouBHighIdx = iHighest(_Symbol, timeframe, MODE_HIGH, Inp_Ichimoku_SenkouB, 1);  // ایندکس سقف سنکو B
      int senkouBLowIdx = iLowest(_Symbol, timeframe, MODE_LOW, Inp_Ichimoku_SenkouB, 1);  // ایندکس کف سنکو B
      double senkouBHigh = iHigh(_Symbol, timeframe, senkouBHighIdx);  // های سنکو B
      double senkouBLow = iLow(_Symbol, timeframe, senkouBLowIdx);  // لو سنکو B
      double senkouB = (senkouBHigh + senkouBLow) / 2.0;  // محاسبه Senkou B

      if(senkouB == 0)  // چک مقدار معتبر (برای ایمنی)
      {
         if(InpDebugMode) CLogger::Log("خطا در محاسبه Senkou Span B.");  // لاگ خطا
      }
      return senkouB;  // بازگشت مقدار
   }
};

#endif  // پایان
```

```mql5
//+------------------------------------------------------------------+
//|                                                   VisualManager.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CVisualManager را تعریف می‌کند که نمایش بصری روی چارت را مدیریت می‌کند.
// استراتژی کلی اکسپرت: نمایش وضعیت روند (Bullish/Bearish/Neutral) برای هر رنج فعال به طور جداگانه 
// برای کمک به کاربر در نظارت، بدون تأثیر بر منطق معاملاتی.
// منطق فایل VisualManager.mqh: کلاس شیء LABEL را برای نمایش متن کامل وضعیت هر رنج ایجاد می‌کند، 
// موقعیت، فونت را تنظیم می‌کند. 
// تابع UpdateTrendStatus متن چندخطی را به‌روزرسانی و چارت را redraw می‌کند. 
// Init شیء را می‌سازد و Deinit حذف می‌کند. 
// این فایل توسط Elemento.mq5 برای نمایش در OnTick فراخوانی می‌شود و اختیاری است 
// (اگر Inp_Visual_ShowTrendStatus خاموش باشد، نادیده گرفته می‌شود). 
// تغییرات جدید: پشتیبانی از متن چندخطی برای نمایش هر رنج جداگانه.
// تغییرات نسخه 2.00: جایگزینی Print با CLogger::Log، کامنت‌گذاری دقیق.
// تغییرات نسخه 2.1: هیچ تغییری لازم نبود.

#ifndef VISUAL_MANAGER_MQH  // چک
#define VISUAL_MANAGER_MQH  // تعریف

// کلاس CVisualManager برای مدیریت نمایش متن روند هر رنج روی چارت
// OBJ_LABEL برای متن استفاده می‌شود
class CVisualManager  // کلاس نمایش
{
private:
   string m_trendStatusObjectName;  // نام منحصربه‌فرد شیء LABEL برای نمایش - ثابت "TrendStatus"

public:
   CVisualManager() : m_trendStatusObjectName("TrendStatus") {}  // سازنده - تنظیم نام شیء

   // مقداردهی: ایجاد شیء LABEL با تنظیمات فونت، رنگ و موقعیت اگر نمایش فعال باشد
   // ObjectCreate شیء را می‌سازد
   bool Init()  // مقداردهی مدیر نمایش
   {
      if(InpDebugMode) CLogger::Log("مقداردهی مدیر نمایش...");  // لاگ شروع
      if(Inp_Visual_ShowTrendStatus)  // چک فعال بودن نمایش
      {
         if(!ObjectCreate(0, m_trendStatusObjectName, OBJ_LABEL, 0, 0, 0))  // ایجاد LABEL
         {
            CLogger::Log("خطا در ایجاد شیء نمایش روند: " + IntegerToString(GetLastError()));  // لاگ خطا
            return false;  // شکست
         }

         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_XDISTANCE, Inp_Visual_X_Offset);  // فاصله افقی
         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_YDISTANCE, Inp_Visual_Y_Offset);  // فاصله عمودی
         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_CORNER, CORNER_LEFT_UPPER);  // گوشه چپ بالا
         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_FONTSIZE, Inp_Visual_FontSize);  // اندازه فونت
         ObjectSetString(0, m_trendStatusObjectName, OBJPROP_FONT, "Arial");  // فونت
         ObjectSetString(0, m_trendStatusObjectName, OBJPROP_TEXT, "Initializing...");  // متن اولیه
         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_COLOR, Inp_Visual_FontColor_Neutral);  // رنگ خنثی
      }
      if(InpDebugMode) CLogger::Log("مدیر نمایش با موفقیت مقداردهی شد.");  // لاگ موفقیت
      return true;  // موفقیت
   }

   // دفع: حذف شیء LABEL برای پاکسازی چارت
   // ObjectDelete شیء را حذف می‌کند
   void Deinit()  // دفع مدیر نمایش
   {
      ObjectDelete(0, m_trendStatusObjectName);  // حذف شیء
      if(InpDebugMode) CLogger::Log("شیء نمایش روند حذف شد.");  // لاگ دیباگ
   }

   // به‌روزرسانی نمایش: تغییر متن کامل وضعیت روند هر رنج و redraw چارت
   // ChartRedraw چارت را به‌روزرسانی می‌کند
   void UpdateTrendStatus(string fullText)  // به‌روزرسانی متن نمایش
   {
      if(!Inp_Visual_ShowTrendStatus) return;  // خروج اگر نمایش خاموش

      ObjectSetString(0, m_trendStatusObjectName, OBJPROP_TEXT, fullText);  // تنظیم متن جدید
      ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_COLOR, Inp_Visual_FontColor_Neutral);  // رنگ خنثی برای متن چندخطی
      ChartRedraw();  // redraw چارت
   }
};

#endif  // پایان
```
