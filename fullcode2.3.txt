//+------------------------------------------------------------------+
//|                                                     Settings.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل شامل تعریف ساختارهای پایه‌ای و پارامترهای ورودی (inputs) برای اکسپرت Elemento است.
// استراتژی کلی اکسپرت: Elemento یک سیستم معاملاتی مبتنی بر شکست رنج (Breakout Range) است که بر اساس زمان‌های مشخص (رنج‌های زمانی) عمل می‌کند. 
// این اکسپرت تا چهار رنج زمانی مختلف را تعریف می‌کند، هر رنج را بر اساس ارتفاع قیمت (High/Low) در بازه زمانی تعیین‌شده شناسایی می‌کند، 
// سپس منتظر شکست (Breakout) سقف یا کف رنج با افست (Offset) مبتنی بر ATR یا درصد ارتفاع رنج می‌ماند. 
// پس از شکست، با تأیید اختیاری قیمت (کندل تایید) و فیلتر روند ایچیموکو، معامله خرید یا فروش باز می‌کند. 
// مدیریت معامله شامل استاپ لاس (SL) مبتنی بر استراتژی جایگذاری (مقابل رنج یا سطح شکست) به علاوه تنظیم ATR یا درصد 
// (برای پوشش کامل رنج و جلوگیری از زیان زودرس)، خروج پله‌ای (Partial Close) در رسیدن به نسبت مشخص سود به ریسک بدون تارگت کل 
// (برای اجازه دادن به روند ادامه‌دار)، و تریلینگ استاپ (Trailing Stop) برای حفظ سود است. 
// پاکسازی رنج‌ها پس از انقضا یا بسته شدن بازار انجام می‌شود تا از تداخل جلوگیری شود.
// منطق فایل Settings.mqh: این فایل هیچ کدی اجرایی ندارد و فقط enums و گروه‌های input را تعریف می‌کند تا کاربر بتواند پارامترها را تنظیم کند. 
// enums برای حالت‌های مختلف (مانند PLACEMENT_MODE برای تعیین افست شکست، SL_STRATEGY برای استراتژی جایگذاری SL، 
// SL_CALC_MODE برای محاسبه بافر SL، TRAILING_MODE برای تریلینگ) استفاده می‌شوند. 
// گروه‌های input شامل تنظیمات عمومی (ریسک، دیباگ، تایید قیمت)، فیلتر ایچیموکو (برای جلوگیری از معاملات خلاف روند)، 
// نمایشگر چارت (برای نشان دادن وضعیت روند هر رنج به طور جداگانه)، و تنظیمات چهار رنج جداگانه (هر رنج می‌تواند تایم‌فریم، ساعات، 
// حداقل/حداکثر ارتفاع، دوره‌های ATR، ضرایب، نسبت R:R، درصد خروج پله‌ای، ساعت پاکسازی و رنگ داشته باشد) است. 
// این ساختار اجازه می‌دهد اکسپرت برای بازارهای مختلف (مانند فارکس یا شاخص‌ها) سفارشی‌سازی شود و استراتژی شکست رنج را با فیلتر روند ترکیب کند 
// تا سیگنال‌های معتبرتری تولید شود. فایل توسط سایر فایل‌ها include می‌شود تا به inputs دسترسی داشته باشند. 
// تغییرات جدید در نسخه 2.30: اضافه کردن گروه "تنظیمات ورود تطبیقی" با Inp_AdaptiveEntry_Enabled, ENUM_ADAPTIVE_MODE و Inp_AdaptiveMode, 
// ENUM_ICHIMOKU_MODE و Inp_IchimokuMode, Inp_MinCandleBodyRatio و Inp_ExplosiveCandleBodyRatio برای تحلیل قدرت شکست و انتخاب استراتژی ورود.

#ifndef SETTINGS_MQH  // چک وجود فایل برای جلوگیری از include مکرر
#define SETTINGS_MQH  // تعریف ماکرو برای جلوگیری از include مجدد

// تعریف enum برای حالت‌های مختلف قرارگیری سفارش (تعیین افست شکست رنج با ATR یا درصد ارتفاع رنج برای جلوگیری از شکست‌های کاذب)
// این enum اجازه می‌دهد کاربر بین محاسبه پویا (ATR) یا ثابت (درصد) برای افست شکست انتخاب کند
enum ENUM_PLACEMENT_MODE
{
   PLACEMENT_ATR,    // استفاده از ATR برای محاسبه افست ثبت سفارش (پویا بر اساس نوسان بازار، مناسب برای بازارهای متغیر)
   PLACEMENT_PERCENT // استفاده از درصد ارتفاع رنج برای محاسبه افست ثبت سفارش (ثابت بر اساس اندازه رنج، مناسب برای رنج‌های پایدار)
};

// تعریف enum برای استراتژی جایگذاری استاپ لاس (تعیین پایه SL: مقابل رنج یا سطح شکست)
// این enum به کاربر اجازه می‌دهد بین استراتژی محافظه‌کارانه (مقابل رنج) یا تهاجمی (سطح شکست) انتخاب کند
enum ENUM_SL_STRATEGY
{
   SL_OPPOSITE_SIDE,  // استاپ لاس در سمت مقابل رنج (قبلی: برای BUY در کف - بافر، برای SELL در سقف + بافر، محافظه‌کارانه‌تر)
   SL_BREAKOUT_LEVEL  // استاپ لاس در سطح شکست (جدید: برای BUY در سقف - بافر، برای SELL در کف + بافر، ریسک بالاتر اما سود بالقوه بیشتر)
};

// تعریف enum برای حالت محاسبه بافر استاپ لاس (تعیین فاصله بافر SL با ATR یا درصد ارتفاع رنج)
// این enum برای تطبیق بافر SL با نوسان یا اندازه رنج استفاده می‌شود
enum ENUM_SL_CALC_MODE
{
   SL_CALC_ATR,    // استفاده از ATR برای محاسبه بافر استاپ لاس (پویا و تطبیقی با نوسان بازار، توصیه‌شده)
   SL_CALC_PERCENT // استفاده از درصد ارتفاع رنج برای محاسبه بافر استاپ لاس (ثابت و ساده، برای رنج‌های کوچک)
};

// تعریف enum برای حالت‌های تریلینگ استاپ (تعیین فاصله تریلینگ با ATR یا Senkou Span B برای حفظ سود)
// این enum گزینه‌های پویا (ATR) یا مبتنی بر ابر ایچیموکو (Senkou B) را فراهم می‌کند
enum ENUM_TRAILING_MODE
{
   TRAILING_ATR,   // استفاده از ATR برای محاسبه فاصله تریلینگ استاپ (پویا و مبتنی بر نوسان اخیر)
   TRAILING_ICHIMOKU_B  // استفاده از Senkou Span B برای تریلینگ استاپ (بر اساس ابر ایچیموکو، برای روندهای بلندمدت)
};

// (جدید) تعریف enum برای استراتژی ابطال تلاش برای ورود (انتخاب بین حالت صبور یا تهاجمی برای ابطال فرصت ورود)
// این enum انعطاف‌پذیری در رفتار ابطال سیگنال را افزایش می‌دهد
enum ENUM_INVALIDATION_MODE
{
   INVALIDATION_RANGE_REENTRY,     // حالت صبور: فرصت ورود فقط در صورت بازگشت قیمت به داخل رنج اصلی باطل می‌شود (فرصت‌های بیشتر)
   INVALIDATION_BREAKOUT_LINE_CROSS  // حالت تهاجمی: فرصت ورود به محض بازگشت قیمت به زیر خط شکست باطل می‌شود (ریسک کمتر)
};

// (جدید) تعریف enum برای استراتژی تایید/ابطال (انتخاب بین حالت قدیمی با تایمر کندلی و جدید با ابطال قیمت)
// این enum به کاربر اجازه می‌دهد بین رویکرد زمانی یا قیمتی انتخاب کند
enum ENUM_CONFIRMATION_STRATEGY
{
   CONFIRMATION_TIMEOUT,           // حالت قدیمی: مهلت تایید با تعداد کندل (Inp_Confirmation_Timeout، محدودکننده)
   CONFIRMATION_PRICE_INVALIDATION // حالت جدید: ابطال بر اساس بازگشت قیمت بدون محدودیت زمانی (انعطاف‌پذیرتر)
};

// گروه ورودی برای تنظیمات عمومی (پارامترهای پایه‌ای که بر تمام رنج‌ها تأثیر می‌گذارند)
// این گروه شامل تنظیمات ریسک، دیباگ و استراتژی‌های عمومی است
input group "تنظیمات عمومی"  // عنوان گروه در تنظیمات MT5
input long InpBaseMagicNumber = 123456; // مجیک نامبر پایه (برای تمایز معاملات رنج‌های مختلف و جلوگیری از تداخل با دیگر اکسپرت‌ها، منحصربه‌فرد باشد)
input double InpRiskPercent = 1.0; // درصد ریسک (0.1 تا 5.0) - مقدار ریسک هر معامله بر اساس موجودی حساب برای کنترل زیان کلی (توصیه: 1-2%)
input bool InpDebugMode = true; // حالت دیباگ (چاپ پیام‌های اضافی برای عیب‌یابی و نظارت بر عملکرد اکسپرت، خاموش برای لایو)
// (جدید) انتخاب‌گر استراتژی ابطال تلاش ورود (برای انعطاف‌پذیری در رفتار اکسپرت: صبور یا تهاجمی)
input ENUM_INVALIDATION_MODE Inp_Invalidation_Mode = INVALIDATION_RANGE_REENTRY; // استراتژی ابطال: بازگشت به رنج (صبور، فرصت بیشتر) یا عبور از خط شکست (تهاجمی، ایمن‌تر)
// (جدید) انتخاب‌گر استراتژی تایید/ابطال (انتخاب بین قدیمی با تایمر و جدید با قیمت)
input ENUM_CONFIRMATION_STRATEGY Inp_Confirmation_Strategy = CONFIRMATION_PRICE_INVALIDATION; // استراتژی تایید: تایمر کندلی (قدیمی، محدود) یا ابطال قیمت (جدید، انعطاف‌پذیر)
input int Inp_Confirmation_Timeout = 3; // مهلت تأیید قیمت و فیلتر (تعداد کندل) - فقط اگر CONFIRMATION_TIMEOUT انتخاب شود (1-10 توصیه‌شده)
input bool Inp_PriceConfirmation_Enabled = true; // فعال کردن تأیید قیمت پس از کندل شکننده (اگر خاموش باشد، مستقیم به فیلتر روند می‌رود یا ورود، برای سرعت بیشتر)

// گروه ورودی برای فیلتر روند ایچیموکو (برای اطمینان از معامله در جهت روند یا خنثی و جلوگیری از معاملات خلاف روند)
// این گروه پارامترهای ایچیموکو را برای فیلتر دینامیک تنظیم می‌کند
input group "فیلتر روند ایچیموکو"  // عنوان گروه
input bool Inp_IchimokuFilter_Enabled = true; // فعال کردن فیلتر روند ایچیموکو (اگر خاموش باشد، همیشه خنثی فرض می‌شود و همه سیگنال‌ها مجاز)
input int Inp_Ichimoku_Tenkan = 9; // دوره تنکان-سن (خط سریع ایچیموکو برای تشخیص روند کوتاه‌مدت، پیش‌فرض استاندارد)
input int Inp_Ichimoku_Kijun = 26; // دوره کیجون-سن (خط کند ایچیموکو برای تشخیص روند میان‌مدت، پیش‌فرض استاندارد)
input int Inp_Ichimoku_SenkouB = 52; // دوره سنکو اسپن B (ابر ایچیموکو برای تشخیص حمایت/مقاومت آینده، پیش‌فرض استاندارد)
input double Inp_Ichimoku_FlatThreshold_Points = 0.0; // آستانه تشخیص ابر فلت به پوینت (برای تعیین روند خنثی اگر تفاوت سنکو A و B کمتر باشد، بر اساس نماد تنظیم شود)

// گروه ورودی برای تنظیمات نمایشگر چارت (برای نمایش بصری وضعیت روند هر رنج به طور جداگانه روی چارت به کاربر)
// این گروه برای نظارت بصری کاربر است و عملکرد را تحت تأثیر قرار نمی‌دهد
input group "تنظیمات نمایشگر چارت"  // عنوان گروه
input bool Inp_Visual_ShowTrendStatus = true; // فعال کردن نمایش وضعیت روند (روی چارت برای نظارت بصری هر رنج، خاموش برای چارت تمیزتر)
input int Inp_Visual_FontSize = 12; // اندازه فونت نمایشگر (برای خوانایی بهتر، 8-16 مناسب)
input color Inp_Visual_FontColor_Buy = clrGreen; // رنگ متن برای روند BUY (سبز برای مثبت، قابل تغییر)
input color Inp_Visual_FontColor_Sell = clrRed; // رنگ متن برای روند SELL (قرمز برای منفی، قابل تغییر)
input color Inp_Visual_FontColor_Neutral = clrGray; // رنگ متن برای روند NEUTRAL (خاکستری برای خنثی، قابل تغییر)
input int Inp_Visual_X_Offset = 10; // فاصله افقی از لبه چارت (پیکسل برای موقعیت مناسب، 0-50)
input int Inp_Visual_Y_Offset = 10; // فاصله عمودی از لبه چارت (پیکسل برای موقعیت مناسب، 0-50)

// گروه ورودی برای تنظیمات رنج 1 (اولین رنج زمانی، معمولاً برای سشن آسیا یا شبانه)
// این گروه پارامترهای اختصاصی رنج 1 را شامل می‌شود
input group "تنظیمات رنج 1"  // عنوان گروه
input bool InpRange1_Enabled = true; // فعال کردن رنج 1 (اگر خاموش باشد، این رنج نادیده گرفته می‌شود و منابع صرفه‌جویی می‌شود)
input ENUM_TIMEFRAMES InpRange1_Execution_Timeframe = PERIOD_M5; // تایم‌فریم اجرا رنج 1 (برای اجرای منطق رنج و محاسبات، M1-M30 توصیه‌شده)
input ENUM_TIMEFRAMES InpRange1_TrendFilter_Timeframe = PERIOD_M15; // تایم‌فریم فیلتر روند رنج 1 (برای فیلتر ایچیموکو، می‌تواند متفاوت باشد، H1-H4 مناسب)
input int InpRange1_Start_Hour = 22; // ساعت شروع رنج 1 (0-23 برای تعریف بازه زمانی، بر اساس GMT سرور)
input int InpRange1_Start_Minute = 0; // دقیقه شروع رنج 1 (0-59 برای دقت زمانی، 0 برای شروع ساعتی)
input int InpRange1_End_Hour = 9; // ساعت پایان رنج 1 (0-23، اگر کمتر از شروع باشد، رنج شبانه فرض می‌شود)
input int InpRange1_End_Minute = 30; // دقیقه پایان رنج 1 (0-59، برای پایان دقیق)
input int InpRange1_MinRangePoints = 200; // حداقل ارتفاع رنج 1 به پوینت (برای فیلتر رنج‌های کوچک و بی‌کیفیت، بر اساس نماد تنظیم شود)
input int InpRange1_MaxRangePoints = 1500; // حداکثر ارتفاع رنج 1 به پوینت (برای فیلتر رنج‌های بزرگ و پرریسک، بر اساس نوسان تنظیم شود)
input ENUM_PLACEMENT_MODE InpRange1_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 1 (افست شکست، ATR برای پویایی)
input int InpRange1_ATR_Period = 122; // دوره ATR برای ثبت سفارش رنج 1 (برای محاسبه افست پویا، 14-200)
input double InpRange1_ATR_Multiplier = 2.3; // ضریب ATR برای ثبت سفارش رنج 1 (برای تنظیم حساسیت افست، 1.0-3.0)
input ENUM_SL_STRATEGY InpRange1_SL_Strategy = SL_BREAKOUT_LEVEL; // استراتژی جایگذاری استاپ لاس رنج 1 (مقابل یا سطح شکست، BREAKOUT برای تهاجمی)
input ENUM_SL_CALC_MODE InpRange1_SL_Calc_Mode = SL_CALC_ATR; // حالت محاسبه بافر استاپ لاس رنج 1 (ATR برای تطبیق)
input int InpRange1_SL_ATR_Period = 62; // دوره ATR برای بافر استاپ لاس رنج 1 (14-100)
input double InpRange1_SL_ATR_Multiplier = 1.3; // ضریب ATR برای بافر استاپ لاس رنج 1 (0.5-2.0)
input ENUM_TRAILING_MODE InpRange1_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 1 (ATR برای پویایی)
input int InpRange1_Trailing_ATR_Period = 43; // دوره ATR برای تریلینگ رنج 1 (14-100)
input double InpRange1_Trailing_ATR_Multiplier = 1.4; // ضریب ATR برای تریلینگ رنج 1 (1.0-2.0)
input double InpRange1_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 1 (سود به ریسک برای خروج پله‌ای، 1.0-3.0)
input double InpRange1_PartialClosePercent = 60.0; // درصد بستن پله‌ای رنج 1 (هنگام رسیدن به RR، 30-70%)
input int InpRange1_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج 1 (0-24، زمان انقضای رنج پس از پایان، 1-12 مناسب)
input color InpRange1_Color = clrBlue; // رنگ مستطیل رنج 1 (برای نمایش گرافیکی روی چارت، آبی برای تمایز)

// گروه ورودی برای تنظیمات رنج 2 (دومین رنج، معمولاً برای سشن اروپا)
// مشابه رنج 1، اما با پارامترهای بهینه‌شده برای سشن اروپا
input group "تنظیمات رنج 2"  // عنوان گروه
input bool InpRange2_Enabled = false; // فعال کردن رنج 2 (خاموش برای غیرفعال کردن)
input ENUM_TIMEFRAMES InpRange2_Execution_Timeframe = PERIOD_M15; // تایم‌فریم اجرا رنج 2 (M5-M30)
input ENUM_TIMEFRAMES InpRange2_TrendFilter_Timeframe = PERIOD_M15; // تایم‌فریم فیلتر روند رنج 2 (M15-H1)
input int InpRange2_Start_Hour = 5; // ساعت شروع رنج 2 (0-23)
input int InpRange2_Start_Minute = 0; // دقیقه شروع رنج 2 (0-59)
input int InpRange2_End_Hour = 13; // ساعت پایان رنج 2 (0-23)
input int InpRange2_End_Minute = 0; // دقیقه پایان رنج 2 (0-59)
input int InpRange2_MinRangePoints = 200; // حداقل ارتفاع رنج 2 به پوینت
input int InpRange2_MaxRangePoints = 3500; // حداکثر ارتفاع رنج 2 به پوینت
input ENUM_PLACEMENT_MODE InpRange2_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 2
input int InpRange2_ATR_Period = 27; // دوره ATR برای ثبت سفارش رنج 2
input double InpRange2_ATR_Multiplier = 2.8; // ضریب ATR برای ثبت سفارش رنج 2
input ENUM_SL_STRATEGY InpRange2_SL_Strategy = SL_OPPOSITE_SIDE; // استراتژی جایگذاری استاپ لاس رنج 2
input ENUM_SL_CALC_MODE InpRange2_SL_Calc_Mode = SL_CALC_ATR; // حالت محاسبه بافر استاپ لاس رنج 2
input int InpRange2_SL_ATR_Period = 86; // دوره ATR برای بافر استاپ لاس رنج 2
input double InpRange2_SL_ATR_Multiplier = 1.56; // ضریب ATR برای بافر استاپ لاس رنج 2
input ENUM_TRAILING_MODE InpRange2_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 2
input int InpRange2_Trailing_ATR_Period = 101; // دوره ATR برای تریلینگ رنج 2
input double InpRange2_Trailing_ATR_Multiplier = 1.58; // ضریب ATR برای تریلینگ رنج 2
input double InpRange2_RR_Ratio = 2.8; // نسبت R:R برای خروج پله‌ای رنج 2
input double InpRange2_PartialClosePercent = 26; // درصد بستن پله‌ای رنج 2
input int InpRange2_Cleanup_Hours = 4; // ساعت‌های پاکسازی رنج 2 (0-24)
input color InpRange2_Color = clrRed; // رنگ مستطیل رنج 2

// گروه ورودی برای تنظیمات رنج 3 (سومین رنج، معمولاً برای سشن آمریکا)
// پارامترهای بهینه‌شده برای سشن آمریکا با رنج کوچک‌تر
input group "تنظیمات رنج 3"  // عنوان گروه
input bool InpRange3_Enabled = false; // فعال کردن رنج 3 (پیش‌فرض خاموش برای سادگی)
input ENUM_TIMEFRAMES InpRange3_Execution_Timeframe = PERIOD_M5; // تایم‌فریم اجرا رنج 3
input ENUM_TIMEFRAMES InpRange3_TrendFilter_Timeframe = PERIOD_M30; // تایم‌فریم فیلتر روند رنج 3
input int InpRange3_Start_Hour = 15; // ساعت شروع رنج 3 (0-23)
input int InpRange3_Start_Minute = 0; // دقیقه شروع رنج 3 (0-59)
input int InpRange3_End_Hour = 18; // ساعت پایان رنج 3 (0-23)
input int InpRange3_End_Minute = 0; // دقیقه پایان رنج 3 (0-59)
input int InpRange3_MinRangePoints = 100; // حداقل ارتفاع رنج 3 به پوینت
input int InpRange3_MaxRangePoints = 2110; // حداکثر ارتفاع رنج 3 به پوینت
input ENUM_PLACEMENT_MODE InpRange3_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 3
input int InpRange3_ATR_Period = 14; // دوره ATR برای ثبت سفارش رنج 3
input double InpRange3_ATR_Multiplier = 1.2; // ضریب ATR برای ثبت سفارش رنج 3
input ENUM_SL_STRATEGY InpRange3_SL_Strategy = SL_OPPOSITE_SIDE; // استراتژی جایگذاری استاپ لاس رنج 3
input ENUM_SL_CALC_MODE InpRange3_SL_Calc_Mode = SL_CALC_ATR; // حالت محاسبه بافر استاپ لاس رنج 3
input int InpRange3_SL_ATR_Period = 14; // دوره ATR برای بافر استاپ لاس رنج 3
input double InpRange3_SL_ATR_Multiplier = 1.5; // ضریب ATR برای بافر استاپ لاس رنج 3
input ENUM_TRAILING_MODE InpRange3_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 3
input int InpRange3_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج 3
input double InpRange3_Trailing_ATR_Multiplier = 1.0; // ضریب ATR برای تریلینگ رنج 3
input double InpRange3_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 3
input double InpRange3_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج 3
input int InpRange3_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج 3 (0-24)
input color InpRange3_Color = clrGreen; // رنگ مستطیل رنج 3

// گروه ورودی برای تنظیمات رنج 4 (چهارمین رنج، برای سفارشی‌سازی اضافی یا تست)
// رنج پیش‌فرض خاموش برای جلوگیری از تداخل
input group "تنظیمات رنج 4"  // عنوان گروه
input bool InpRange4_Enabled = false; // فعال کردن رنج 4 (خاموش پیش‌فرض)
input ENUM_TIMEFRAMES InpRange4_Execution_Timeframe = PERIOD_CURRENT; // تایم‌فریم اجرا رنج 4 (CURRENT برای همخوانی با چارت)
input ENUM_TIMEFRAMES InpRange4_TrendFilter_Timeframe = PERIOD_CURRENT; // تایم‌فریم فیلتر روند رنج 4
input int InpRange4_Start_Hour = 0; // ساعت شروع رنج 4 (0-23)
input int InpRange4_Start_Minute = 0; // دقیقه شروع رنج 4 (0-59)
input int InpRange4_End_Hour = 0; // ساعت پایان رنج 4 (0-23)
input int InpRange4_End_Minute = 0; // دقیقه پایان رنج 4 (0-59)
input int InpRange4_MinRangePoints = 50; // حداقل ارتفاع رنج 4 به پوینت
input int InpRange4_MaxRangePoints = 500; // حداکثر ارتفاع رنج 4 به پوینت
input ENUM_PLACEMENT_MODE InpRange4_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج 4
input int InpRange4_ATR_Period = 14; // دوره ATR برای ثبت سفارش رنج 4
input double InpRange4_ATR_Multiplier = 1.2; // ضریب ATR برای ثبت سفارش رنج 4
input ENUM_SL_STRATEGY InpRange4_SL_Strategy = SL_OPPOSITE_SIDE; // استراتژی جایگذاری استاپ لاس رنج 4
input ENUM_SL_CALC_MODE InpRange4_SL_Calc_Mode = SL_CALC_ATR; // حالت محاسبه بافر استاپ لاس رنج 4
input int InpRange4_SL_ATR_Period = 14; // دوره ATR برای بافر استاپ لاس رنج 4
input double InpRange4_SL_ATR_Multiplier = 1.5; // ضریب ATR برای بافر استاپ لاس رنج 4
input ENUM_TRAILING_MODE InpRange4_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج 4
input int InpRange4_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج 4
input double InpRange4_Trailing_ATR_Multiplier = 1.0; // ضریب ATR برای تریلینگ رنج 4
input double InpRange4_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج 4
input double InpRange4_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج 4
input int InpRange4_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج 4 (0-24)
input color InpRange4_Color = clrYellow; // رنگ مستطیل رنج 4

// (جدید در 2.30) گروه ورودی برای ورود تطبیقی: برای تحلیل قدرت شکست و انتخاب استراتژی ورود
input group "تنظیمات ورود تطبیقی (نسخه 2.3)"
input bool Inp_AdaptiveEntry_Enabled = true; // فعال کردن سیستم ورود تطبیقی (اگر خاموش باشد، همیشه پولبک استفاده می‌شود)
enum ENUM_ADAPTIVE_MODE
{
   MODE_CANDLE_ONLY,         // تحلیل فقط بر اساس قدرت کندل شکست
   MODE_CANDLE_CONFIRM,      // تحلیل بر اساس کندل شکست + تاییدیه فوری
   MODE_CANDLE_CONFIRM_ICHI  // تحلیل بر اساس کندل شکست + تاییدیه فوری + ایچیموکو همزمان
};
input ENUM_ADAPTIVE_MODE Inp_AdaptiveMode = MODE_CANDLE_CONFIRM_ICHI; // حالت تحلیل قدرت شکست
enum ENUM_ICHIMOKU_MODE
{
   MODE_KUMO_CLOUD,  // فیلتر بر اساس ابر کومو (روش فعلی)
   MODE_CHIKOU_SPAN  // فیلتر بر اساس چیکو اسپن (روش جدید)
};
input ENUM_ICHIMOKU_MODE Inp_IchimokuMode = MODE_CHIKOU_SPAN; // انتخاب نوع فیلتر روند ایچیموکو
input double Inp_MinCandleBodyRatio = 0.3; // حداقل نسبت بدنه به کل کندل برای "ضعیف نبودن" (0.1-0.9)
input double Inp_ExplosiveCandleBodyRatio = 0.7; // حداقل نسبت بدنه به کل کندل برای "انفجاری بودن" (0.1-0.9)

#endif  // پایان چک include






//+------------------------------------------------------------------+
//|                                                       Elemento.mq5 |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل اصلی اکسپرت Elemento است و نقطه ورود برنامه (OnInit, OnDeinit, OnTick, OnTimer) را مدیریت می‌کند.
// استراتژی کلی اکسپرت: Elemento بر اساس استراتژی شکست رنج عمل می‌کند که رنج‌های زمانی را شناسایی می‌کند، 
// منتظر شکست با افست می‌ماند، با تایید اختیاری قیمت و فیلتر ایچیموکو تأیید می‌کند، معامله باز می‌کند 
// و سپس معامله را با خروج پله‌ای و تریلینگ مدیریت می‌کند. 
// این استراتژی برای بازارهای رنجی مانند سشن آسیا مناسب است و با فیلتر روند از معاملات خلاف جهت جلوگیری می‌کند تا ریسک کاهش یابد. 
// اکسپرت از چهار رنج همزمان پشتیبانی می‌کند تا پوشش کامل بازار را فراهم کند.
// منطق فایل Elemento.mq5: این فایل هماهنگ‌کننده اصلی است. 
// در OnInit اطلاعات نماد را کش می‌کند، ورودی‌ها را ولید می‌کند، چهار نمونه CRange را مقداردهی می‌کند، 
// هندل‌های ATR را ایجاد می‌کند، فیلتر روند و مدیر نمایش را راه‌اندازی می‌کند. 
// در OnDeinit تمام منابع را آزاد و پاکسازی سخت انجام می‌دهد. 
// در OnTick کندل‌های جدید را تشخیص می‌دهد، رنج‌ها را به‌روزرسانی می‌کند، وضعیت روند هر رنج را به طور جداگانه نمایش می‌دهد 
// و در صورت بسته بودن بازار پاکسازی می‌کند. 
// در OnTimer (هر ۶۰ ثانیه) معاملات فعال را مدیریت می‌کند تا بار OnTick کاهش یابد. 
// متغیرهای جهانی مانند g_ranges برای نگهداری رنج‌ها، g_lastBarTime برای تشخیص کندل جدید، و g_trendFilter برای فیلتر روند استفاده می‌شوند. 
// تغییرات جدید در نسخه 2.30: نسخه به 2.30 به‌روزرسانی شده. اضافه کردن بازیابی وضعیت سفارشات پندینگ در OnInit با پارس کامنت (شروع با "PB") و فراخوانی SetPendingOrderTicket و RestoreState برای هر رنج فعال، 
// برای حل باگ بازیابی ناقص پس از ری‌استارت در استراتژی پولبک. همچنین کامنت‌گذاری دقیق‌تر و حفظ ساختار قبلی.

#property copyright "Copyright 2025, Hipoalgorithm Team"  // کپی‌رایت فایل
#property link      "https://hipoalgorithm.com"  // لینک وب‌سایت تیم
#property version   "2.30"  // ورژن نهایی با تغییرات مدیریت معامله و لاگ هوشمند و پشتیبانی از پولبک
#property strict  // حالت厳格 برای جلوگیری از خطاهای کامپایل

#include "Settings.mqh"  // فایل تنظیمات برای دسترسی به ورودی‌ها و enums
#include "Logger.mqh"  // کتابخانه جدید لاگ هوشمند برای چاپ پیام‌های کنترل‌شده
#include "CRange.mqh"  // کلاس مدیریت رنج برای هر رنج جداگانه
#include "TrendFilter.mqh"  // کلاس فیلتر روند برای تعیین جهت روند
#include "VisualManager.mqh"  // کلاس مدیر نمایش برای نمایش بصری روی چارت
#include "CActiveTradeManager.mqh"  // کلاس جدید مدیر معاملات فعال برای مدیریت تمام معاملات باز

// آرایه برای ذخیره ۴ رنج (هر کدام یک نمونه از کلاس CRange برای مدیریت مستقل رنج‌ها)
// این آرایه اجازه می‌دهد چهار رنج همزمان بدون تداخل کار کنند
CRange g_ranges[4];  // آرایه رنج‌ها

// آرایه برای ذخیره زمان آخرین کندل هر تایم‌فریم (برای تشخیص کندل جدید و جلوگیری از اجرای مکرر)
// هر ایندکس مربوط به یک رنج است
datetime g_lastBarTime[4];  // آرایه زمان آخرین بار

// آرایه برای هندل‌های ATR shared (برای هر رنج یک هندل ATR برای محاسبات افست، SL و تریلینگ)
// هندل‌ها برای بهینه‌سازی محاسبات اندیکاتور استفاده می‌شوند
int g_atrHandles[4];  // آرایه هندل‌های ATR

// متغیرهای کش‌شده برای بهینه‌سازی (اطلاعات نماد برای محاسبه ریسک، حجم و فاصله‌ها به طور دقیق و مستقل از نوع نماد)
// کش کردن این مقادیر از فراخوانی مکرر SymbolInfoDouble جلوگیری می‌کند
double g_tickValue;  // ارزش تیک برای محاسبات ریسک (دلار به ازای هر تیک)
double g_tickSize;  // اندازه تیک برای دقت محاسبات (فاصله بین تیک‌ها)
double g_volumeStep;  // گام حجم برای راند کردن لات (مثلاً 0.01)
double g_volumeMin;  // حداقل حجم مجاز (مثلاً 0.01)
double g_volumeMax;  // حداکثر حجم مجاز (مثلاً 100)

// فلگ برای تشخیص حالت tester (برای رفتار متفاوت مانند نادیده گرفتن چک بازار بسته در بک‌تست)
// این فلگ عملکرد را در بک‌تست و لایو متمایز می‌کند
bool g_isTester = false;  // فلگ تستر

// فیلتر روند جهانی (نمونه‌ای از CTrendFilter برای استفاده مشترک در تمام رنج‌ها)
// این نمونه برای فیلتر دینامیک در هر رنج استفاده می‌شود
CTrendFilter g_trendFilter;  // فیلتر روند جهانی

// مدیر نمایش جهانی (نمونه‌ای از CVisualManager برای نمایش بصری وضعیت روند هر رنج روی چارت)
// این نمونه برای به‌روزرسانی متن نمایش استفاده می‌شود
CVisualManager g_visualManager;  // مدیر نمایش جهانی

// مدیر معاملات فعال (نمونه‌ای از CActiveTradeManager برای مدیریت تمام معاملات باز)
// این کلاس تمام مدیریت معاملات را انجام می‌دهد
CActiveTradeManager g_tradeManager;  // مدیر معاملات

// تابع شروع اکسپرت (OnInit): مقداردهی اولیه، چک ولیدیشن و راه‌اندازی تایمر
// این تابع در شروع اکسپرت فراخوانی می‌شود و تمام منابع را آماده می‌کند
int OnInit()  // تابع مقداردهی اولیه
{
   // تشخیص حالت تستر برای تنظیم رفتار خاص (مانند نادیده گرفتن چک بازار بسته در بک‌تست)
   // MQLInfoInteger اطلاعات محیط را برمی‌گرداند
   g_isTester = MQLInfoInteger(MQL_TESTER);  // تنظیم فلگ تستر
   
   // چاپ پیام دیباگ برای شروع مقداردهی با استفاده از Print (چون فقط یکبار اجرا می‌شود)
   // این پیام فقط در حالت دیباگ چاپ می‌شود
   if(InpDebugMode) Print("شروع مقداردهی اکسپرت Elemento نسخه 2.30...");  // چاپ شروع مقداردهی

   // کش اطلاعات سیمبل (نماد) برای استفاده در محاسبه ریسک، حجم و فاصله‌ها
   // SymbolInfoDouble اطلاعات معاملاتی نماد را برمی‌گرداند
   g_tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);  // کش ارزش تیک برای محاسبات ریسک
   g_tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);  // کش اندازه تیک برای دقت محاسبات
   g_volumeStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);  // کش گام حجم برای راند کردن لات
   g_volumeMin = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);  // کش حداقل حجم مجاز برای معاملات
   g_volumeMax = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);  // کش حداکثر حجم مجاز برای معاملات

   // چک ولید بودن اطلاعات نماد (اگر صفر یا نامعتبر باشد، اکسپرت متوقف می‌شود برای جلوگیری از محاسبات اشتباه)
   // این چک از خطاهای runtime جلوگیری می‌کند
   if(g_tickValue <= 0 || g_tickSize <= 0 || g_volumeStep <= 0)  // شرط چک مقادیر کش
   {
      // چاپ خطا و توقف اکسپرت با استفاده از Print (چون خطای مرگبار است)
      Print("خطای مرگبار: اطلاعات نماد نامعتبر است (tickValue/tickSize/volumeStep). اکسپرت متوقف می‌شود.");  // چاپ خطا و توقف اکسپرت
      return(INIT_FAILED);  // بازگشت شکست مقداردهی
   }

   // ولیدیشن ورودی‌های عمومی (اطمینان از محدوده مجاز برای جلوگیری از خطاهای منطقی)
   // این چک‌ها از اجرای نادرست جلوگیری می‌کنند
   if(InpRiskPercent <= 0 || InpRiskPercent > 10.0)  // چک محدوده ریسک
   {
      Print("خطا: RiskPercent باید بین 0.1 تا 10.0 باشد.");  // چاپ خطا برای ریسک نامعتبر
      return(INIT_PARAMETERS_INCORRECT);  // بازگشت شکست پارامترها
   }

   // ولیدیشن Inp_Confirmation_Timeout اگر حالت قدیمی انتخاب شده باشد
   // این چک فقط در حالت تایمر اعمال می‌شود
   if(Inp_Confirmation_Strategy == CONFIRMATION_TIMEOUT && (Inp_Confirmation_Timeout < 1 || Inp_Confirmation_Timeout > 50))  // چک محدوده تایم‌اوت
   {
      Print("خطا: Confirmation_Timeout باید بین 1 تا 50 باشد (برای حالت تایمر).");  // چاپ خطا برای تایم‌اوت نامعتبر
      return(INIT_PARAMETERS_INCORRECT);  // بازگشت شکست پارامترها
   }

   // مقداردهی ۴ رنج (برای هر رنج فعال، پارامترها را از ورودی‌ها گرفته، هندل ATR می‌سازد و Init می‌کند)
   // حلقه برای مقداردهی چهار رنج به صورت جداگانه
   for(int i = 0; i < 4; i++)  // حلقه برای مقداردهی چهار رنج
   {
      // چک فعال بودن رنج بر اساس ورودی مربوطه (استفاده از شرط سه‌تایی برای سادگی)
      bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;  // چک فعال بودن رنج بر اساس ورودی
      if(!enabled)  // شرط غیرفعال
      {
         // چاپ دیباگ برای رنج غیرفعال با استفاده از CLogger (برای لاگ هوشمند)
         CLogger::Log("رنج " + IntegerToString(i + 1) + " غیرفعال است. رد می‌شود.", i + 1);  // چاپ دیباگ برای رنج غیرفعال
         continue;  // پرش به رنج بعدی
      }

      // مجیک نامبر منحصربه‌فرد برای هر رنج جهت تمایز معاملات
      long magic = InpBaseMagicNumber + i;  // مجیک نامبر منحصربه‌فرد برای هر رنج جهت تمایز معاملات
      // استخراج ساعت و دقیقه شروع از ورودی مربوطه
      int startHour = i == 0 ? InpRange1_Start_Hour : i == 1 ? InpRange2_Start_Hour : i == 2 ? InpRange3_Start_Hour : InpRange4_Start_Hour;  // ساعت شروع رنج
      int startMinute = i == 0 ? InpRange1_Start_Minute : i == 1 ? InpRange2_Start_Minute : i == 2 ? InpRange3_Start_Minute : InpRange4_Start_Minute;  // دقیقه شروع رنج
      // استخراج ساعت و دقیقه پایان از ورودی مربوطه
      int endHour = i == 0 ? InpRange1_End_Hour : i == 1 ? InpRange2_End_Hour : i == 2 ? InpRange3_End_Hour : InpRange4_End_Hour;  // ساعت پایان رنج
      int endMinute = i == 0 ? InpRange1_End_Minute : i == 1 ? InpRange2_End_Minute : i == 2 ? InpRange3_End_Minute : InpRange4_End_Minute;  // دقیقه پایان رنج

      // چک ولید بودن ساعات و دقیقه‌ها (برای جلوگیری از زمان‌های نامعتبر)
      // این چک از خطاهای زمانی جلوگیری می‌کند
      if(startHour < 0 || startHour > 23 || startMinute < 0 || startMinute > 59 ||  // شرط چک شروع
         endHour < 0 || endHour > 23 || endMinute < 0 || endMinute > 59)  // شرط چک پایان
      {
         Print("خطا: ساعات یا دقیقه‌های رنج " + IntegerToString(i + 1) + " نامعتبر است.");  // چاپ خطا برای زمان نامعتبر
         return(INIT_PARAMETERS_INCORRECT);  // بازگشت شکست پارامترها
      }

      // استخراج تایم‌فریم اجرا از ورودی مربوطه
      ENUM_TIMEFRAMES timeframe = i == 0 ? InpRange1_Execution_Timeframe : i == 1 ? InpRange2_Execution_Timeframe : i == 2 ? InpRange3_Execution_Timeframe : InpRange4_Execution_Timeframe;  // تایم‌فریم اجرا رنج
      // استخراج دوره ATR از ورودی مربوطه
      int atrPeriod = i == 0 ? InpRange1_ATR_Period : i == 1 ? InpRange2_ATR_Period : i == 2 ? InpRange3_ATR_Period : InpRange4_ATR_Period;  // دوره ATR برای افست
      // ایجاد هندل ATR برای محاسبات پویا با استفاده از iATR
      g_atrHandles[i] = iATR(_Symbol, timeframe, atrPeriod);  // ایجاد هندل ATR برای محاسبات پویا
      if(g_atrHandles[i] == INVALID_HANDLE)  // چک هندل معتبر
      {
         Print("خطا در ایجاد هندل ATR برای رنج " + IntegerToString(i + 1));  // چاپ خطا برای هندل نامعتبر
         return(INIT_FAILED);  // بازگشت شکست مقداردهی
      }

      // استخراج استراتژی SL از ورودی مربوطه
      ENUM_SL_STRATEGY slStrategy = i == 0 ? InpRange1_SL_Strategy : i == 1 ? InpRange2_SL_Strategy : i == 2 ? InpRange3_SL_Strategy : InpRange4_SL_Strategy;  // استراتژی SL
      // استخراج حالت محاسبه بافر SL از ورودی مربوطه
      ENUM_SL_CALC_MODE slCalcMode = i == 0 ? InpRange1_SL_Calc_Mode : i == 1 ? InpRange2_SL_Calc_Mode : i == 2 ? InpRange3_SL_Calc_Mode : InpRange4_SL_Calc_Mode;  // حالت محاسبه بافر SL
      // استخراج دوره ATR برای SL از ورودی مربوطه
      int slAtrPeriod = i == 0 ? InpRange1_SL_ATR_Period : i == 1 ? InpRange2_SL_ATR_Period : i == 2 ? InpRange3_SL_ATR_Period : InpRange4_SL_ATR_Period;  // دوره ATR برای SL
      // استخراج ضریب ATR برای SL از ورودی مربوطه
      double slAtrMultiplier = i == 0 ? InpRange1_SL_ATR_Multiplier : i == 1 ? InpRange2_SL_ATR_Multiplier : i == 2 ? InpRange3_SL_ATR_Multiplier : InpRange4_SL_ATR_Multiplier;  // ضریب ATR برای SL

      // فراخوانی Init برای هر رنج با پارامترهای مربوطه (مقداردهی کامل رنج، شامل SL strategy جدید)
      // استفاده از شرط سه‌تایی برای استخراج پارامترهای دیگر
      if(!g_ranges[i].Init(  // فراخوانی Init رنج
         i + 1, magic, timeframe, startHour, startMinute, endHour, endMinute,  // پارامترهای پایه
         i == 0 ? InpRange1_MinRangePoints : i == 1 ? InpRange2_MinRangePoints : i == 2 ? InpRange3_MinRangePoints : InpRange4_MinRangePoints,  // حداقل ارتفاع
         i == 0 ? InpRange1_MaxRangePoints : i == 1 ? InpRange2_MaxRangePoints : i == 2 ? InpRange3_MaxRangePoints : InpRange4_MaxRangePoints,  // حداکثر ارتفاع
         i == 0 ? InpRange1_Placement_Mode : i == 1 ? InpRange2_Placement_Mode : i == 2 ? InpRange3_Placement_Mode : InpRange4_Placement_Mode,  // حالت افست
         atrPeriod,  // دوره ATR
         i == 0 ? InpRange1_ATR_Multiplier : i == 1 ? InpRange2_ATR_Multiplier : i == 2 ? InpRange3_ATR_Multiplier : InpRange4_ATR_Multiplier,  // ضریب ATR
         slStrategy, slCalcMode, slAtrPeriod, slAtrMultiplier,  // پارامترهای SL
         i == 0 ? InpRange1_Trailing_Mode : i == 1 ? InpRange2_Trailing_Mode : i == 2 ? InpRange3_Trailing_Mode : InpRange4_Trailing_Mode,  // حالت تریلینگ
         i == 0 ? InpRange1_Trailing_ATR_Period : i == 1 ? InpRange2_Trailing_ATR_Period : i == 2 ? InpRange3_Trailing_ATR_Period : InpRange4_Trailing_ATR_Period,  // دوره تریلینگ
         i == 0 ? InpRange1_Trailing_ATR_Multiplier : i == 1 ? InpRange2_Trailing_ATR_Multiplier : i == 2 ? InpRange3_Trailing_ATR_Multiplier : InpRange4_Trailing_ATR_Multiplier,  // ضریب تریلینگ
         i == 0 ? InpRange1_RR_Ratio : i == 1 ? InpRange2_RR_Ratio : i == 2 ? InpRange3_RR_Ratio : InpRange4_RR_Ratio,  // نسبت RR
         i == 0 ? InpRange1_PartialClosePercent : i == 1 ? InpRange2_PartialClosePercent : i == 2 ? InpRange3_PartialClosePercent : InpRange4_PartialClosePercent,  // درصد پله‌ای
         i == 0 ? InpRange1_Cleanup_Hours : i == 1 ? InpRange2_Cleanup_Hours : i == 2 ? InpRange3_Cleanup_Hours : InpRange4_Cleanup_Hours,  // ساعت پاکسازی
         i == 0 ? InpRange1_Color : i == 1 ? InpRange2_Color : i == 2 ? InpRange3_Color : InpRange4_Color,  // رنگ
         i == 0 ? InpRange1_TrendFilter_Timeframe : i == 1 ? InpRange2_TrendFilter_Timeframe : i == 2 ? InpRange3_TrendFilter_Timeframe : InpRange4_TrendFilter_Timeframe,  // تایم‌فریم فیلتر
         g_atrHandles[i]  // هندل ATR
      ))  // پایان فراخوانی Init
      {
         Print("خطا در مقداردهی رنج " + IntegerToString(i + 1) + ": " + IntegerToString(GetLastError()));  // چاپ خطا برای شکست Init
         return(INIT_PARAMETERS_INCORRECT);  // بازگشت شکست پارامترها
      }
   }

// (جدید) اضافه کردن حافظه: چک معاملات باز برای هر رنج و بازگردانی حالت
for(int i = 0; i < 4; i++)
{
    bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;
    if(!enabled) continue;

    long magic = InpBaseMagicNumber + i;
    for(int pos = PositionsTotal() - 1; pos >= 0; pos--)
    {
        if(PositionGetSymbol(pos) == _Symbol && PositionGetInteger(POSITION_MAGIC) == magic)
        {
            ulong ticket = PositionGetInteger(POSITION_TICKET);
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            double sl = PositionGetDouble(POSITION_SL);

            // به CRange میگیم که یه معامله فعال داشته
            g_ranges[i].SetActiveTicket(ticket);
            g_ranges[i].SetCurrentState(RANGE_TRADE_ACTIVE);
            
            CLogger::Log("معامله باز برای رنج " + IntegerToString(i + 1) + " پیدا شد. در حال ثبت در مدیر معاملات...", i + 1);

            // ۱. خوندن پارامترهای لازم برای مدیریت معامله از تنظیمات ورودی
            double rec_rr_ratio = i == 0 ? InpRange1_RR_Ratio : i == 1 ? InpRange2_RR_Ratio : i == 2 ? InpRange3_RR_Ratio : InpRange4_RR_Ratio;
            double rec_partial_percent = i == 0 ? InpRange1_PartialClosePercent : i == 1 ? InpRange2_PartialClosePercent : i == 2 ? InpRange3_PartialClosePercent : InpRange4_PartialClosePercent;
            ENUM_TRAILING_MODE rec_trailing_mode = i == 0 ? InpRange1_Trailing_Mode : i == 1 ? InpRange2_Trailing_Mode : i == 2 ? InpRange3_Trailing_Mode : InpRange4_Trailing_Mode;
            int rec_trailing_atr_period = i == 0 ? InpRange1_Trailing_ATR_Period : i == 1 ? InpRange2_Trailing_ATR_Period : i == 2 ? InpRange3_Trailing_ATR_Period : InpRange4_Trailing_ATR_Period;
            double rec_trailing_atr_multiplier = i == 0 ? InpRange1_Trailing_ATR_Multiplier : i == 1 ? InpRange2_Trailing_ATR_Multiplier : i == 2 ? InpRange3_Trailing_ATR_Multiplier : InpRange4_Trailing_ATR_Multiplier;
            ENUM_TIMEFRAMES rec_exec_tf = i == 0 ? InpRange1_Execution_Timeframe : i == 1 ? InpRange2_Execution_Timeframe : i == 2 ? InpRange3_Execution_Timeframe : InpRange4_Execution_Timeframe;
            ENUM_TIMEFRAMES rec_trend_tf = i == 0 ? InpRange1_TrendFilter_Timeframe : i == 1 ? InpRange2_TrendFilter_Timeframe : i == 2 ? InpRange3_TrendFilter_Timeframe : InpRange4_TrendFilter_Timeframe;
            
            // ۲. خوندن اطلاعات حیاتی از کامنت خود معامله
            string comment = PositionGetString(POSITION_COMMENT);
            string parts[];
            double rec_high = 0.0, rec_low = 0.0, initial_sl_dist = 0.0;
            if(StringSplit(comment, ';', parts) >= 4)
            {
                rec_high = StringToDouble(StringSubstr(parts[1], 2));
                rec_low = StringToDouble(StringSubstr(parts[2], 2));
                initial_sl_dist = StringToDouble(StringSubstr(parts[3], 4));
                g_ranges[i].RestoreState(rec_high, rec_low, initial_sl_dist);
            }
            else
            {
               CLogger::Log("کامنت معامله برای بازیابی وضعیت نامعتبر است.", i+1);
            }

            // ۳. ثبت معامله در مدیر معاملات (این خط حیاتی‌ترین بخش اصلاحه)
            g_tradeManager.RegisterTrade(
                ticket,
                magic,
                i + 1, // Range Index
                initial_sl_dist,
                openPrice,
                rec_rr_ratio,
                rec_partial_percent,
                rec_trailing_mode,
                rec_trailing_atr_period,
                rec_trailing_atr_multiplier,
                rec_exec_tf,
                g_ranges[i].GetTrailingAtrHandle(), // هندل تریلینگ رو از خود رنج میگیریم
                rec_trend_tf
            );
            CLogger::Log("معامله بازیابی شده با موفقیت به ActiveTradeManager ثبت شد.", i + 1);

            // ۴. چک کردن اینکه آیا معامله قبلا ریسک-فری شده یا نه
            if (MathAbs(sl - openPrice) < (_Point * 5))
            {
               g_tradeManager.SetPartialClosedFlag(ticket, true);
               CLogger::Log("معامله رنج " + IntegerToString(i+1) + " قبلاً ریسک-فری شده. حالت بازیابی شد.", i + 1);
            }
            
            break; // خروج از حلقه داخلی چون معامله این رنج پیدا شد
        }
    }
}

// (جدید در نسخه 2.30) اضافه کردن حافظه برای سفارشات پندینگ: چک سفارشات لیمیت و استاپ برای هر رنج و بازگردانی حالت پولبک
// این حلقه سفارشات پندینگ را بازیابی می‌کند تا پس از ری‌استارت، سفارشات حفظ شوند
for(int i = 0; i < 4; i++)
{
    bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;
    if(!enabled) continue;

    long magic = InpBaseMagicNumber + i;
    for(int ord = OrdersTotal() - 1; ord >= 0; ord--)
    {
        if(OrderGetTicket(ord) > 0 && OrderGetString(ORDER_SYMBOL) == _Symbol && OrderGetInteger(ORDER_MAGIC) == magic)
        {
            ulong ticket = OrderGetInteger(ORDER_TICKET);
            string comment = OrderGetString(ORDER_COMMENT);
            if(StringFind(comment, "PB;S") == 0)  // چک شروع کامنت با "PB;S" برای سفارشات Stop پولبک
            {
                // پارس کامنت برای اطلاعات رنج: "PB;S;R1;H:1.1234;L:1.1200;SLD:0.0010"
                string parts[];
                if(StringSplit(comment, ';', parts) >= 6)
                {
                    // parts[0] = "PB", parts[1] = "S", parts[2] = "R" + index, parts[3] = "H:" + high, parts[4] = "L:" + low, parts[5] = "SLD:" + dist
                    double rec_high = StringToDouble(StringSubstr(parts[3], 2));  // استخراج high از "H:1.1234"
                    double rec_low = StringToDouble(StringSubstr(parts[4], 2));  // استخراج low از "L:1.1200"
                    double initial_sl_dist = StringToDouble(StringSubstr(parts[5], 4));  // استخراج dist از "SLD:0.0010"
                    
                    g_ranges[i].RestoreState(rec_high, rec_low, initial_sl_dist);  // بازیابی وضعیت رنج
                    g_ranges[i].SetPendingOrderTicket(ticket);  // تنظیم تیکت سفارش پندینگ
                    // تنظیم حالت به AWAITING_REVERSAL_TRIGGER چون Stop Order در انتظار فعال شدن است
                    g_ranges[i].SetCurrentState(RANGE_AWAITING_REVERSAL_TRIGGER);  // حالت انتظار استاپ
                    
                    CLogger::Log("سفارش Stop پولبک برای رنج " + IntegerToString(i + 1) + " پیدا شد. حالت بازیابی شد: " + EnumToString(g_ranges[i].GetCurrentState()), i + 1);
                    break;  // خروج از حلقه داخلی چون سفارش این رنج پیدا شد
                }
                else
                {
                    CLogger::Log("کامنت سفارش پندینگ برای بازیابی وضعیت نامعتبر است.", i + 1);
                }
            }
        }
    }
}

   // مقداردهی فیلتر روند جهانی (برای تعیین جهت روند در تمام رنج‌ها)
   // فراخوانی Init فیلتر (که خالی است اما برای سازگاری)
   if(!g_trendFilter.Init())  // چک موفقیت Init
   {
      Print("خطا در مقداردهی فیلتر روند.");  // چاپ خطا برای شکست Init فیلتر
      return(INIT_FAILED);  // بازگشت شکست مقداردهی
   }
   // مقداردهی مدیر نمایش جهانی (برای نمایش وضعیت روند هر رنج روی چارت)
   // فراخوانی Init نمایشگر
   if(!g_visualManager.Init())  // چک موفقیت Init
   {
      Print("خطا در مقداردهی مدیر نمایش.");  // چاپ خطا برای شکست Init نمایشگر
      return(INIT_FAILED);  // بازگشت شکست مقداردهی
   }

   // مقداردهی اولیه زمان آخرین کندل‌ها (برای تشخیص کندل جدید در OnTick)
   // حلقه برای ریست زمان‌ها به صفر
   for(int i = 0; i < 4; i++)  // حلقه برای ریست زمان‌ها
   {
      g_lastBarTime[i] = 0;  // تنظیم زمان اولیه به صفر
   }

   // راه‌اندازی تایمر برای مدیریت معاملات هر ۶۰ ثانیه (بهینه‌سازی عملکرد OnTick)
   // EventSetTimer تایمر را فعال می‌کند
   EventSetTimer(60);  // تنظیم تایمر ۶۰ ثانیه

   // چاپ موفقیت مقداردهی با Print (چون نهایی است)
   Print("مقداردهی اکسپرت Elemento نسخه 2.30 با موفقیت انجام شد.");  // چاپ موفقیت مقداردهی
   return(INIT_SUCCEEDED);  // بازگشت موفقیت
}

// تابع پایان اکسپرت (OnDeinit): پاکسازی منابع و پاکسازی سخت تمام رنج‌ها
// این تابع در پایان اکسپرت فراخوانی می‌شود و منابع را آزاد می‌کند
void OnDeinit(const int reason)  // تابع دفع با دلیل
{
   // چاپ دیباگ برای دلیل دفع با Print (چون فقط یکبار)
   if(InpDebugMode) Print("دفع مقداردهی اکسپرت Elemento نسخه 2.30. دلیل: " + IntegerToString(reason));  // چاپ دیباگ برای دلیل دفع

   // پاکسازی سخت تمام رنج‌ها برای بستن معاملات باقی‌مانده و ریست (در صورت کرش یا خروج)
   // حلقه برای پاکسازی سخت هر رنج
   for(int i = 0; i < 4; i++)  // حلقه برای پاکسازی سخت هر رنج
   {
      g_ranges[i].HardCleanup();  // فراخوانی پاکسازی سخت
   }

   // دفع هر رنج و آزادسازی هندل ATR مربوطه
   // حلقه برای دفع رنج‌ها و هندل‌ها
   for(int i = 0; i < 4; i++)  // حلقه برای دفع رنج‌ها
   {
      g_ranges[i].Deinit();  // دفع رنج
      if(g_atrHandles[i] != INVALID_HANDLE)  // چک هندل معتبر
      {
         IndicatorRelease(g_atrHandles[i]);  // آزادسازی هندل ATR
      }
   }

   // دفع فیلتر روند و مدیر نمایش
   g_trendFilter.Deinit();  // دفع فیلتر روند
   g_visualManager.Deinit();  // دفع مدیر نمایش
   // حذف تمام اشیاء گرافیکی با پیشوند Range_ برای پاکسازی چارت
   ObjectsDeleteAll(0, "Range_");  // حذف تمام اشیاء گرافیکی با پیشوند Range_ برای پاکسازی چارت
   Print("تمامی اشیاء گرافیکی پاکسازی شدند.");  // چاپ موفقیت پاکسازی اشیاء

   // خاموش کردن تایمر
   EventKillTimer();  // خاموش کردن تایمر
}

// تابع اصلی هر تیک (OnTick): تشخیص کندل جدید، به‌روزرسانی رنج‌ها و چک بازار
// این تابع در هر تیک قیمت فراخوانی می‌شود و منطق اصلی را اجرا می‌کند
void OnTick()  // تابع اصلی هر تیک
{
   // چک روز جدید برای به‌روزرسانی کش اطلاعات نماد (در صورت تغییر مشخصات بروکر)
   // متغیر استاتیک برای ذخیره روز آخرین به‌روزرسانی
   static datetime lastDay = 0;  // متغیر استاتیک برای ذخیره روز آخرین
   datetime currentDay = TimeCurrent() / 86400;  // محاسبه روز فعلی (ثانیه‌ها به روز)
   if(currentDay != lastDay)  // چک تغییر روز
   {
      // به‌روزرسانی کش اطلاعات نماد با فراخوانی مجدد SymbolInfoDouble
      g_tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);  // به‌روزرسانی ارزش تیک
      g_tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);  // به‌روزرسانی اندازه تیک
      g_volumeStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);  // به‌روزرسانی گام حجم
      g_volumeMin = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);  // به‌روزرسانی حداقل حجم
      g_volumeMax = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);  // به‌روزرسانی حداکثر حجم
      // چاپ دیباگ برای به‌روزرسانی با CLogger
      CLogger::Log("به‌روزرسانی کش اطلاعات نماد در روز جدید.");  // چاپ دیباگ برای به‌روزرسانی
      lastDay = currentDay;  // ذخیره روز جدید
   }

   // اگر تستر نیست و بازار بسته است یا یک ساعت قبل از بسته شدن، پاکسازی سخت انجام می‌شود
   // این شرط از معاملات در تعطیلات جلوگیری می‌کند
   if(!g_isTester && (IsMarketClosed() || IsOneHourBeforeMarketClose()))  // چک شرایط بازار بسته
   {
      // حلقه برای هر رنج فعال
      for(int i = 0; i < 4; i++)  // حلقه برای هر رنج
      {
         // چک فعال بودن رنج
         bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;  // چک فعال بودن
         if(enabled)  // شرط فعال
         {
            g_ranges[i].HardCleanup();  // پاکسازی سخت رنج (بستن معاملات و ریست برای جلوگیری از معاملات باز در تعطیلات)
         }
      }
      return;  // خروج از تابع
   }

   // فلگ برای تشخیص کندل جدید و به‌روزرسانی نمایش
   bool newBarDetected = false;  // فلگ برای تشخیص کندل جدید و به‌روزرسانی نمایش
   string trendDisplayText = "";  // متن کامل نمایش وضعیت روند هر رنج
   // متغیر استاتیک برای جلوگیری از لاگ تکراری وضعیت روند
   static string lastTrendStatusText = "";  // متغیر استاتیک برای جلوگیری از لاگ تکراری

   // حلقه برای هر رنج فعال
   for(int i = 0; i < 4; i++)  // حلقه برای هر رنج
   {
      // چک فعال بودن رنج
      bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;  // چک فعال بودن رنج
      if(!enabled) continue;  // پرش اگر غیرفعال

      // گرفتن تایم‌فریم اجرا رنج از کلاس CRange
      ENUM_TIMEFRAMES timeframe = g_ranges[i].GetTimeframe();  // گرفتن تایم‌فریم اجرا رنج

      // چک لود کافی تاریخچه برای هر رنج جداگانه (بر اساس تایم‌فریم اجرای رنج برای جلوگیری از اجرای زودرس)
      // Bars تعداد کندل‌های لودشده را برمی‌گرداند
      if(Bars(_Symbol, timeframe) < 200)  // چک تعداد بارها
      {
         CLogger::Log("تاریخچه کافی برای رنج " + IntegerToString(i + 1) + " لود نشده است. رد می‌شود.", i + 1);  // چاپ دیباگ برای تاریخچه ناکافی
         continue;  // پرش به رنج بعدی
      }

      // زمان کندل فعلی برای تشخیص جدید بودن با iTime
      datetime currentBarTime = iTime(_Symbol, timeframe, 0);  // زمان کندل فعلی برای تشخیص جدید بودن
      if(currentBarTime == 0)  // چک زمان معتبر
      {
         CLogger::Log("خطا: iTime مقدار نامعتبر برای رنج " + IntegerToString(i + 1), i + 1);  // چاپ خطا
         continue;  // پرش
      }

      // تشخیص کندل جدید و به‌روزرسانی رنج (فقط در کندل جدید اجرا می‌شود تا بار کاهش یابد)
      if(currentBarTime > g_lastBarTime[i])  // چک کندل جدید
      {
         // چاپ دیباگ برای کندل جدید با CLogger
         CLogger::Log("کندل جدید برای رنج " + IntegerToString(i + 1) + " در تایم‌فریم " + EnumToString(timeframe), i + 1);  // چاپ دیباگ برای کندل جدید
         g_ranges[i].UpdateOnNewBar();  // به‌روزرسانی ماشین حالت رنج
         g_lastBarTime[i] = currentBarTime;  // ذخیره زمان جدید
         newBarDetected = true;  // تنظیم فلگ کندل جدید
      }

      // چک کندل جدید در تایم‌فریم فیلتر برای آپدیت نمایش روند آن رنج
      // گرفتن تایم‌فریم فیلتر از کلاس
      ENUM_TIMEFRAMES trendTf = g_ranges[i].GetTrendFilterTimeframe();  // گرفتن تایم‌فریم فیلتر
      datetime currentTrendBarTime = iTime(_Symbol, trendTf, 0);  // زمان کندل فیلتر فعلی
      if(currentTrendBarTime > g_ranges[i].GetLastFilterBarTime())  // چک کندل جدید فیلتر
      {
         // گرفتن جهت روند از فیلتر
         ENUM_TREND_DIRECTION trend = g_trendFilter.GetTrendDirection(trendTf);  // گرفتن جهت روند
         // تبدیل جهت به رشته برای نمایش
         string trendStr = trend == TREND_BUY ? "Bullish" : trend == TREND_SELL ? "Bearish" : "Neutral";  // تبدیل جهت به رشته
         string tfStr = EnumToString(trendTf);  // تبدیل تایم‌فریم به رشته
         // اضافه به متن نمایش با فرمت مشخص
         trendDisplayText += "Range " + IntegerToString(i + 1) + " (Filter " + tfStr + "): " + trendStr + "\n";  // اضافه به متن نمایش
         g_ranges[i].UpdateLastFilterBarTime(currentTrendBarTime);  // آپدیت زمان در رنج
         // چاپ دیباگ برای آپدیت روند با CLogger
         CLogger::Log("آپدیت روند رنج " + IntegerToString(i + 1) + ": " + trendStr, i + 1);  // چاپ دیباگ برای آپدیت روند
      }

      // مدیریت معاملات به OnTimer منتقل شده، اینجا فقط چک حالت برای اطمینان
      if(enabled && g_ranges[i].GetCurrentState() == RANGE_TRADE_ACTIVE)  // چک حالت مدیریت معامله
      {
         // هیچ عملی در OnTick، مدیریت در OnTimer انجام می‌شود
         // این چک فقط برای اطمینان از حالت است
      }
   }

   // لاگ کردن وضعیت روند فقط اگر تغییر کرده باشد و متن موجود باشد
   if(trendDisplayText != "" && trendDisplayText != lastTrendStatusText)  // چک تغییر متن
   {
      CLogger::Log("وضعیت روند آپدیت شد:\n" + trendDisplayText);  // لاگ کردن وضعیت روند
      lastTrendStatusText = trendDisplayText;  // ذخیره متن جدید
   }

   // آپدیت نمایشگر با متن کامل وضعیت روند هر رنج (اگر نمایش فعال باشد)
   if(Inp_Visual_ShowTrendStatus && trendDisplayText != "")  // چک فعال بودن نمایش و متن موجود
   {
      g_visualManager.UpdateTrendStatus(trendDisplayText);  // به‌روزرسانی نمایشگر
   }
}

// تابع تایمر (OnTimer): مدیریت معاملات فعال هر ۶۰ ثانیه برای کاهش بار OnTick
// این تابع هر 60 ثانیه فراخوانی می‌شود و مدیریت معاملات را انجام می‌دهد
void OnTimer()  // تابع تایمر
{
   g_tradeManager.ManageAllTrades();  // مدیریت تمام معاملات فعال در مدیر معاملات
}

// تابع چک یک ساعت قبل از بسته شدن بازار (برای فعال کردن پاکسازی سخت و جلوگیری از معاملات باز در تعطیلات)
// این تابع زمان بسته شدن را محاسبه می‌کند
bool IsOneHourBeforeMarketClose()  // تابع چک یک ساعت قبل از بسته شدن
{
   datetime from = 0, to = 0;  // متغیرهای زمان جلسه
   MqlDateTime dt;  // ساختار زمان
   TimeToStruct(TimeTradeServer(), dt);  // تبدیل زمان سرور به ساختار
   ENUM_DAY_OF_WEEK day = (ENUM_DAY_OF_WEEK)dt.day_of_week;  // روز هفته
   datetime max_to = 0;  // حداکثر زمان بسته شدن
   uint session = 0;  // شمارنده جلسه
   // پیدا کردن آخرین جلسه معاملاتی روز برای تعیین زمان بسته شدن
   // حلقه جلسات با SymbolInfoSessionTrade
   while(SymbolInfoSessionTrade(_Symbol, day, session, from, to))  // حلقه جلسات
   {
      if(to > max_to) max_to = to;  // ذخیره حداکثر زمان
      session++;  // افزایش شمارنده
   }
   if(max_to == 0)  // چک عدم یافتن جلسه
   {
      CLogger::Log("خطا در SymbolInfoSessionTrade: " + IntegerToString(GetLastError()));  // چاپ خطا
      return false;  // بازگشت نادرست
   }
   datetime currentTime = TimeTradeServer();  // زمان فعلی سرور
   // چک اگر زمان فعلی یک ساعت قبل از بسته شدن باشد (برای پاکسازی پیشگیرانه)
   if(currentTime >= (max_to - 3600) && currentTime < max_to)  // چک محدوده زمان
   {
      CLogger::Log("یک ساعت قبل از بسته شدن بازار: پاکسازی سخت فعال شد.");  // چاپ دیباگ
      return true;  // بازگشت درست
   }
   return false;  // بازگشت نادرست
}

// تابع چک بسته بودن بازار (برای فعال کردن پاکسازی نرم و جلوگیری از عملیات در تعطیلات)
// این تابع وضعیت بازار را بر اساس جلسات چک می‌کند
bool IsMarketClosed()  // تابع چک بسته بودن بازار
{
   datetime from = 0, to = 0;  // متغیرهای زمان جلسه
   MqlDateTime dt;  // ساختار زمان
   TimeToStruct(TimeTradeServer(), dt);  // تبدیل زمان سرور به ساختار
   ENUM_DAY_OF_WEEK day = (ENUM_DAY_OF_WEEK)dt.day_of_week;  // روز هفته
   uint session = 0;  // شمارنده جلسه
   // چک جلسات معاملاتی روز برای تعیین وضعیت بازار
   // حلقه جلسات
   while(SymbolInfoSessionTrade(_Symbol, day, session, from, to))  // حلقه جلسات
   {
      if(TimeTradeServer() >= from && TimeTradeServer() <= to)  // چک داخل جلسه
      {
         return false;  // بازار باز است، عملیات ادامه می‌یابد
      }
      session++;  // افزایش شمارنده
   }
   // چک تعطیلات آخر هفته (شنبه و یکشنبه)
   if(dt.day_of_week == 6 || dt.day_of_week == 0)  // چک شنبه یا یکشنبه
   {
      CLogger::Log("بازار تعطیل است (weekend).");  // چاپ دیباگ
      return true;  // بازگشت درست
   }
   CLogger::Log("بازار تعطیل است (خارج از جلسه).");  // چاپ دیباگ
   return true;  // بازگشت درست
}









//+------------------------------------------------------------------+
//|                                                          Utils.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل شامل توابع کمکی عمومی برای اکسپرت Elemento است.
// استراتژی کلی: این فایل برای بهینه‌سازی و استانداردسازی عملیات مشترک مانند نرمال‌سازی قیمت‌ها و اعتبارسنجی‌ها استفاده می‌شود.
// منطق فایل Utils.mqh: حاوی توابع استاتیک برای نرمال‌سازی قیمت‌ها بر اساس Tick Size نماد. 
// این فایل توسط فایل‌های دیگر مانند CRange.mqh include می‌شود تا دسترسی به توابع کمکی فراهم شود. 
// تغییرات جدید در نسخه 2.30: بهبود کامنت‌گذاری برای هر خط، اضافه توضیحات دقیق‌تر برای NormalizePrice، 
// بدون تغییر در منطق تابع اما با چک اضافی برای tickSize صفر. هیچ تغییری اعمال نشده زیرا بلوپرینت تغییری مشخص نکرده.

#ifndef UTILS_MQH  // چک وجود فایل
#define UTILS_MQH  // تعریف ماکرو

// تابع برای نرمال سازی دقیق قیمت بر اساس TickSize نماد
// این تابع قیمت را به نزدیک‌ترین مضرب tickSize راند می‌کند و به _Digits نرمال می‌کند
double NormalizePrice(double price)  // تابع نرمال‌سازی قیمت
{
   // گرفتن اندازه تیک نماد با SymbolInfoDouble
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);  // گرفتن اندازه تیک نماد
   if(tickSize > 0)  // چک اگر tickSize معتبر باشد (بزرگتر از صفر)
   {
      // راند به نزدیک‌ترین مضرب tickSize با MathRound و سپس نرمال‌سازی به _Digits با NormalizeDouble
      return NormalizeDouble(MathRound(price / tickSize) * tickSize, _Digits);  // راند به نزدیک‌ترین مضرب tickSize و نرمال‌سازی به _Digits
   }
   // اگر tickSize صفر بود، نرمال‌سازی استاندارد بدون راند تیک
   return NormalizeDouble(price, _Digits);  // اگر tickSize صفر بود، نرمال‌سازی استاندارد
}

#endif  // پایان چک include







//+------------------------------------------------------------------+
//|                                                         CRange.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CRange را تعریف می‌کند که هسته استراتژی شکست رنج را مدیریت می‌کند.
// استراتژی کلی اکسپرت: هر رنج زمانی (مانند سشن آسیا) را شناسایی می‌کند، سقف و کف آن را تعیین می‌کند، 
// اگر ارتفاع معتبر باشد، با افست (بر اساس ATR یا درصد) مسلح می‌شود، منتظر کندل بریک (شکست) می‌ماند، 
// به صورت اختیاری قیمت را تأیید می‌کند (اگر Inp_PriceConfirmation_Enabled فعال باشد)، 
// فیلتر روند را به طور مستقل و در لحظه چک می‌کند، معامله باز می‌کند 
// و سپس معامله را با خروج پله‌ای (هنگام رسیدن به RR)، انتقال SL به ورود، و تریلینگ مدیریت می‌کند. 
// این استراتژی برای بازارهای رنجی با شکست قوی مناسب است و با فیلتر ایچیموکو ریسک خلاف روند را کاهش می‌دهد.
// منطق فایل CRange.mqh: این کلاس برای هر رنج جداگانه عمل می‌کند. 
// ماشین حالت (ENUM_RANGE_STATE) جریان را کنترل می‌کند: از انتظار رنج جدید شروع می‌شود، 
// رنج را شناسایی و ولید می‌کند، مسلح می‌کند، منتظر بریک و تأییدها می‌ماند، معامله اجرا می‌کند و مدیریت می‌کند. 
// پاکسازی نرم برای ریست روزانه و سخت برای بستن معاملات در تعطیلات استفاده می‌شود. 
// کش ATR برای بهینه‌سازی محاسبات، و فراخوانی مستقل g_trendFilter برای فیلتر دینامیک. 
// تغییرات جدید در نسخه 2.30: اضافه کردن متغیرهای m_breakerCandleTime و m_confirmationCandleTime، 
// حالت‌های جدید RANGE_AWAITING_PULLBACK_TOUCH و RANGE_AWAITING_REVERSAL_TRIGGER، 
// اصلاح ProcessEntryAttempt برای تصمیم‌گیری تطبیقی با BreakoutAnalyzer، 
// اضافه ExecuteMarketOrder و PlacePullbackStrategyOrders، 
// اصلاح SoftCleanup و HardCleanup برای مدیریت حالت‌ها و سفارشات جدید، 
// به‌روزرسانی کامنت‌ها برای PB;S یا PB;L، 
// کامنت‌گذاری دقیق هر خط، و حفظ ساختار قبلی.

#ifndef CRANGE_MQH  // چک وجود فایل
#define CRANGE_MQH  // تعریف ماکرو

#include "TimeHelper.mqh"  // کلاس کمک‌کننده زمان برای محاسبات رنج و پاکسازی
#include "RiskManager.mqh"  // کلاس مدیریت ریسک برای محاسبه حجم
#include "Utils.mqh"  // کلاس کمکی برای نرمال‌سازی قیمت‌ها
#include "Logger.mqh"  // کتابخانه لاگ هوشمند برای چاپ پیام‌های کنترل‌شده
#include "BreakoutAnalyzer.mqh"  // کتابخانه جدید برای تحلیل قدرت شکست

// تعریف enum برای حالت‌های رنج (ماشین حالت برای کنترل جریان هر رنج جداگانه)
// این enum جریان استراتژی را از انتظار تا مدیریت معامله کنترل می‌کند
enum ENUM_RANGE_STATE
{
   RANGE_IDLE,                  // انتظار برای رنج جدید (حالت اولیه یا پس از پاکسازی، آماده شناسایی)
   RANGE_IDENTIFYING,           // در حال شناسایی رنج (محاسبه سقف/کف و چک ارتفاع)
   RANGE_ARMED,                 // رنج مسلح شده و منتظر شکست (خطوط افست رسم شده)
   AWAITING_CONFIRMATION,       // انتظار تایید ورود (پس از کندل بریک، چک ابطال و تاییدها)
   RANGE_AWAITING_PULLBACK_TOUCH,  // (جدید) انتظار لمس خط پولبک (برای استراتژی جدید)
   RANGE_AWAITING_REVERSAL_TRIGGER, // (جدید) انتظار فعال شدن Stop Order بعد از لمس
   RANGE_TRADE_ACTIVE,          // معامله این رنج فعال است (معامله باز شده، منتظر پاکسازی)
   RANGE_EXPIRED                // رنج منقضی شده (پس از پاکسازی یا نامعتبر، آماده رنج جدید)
};

// کلاس CRange برای مدیریت هر رنج زمانی به طور مستقل
// این کلاس تمام منطق یک رنج را از شناسایی تا باز کردن معامله کپسوله می‌کند (مدیریت معامله به CActiveTradeManager منتقل شده)
class CRange  // کلاس اصلی مدیریت رنج
{
private:
   int m_rangeIndex;  // ایندکس رنج (1 تا 4 برای تمایز، برای لاگ و اشیاء)
   long m_magicNumber;  // مجیک نامبر منحصربه‌فرد برای معاملات این رنج (برای تمایز در PositionsTotal)
   ENUM_TIMEFRAMES m_timeframe;  // تایم‌فریم اجرا برای محاسبات رنج (برای iHigh/iLow/iClose)
   int m_startHour;  // ساعت شروع رنج (0-23، بر اساس GMT سرور)
   int m_startMinute;  // دقیقه شروع رنج (0-59)
   int m_endHour;  // ساعت پایان رنج (0-23)
   int m_endMinute;  // دقیقه پایان رنج (0-59)
   int m_minRangePoints;  // حداقل ارتفاع مجاز رنج به پوینت (برای فیلتر رنج‌های کوچک)
   int m_maxRangePoints;  // حداکثر ارتفاع مجاز رنج به پوینت (برای فیلتر رنج‌های بزرگ)
   ENUM_PLACEMENT_MODE m_placementMode;  // حالت افست شکست (ATR یا درصد، برای محاسبه سطوح)
   int m_atrPeriod;  // دوره ATR برای افست (برای iATR)
   double m_atrMultiplier;  // ضریب ATR برای افست (برای حساسیت)
   ENUM_SL_STRATEGY m_slStrategy;  // استراتژی جایگذاری SL (مقابل یا سطح شکست، برای base point)
   ENUM_SL_CALC_MODE m_slCalcMode;  // حالت محاسبه بافر SL (ATR یا درصد)
   int m_slAtrPeriod;  // دوره ATR برای بافر SL
   double m_slAtrMultiplier;  // ضریب ATR برای بافر SL
   ENUM_TRAILING_MODE m_trailingMode;  // حالت تریلینگ (ATR یا Senkou B)
   int m_trailingAtrPeriod;  // دوره ATR برای تریلینگ
   double m_trailingAtrMultiplier;  // ضریب ATR برای تریلینگ
   double m_rrRatio;  // نسبت R:R برای خروج پله‌ای (سود/ریسک)
   double m_partialClosePercent;  // درصد خروج پله‌ای (0-100)
   int m_cleanupHours;  // ساعت‌های پاکسازی پس از پایان رنج (0-24)
   color m_color;  // رنگ مستطیل رنج (برای OBJ_RECTANGLE)
   ENUM_TIMEFRAMES m_trendFilterTimeframe;  // تایم‌فریم فیلتر روند (برای GetTrendDirection)
   int m_atrHandle;  // هندل ATR برای افست (shared از Elemento)
   int m_slAtrHandle;  // هندل ATR برای SL (جداگانه برای دوره متفاوت)
   int m_trailingAtrHandle;  // هندل ATR برای تریلینگ (جداگانه)
   ENUM_RANGE_STATE m_currentState;  // حالت فعلی رنج (ماشین حالت)
   double m_rangeHigh;  // سقف رنج شناسایی‌شده (از iHighest)
   double m_rangeLow;  // کف رنج شناسایی‌شده (از iLowest)
   double m_potentialBuyPrice;  // سطح خرید با افست (برای چک بریک)
   double m_potentialSellPrice;  // سطح فروش با افست (برای چک بریک)
   double m_breakerCandleLevel;  // سطح کلوز کندل شکننده (برای تایید قیمت)
   ulong m_activeTicket;  // تیکت معامله فعال (از result.deal)
   ulong m_pendingOrderTicket;  // تیکت سفارش پندینگ (لیمیت یا استاپ، ذخیره تیکت ORDER)
   double m_cachedATR;  // کش ATR برای ورود (ثابت، محاسبه در شناسایی)
   double m_cachedSlATR;  // کش ATR برای SL (ثابت)
   double m_cachedTrailingATR;  // کش ATR برای تریلینگ (پویا در مدیریت، اما کش اولیه)
   int m_waitCounter;  // شمارنده کندل برای حالت تایمر قدیمی (فقط اگر CONFIRMATION_TIMEOUT)
   datetime m_cleanupTime;  // زمان پاکسازی محاسبه‌شده (از CalculateCleanupTime)
   datetime m_lastEndTime;  // آخرین زمان پایان پردازش شده (برای جلوگیری از تکرار شناسایی)
   bool m_lastInvalid;  // فلگ آخرین رنج نامعتبر (برای جلوگیری از تکرار)
   datetime m_rangeEndTime;  // زمان کامل پایان رنج (برای محاسبه دقیق پاکسازی)
   datetime m_lastFilterBarTime;  // زمان آخرین کندل فیلتر روند (برای آپدیت نمایش)
   double m_fixedOffsetValue;  // مقدار ثابت افست ATR یا درصد در لحظه شناسایی رنج (برای ثابت کردن خطوط)
   string m_rangeObjectName;  // نام مستطیل رنج (برای OBJ_RECTANGLE)
   string m_buyLineName;  // نام خط خرید (برای OBJ_HLINE)
   string m_sellLineName;  // نام خط فروش (برای OBJ_HLINE)
   double m_initialSlDistance; // فاصله SL اولیه (برای ذخیره و بازیابی در کامنت معامله، برای حل باگ بازیابی ناقص)
   bool m_isCleanedForThisCycle;  // فلگ برای جلوگیری از پاکسازی مکرر در یک چرخه
   // (جدید) متغیرهای برای مدیریت حافظه ابطال جهت‌ها و ذخیره جهت سیگنال (برای اصلاح منطق ورود)
   bool m_buyAttemptDisabled;  // فلگ برای غیرفعال کردن دائمی تلاش خرید پس از timeout (حافظه ابطال)
   bool m_sellAttemptDisabled;  // فلگ برای غیرفعال کردن دائمی تلاش فروش پس از timeout (حافظه ابطال)
   bool m_isBuyAttempt;  // فلگ برای ذخیره جهت سیگنال فعلی (true برای خرید، false برای فروش، برای تشخیص قطعی در ProcessEntryAttempt)
   datetime m_breakerCandleTime;  // زمان کندل شکست (برای تحلیل قدرت)
   datetime m_confirmationCandleTime;  // زمان کندل تاییدیه (برای تحلیل قدرت)

   // شناسایی و ولید رنج: محاسبه سقف/کف، چک ارتفاع و رسم مستطیل اگر معتبر باشد
   // این تابع رنج را بر اساس زمان محاسبه و ولید می‌کند
   void IdentifyAndValidateRange();  // شناسایی و ولید رنج

   // انتظار برای کندل بریک: چک کلوز بالای/پایین افست برای شروع تایید ورود
   // این تابع شکست را تشخیص می‌دهد
   void WaitForBreakerCandle();  // انتظار برای کندل بریک

   // فرآیند تلاش ورود: چک ابطال، تایید قیمت و فیلتر روند، اجرای معامله اگر تایید شد
   // این تابع ابطال و تاییدها را مدیریت می‌کند
   void ProcessEntryAttempt();  // فرآیند تلاش ورود

   // ریست به حالت مسلح: ریست سطح بریک بدون حذف خطوط برای حفظ فرصت‌ها
   // این تابع برای ابطال بدون پاکسازی استفاده می‌شود
   void ResetToArmedState();  // ریست به حالت مسلح

   // (جدید) اجرای سفارش مارکت: محاسبه SL با استراتژی جدید، حجم و ارسال سفارش مارکت
   void ExecuteMarketOrder(bool isBuy);  // اجرای سفارش مارکت

   // (جدید) ثبت استراتژی پولبک: شروع انتظار برای لمس خط پولبک
   void PlacePullbackStrategyOrders(bool isBuy);  // ثبت استراتژی پولبک

   // غیرفعال کردن مسیر مخالف: حذف خط و ریست قیمت برای OCO
   // این تابع مسیر مخالف را غیرفعال می‌کند
   void DisableOppositePath(bool isBuy);  // غیرفعال کردن مسیر مخالف

   // پاکسازی نرم: ریست متغیرها و حذف اشیاء بدون بستن معامله
   // این تابع برای ریست روزانه استفاده می‌شود
   void SoftCleanup();  // پاکسازی نرم

   // گرفتن ATR کش‌شده: محاسبه اگر خالی باشد (برای ورود ثابت)
   // این تابع کش ATR را مدیریت می‌کند
   double GetCachedATR();  // گرفتن ATR کش‌شده

   // گرفتن ATR برای SL: مشابه برای SL (ثابت)
   // این تابع کش SL را مدیریت می‌کند
   double GetSlATR();  // گرفتن ATR برای SL

   // گرفتن ATR برای تریلینگ: مشابه برای تریلینگ (پویا در مدیریت)
   // این تابع کش تریلینگ را مدیریت می‌کند
   double GetTrailingATR();  // گرفتن ATR برای تریلینگ

   // (جدید) تابع برای کاشتن Stop Order در استراتژی پولبک
   void PlaceReversalStopOrder(bool isBuy);  // تابع جدید برای کاشتن Stop Order

public:
   // سازنده پیش‌فرض با مقادیر اولیه برای جلوگیری از garbage values
   CRange() : m_rangeIndex(0), m_magicNumber(0), m_timeframe(PERIOD_CURRENT), m_startHour(0), m_startMinute(0), m_endHour(0), m_endMinute(0),
              m_minRangePoints(0), m_maxRangePoints(0), m_placementMode(PLACEMENT_ATR), m_atrPeriod(0), m_atrMultiplier(0.0),
              m_slStrategy(SL_OPPOSITE_SIDE), m_slCalcMode(SL_CALC_ATR), m_slAtrPeriod(0), m_slAtrMultiplier(0.0),
              m_trailingMode(TRAILING_ATR), m_trailingAtrPeriod(0), m_trailingAtrMultiplier(0.0), m_rrRatio(0.0), m_partialClosePercent(0.0),
              m_cleanupHours(0), m_color(clrNONE), m_trendFilterTimeframe(PERIOD_CURRENT), m_atrHandle(INVALID_HANDLE),
              m_slAtrHandle(INVALID_HANDLE), m_trailingAtrHandle(INVALID_HANDLE), m_currentState(RANGE_IDLE),
              m_rangeHigh(0), m_rangeLow(0), m_potentialBuyPrice(0), m_potentialSellPrice(0), m_breakerCandleLevel(0),
              m_activeTicket(0), m_pendingOrderTicket(0), m_cachedATR(0), m_cachedSlATR(0), m_cachedTrailingATR(0),
              m_waitCounter(0), m_cleanupTime(0), m_lastEndTime(0), m_lastInvalid(false), m_rangeEndTime(0), m_lastFilterBarTime(0),
              m_fixedOffsetValue(0.0), m_rangeObjectName(""), m_buyLineName(""), m_sellLineName(""), m_initialSlDistance(0.0), m_isCleanedForThisCycle(false),
              m_buyAttemptDisabled(false), m_sellAttemptDisabled(false), m_isBuyAttempt(false), m_breakerCandleTime(0), m_confirmationCandleTime(0) {}  // سازنده پیش‌فرض با مقادیر اولیه (شامل متغیرهای جدید)

   // مقداردهی رنج: تنظیم پارامترها، ایجاد هندل‌های ATR و نام‌گذاری اشیاء
   // این تابع تمام پارامترها را از ورودی‌ها می‌گیرد
   bool Init(int index, long magic, ENUM_TIMEFRAMES timeframe, int startHour, int startMinute, int endHour, int endMinute,
             int minRangePoints, int maxRangePoints, ENUM_PLACEMENT_MODE placementMode, int atrPeriod, double atrMultiplier,
             ENUM_SL_STRATEGY slStrategy, ENUM_SL_CALC_MODE slCalcMode, int slAtrPeriod, double slAtrMultiplier,
             ENUM_TRAILING_MODE trailingMode, int trailingAtrPeriod, double trailingAtrMultiplier,
             double rrRatio, double partialClosePercent, int cleanupHours, color col, ENUM_TIMEFRAMES trendTf, int sharedAtrHandle);  // مقداردهی رنج
   int GetTrailingAtrHandle() const { return m_trailingAtrHandle; }  // بازگشت هندل ATR تریلینگ
   // دفع رنج: آزادسازی هندل‌های ATR
   // این تابع منابع را آزاد می‌کند
   void Deinit();  // دفع رنج

   // به‌روزرسانی در کندل جدید: اجرای ماشین حالت
   // این تابع بر اساس حالت فعلی عمل می‌کند
   void UpdateOnNewBar();  // به‌روزرسانی در کندل جدید

   // پاکسازی سخت: بستن معامله اگر باز باشد و سپس پاکسازی نرم (برای تعطیلات یا دفع)
   // این تابع برای پاکسازی کامل استفاده می‌شود
   void HardCleanup();  // پاکسازی سخت

   // چک پاکسازی: چک زمان انقضا و فراخوانی پاکسازی مناسب
   // این تابع در OnTick فراخوانی می‌شود
   void CheckCleanup();  // چک پاکسازی

   // ریست کش‌ها: صفر کردن کش ATRها برای رنج جدید
   // این تابع کش‌ها را ریست می‌کند
   void ResetCaches();  // ریست کش‌ها

   // گرفتن تایم‌فریم اجرا
   // این گتر تایم‌فریم را برمی‌گرداند
   ENUM_TIMEFRAMES GetTimeframe() const { return m_timeframe; }  // بازگشت تایم‌فریم اجرا

   // گرفتن تایم‌فریم فیلتر روند
   // این گتر فیلتر را برمی‌گرداند
   ENUM_TIMEFRAMES GetTrendFilterTimeframe() const { return m_trendFilterTimeframe; }  // بازگشت تایم‌فریم فیلتر

   // گرفتن حالت فعلی
   // این گتر حالت را برمی‌گرداند
   ENUM_RANGE_STATE GetCurrentState() const { return m_currentState; }  // بازگشت حالت فعلی

   // تنظیم حالت فعلی (برای استفاده داخلی یا بازیابی حافظه)
   // این ستر حالت را تنظیم می‌کند
   void SetCurrentState(ENUM_RANGE_STATE state) { m_currentState = state; }  // تنظیم حالت

   // گرفتن زمان آخرین کندل فیلتر
   // این گتر زمان فیلتر را برمی‌گرداند
   datetime GetLastFilterBarTime() const { return m_lastFilterBarTime; }  // بازگشت زمان فیلتر

   // به‌روزرسانی زمان آخرین کندل فیلتر
   // این ستر زمان را آپدیت می‌کند
   void UpdateLastFilterBarTime(datetime time) { m_lastFilterBarTime = time; }  // تنظیم زمان فیلتر

   // تنظیم تیکت فعال (برای بازیابی حافظه)
   // این ستر تیکت را تنظیم می‌کند
   void SetActiveTicket(ulong ticket) { m_activeTicket = ticket; }  // تنظیم تیکت

   // تنظیم تیکت سفارش پندینگ (برای بازیابی حافظه سفارشات پندینگ)
   // این ستر تیکت سفارش را تنظیم می‌کند
   void SetPendingOrderTicket(ulong ticket) { m_pendingOrderTicket = ticket; }  // تنظیم تیکت سفارش پندینگ

   // گرفتن تیکت سفارش پندینگ (برای چک در پاکسازی)
   // این گتر تیکت سفارش را برمی‌گرداند
   ulong GetPendingOrderTicket() const { return m_pendingOrderTicket; }  // بازگشت تیکت سفارش پندینگ

   // بازیابی وضعیت: ذخیره سقف، کف و فاصله SL اولیه برای استفاده پس از ری‌استارت
   // این تابع وضعیت را از کامنت بازیابی می‌کند
   void RestoreState(double range_high, double range_low, double initial_sl_distance)  // بازیابی وضعیت
   {
      m_rangeHigh = range_high;  // ذخیره سقف
      m_rangeLow = range_low;  // ذخیره کف
      m_initialSlDistance = initial_sl_distance;  // ذخیره فاصله SL
      CLogger::Log("وضعیت رنج " + IntegerToString(m_rangeIndex) + " با موفقیت بازیابی شد.", m_rangeIndex);  // چاپ موفقیت
   }

   // Getter برای زمان کندل شکست (برای BreakoutAnalyzer)
   datetime GetBreakerCandleTime() const { return m_breakerCandleTime; }

   // Getter برای زمان کندل تاییدیه (برای BreakoutAnalyzer)
   datetime GetConfirmationCandleTime() const { return m_confirmationCandleTime; }

   // Getter برای جهت خرید/فروش (برای BreakoutAnalyzer)
   bool GetIsBuyAttempt() const { return m_isBuyAttempt; }
};

// پیاده‌سازی توابع کلاس CRange (خارج از تعریف کلاس برای خوانایی)
// تمام توابع private/public در ادامه تعریف می‌شوند

// مقداردهی رنج: تنظیم پارامترها، ایجاد هندل‌های ATR و نام‌گذاری اشیاء
// این تابع تمام فیلدهای private را مقداردهی می‌کند
bool CRange::Init(int index, long magic, ENUM_TIMEFRAMES timeframe, int startHour, int startMinute, int endHour, int endMinute,
                  int minRangePoints, int maxRangePoints, ENUM_PLACEMENT_MODE placementMode, int atrPeriod, double atrMultiplier,
                  ENUM_SL_STRATEGY slStrategy, ENUM_SL_CALC_MODE slCalcMode, int slAtrPeriod, double slAtrMultiplier,
                  ENUM_TRAILING_MODE trailingMode, int trailingAtrPeriod, double trailingAtrMultiplier,
                  double rrRatio, double partialClosePercent, int cleanupHours, color col, ENUM_TIMEFRAMES trendTf, int sharedAtrHandle)  // پارامترهای ورودی
{
   // تنظیم ایندکس رنج برای لاگ و اشیاء
   m_rangeIndex = index;  // تنظیم ایندکس رنج
   // تنظیم مجیک برای تمایز معاملات
   m_magicNumber = magic;  // تنظیم مجیک
   // تنظیم تایم‌فریم اجرا
   m_timeframe = timeframe;  // تنظیم تایم‌فریم اجرا
   // تنظیم زمان شروع
   m_startHour = startHour;  // تنظیم ساعت شروع
   m_startMinute = startMinute;  // تنظیم دقیقه شروع
   // تنظیم زمان پایان
   m_endHour = endHour;  // تنظیم ساعت پایان
   m_endMinute = endMinute;  // تنظیم دقیقه پایان
   // تنظیم محدودیت‌های ارتفاع
   m_minRangePoints = minRangePoints;  // تنظیم حداقل ارتفاع
   m_maxRangePoints = maxRangePoints;  // تنظیم حداکثر ارتفاع
   // تنظیم حالت افست
   m_placementMode = placementMode;  // تنظیم حالت افست
   // تنظیم پارامترهای ATR افست
   m_atrPeriod = atrPeriod;  // تنظیم دوره ATR افست
   m_atrMultiplier = atrMultiplier;  // تنظیم ضریب ATR افست
   // تنظیم پارامترهای SL
   m_slStrategy = slStrategy;  // تنظیم استراتژی SL
   m_slCalcMode = slCalcMode;  // تنظیم حالت بافر SL
   m_slAtrPeriod = slAtrPeriod;  // تنظیم دوره ATR SL
   m_slAtrMultiplier = slAtrMultiplier;  // تنظیم ضریب ATR SL
   // تنظیم پارامترهای تریلینگ
   m_trailingMode = trailingMode;  // تنظیم حالت تریلینگ
   m_trailingAtrPeriod = trailingAtrPeriod;  // تنظیم دوره ATR تریلینگ
   m_trailingAtrMultiplier = trailingAtrMultiplier;  // تنظیم ضریب ATR تریلینگ
   // تنظیم پارامترهای مدیریت معامله
   m_rrRatio = rrRatio;  // تنظیم نسبت RR
   m_partialClosePercent = partialClosePercent;  // تنظیم درصد پله‌ای
   m_cleanupHours = cleanupHours;  // تنظیم ساعت‌های پاکسازی
   m_color = col;  // تنظیم رنگ
   m_trendFilterTimeframe = trendTf;  // تنظیم تایم‌فریم فیلتر
   m_atrHandle = sharedAtrHandle;  // هندل ATR افست (مشترک)

   // ایجاد هندل‌های جداگانه برای SL و تریلینگ (برای دوره‌های متفاوت)
   // iATR هندل اندیکاتور را ایجاد می‌کند
   m_slAtrHandle = iATR(_Symbol, timeframe, m_slAtrPeriod);  // هندل ATR برای SL
   if(m_slAtrHandle == INVALID_HANDLE)  // چک موفقیت ایجاد
   {
      CLogger::Log("خطا در ایجاد هندل ATR برای SL رنج " + IntegerToString(index), index);  // چاپ خطا
      return false;  // بازگشت شکست
   }
   m_trailingAtrHandle = iATR(_Symbol, timeframe, m_trailingAtrPeriod);  // هندل ATR برای تریلینگ
   if(m_trailingAtrHandle == INVALID_HANDLE)  // چک موفقیت
   {
      CLogger::Log("خطا در ایجاد هندل ATR برای تریلینگ رنج " + IntegerToString(index), index);  // چاپ خطا
      return false;  // بازگشت شکست
   }

   // نام‌گذاری اشیاء گرافیکی با ایندکس برای تمایز
   m_rangeObjectName = "Range_Rect_" + IntegerToString(index);  // نام مستطیل رنج
   m_buyLineName = "Range_BuyLine_" + IntegerToString(index);  // نام خط خرید
   m_sellLineName = "Range_SellLine_" + IntegerToString(index);  // نام خط فروش

   ResetCaches();  // ریست کش‌ها در شروع
   m_currentState = RANGE_IDLE;  // حالت اولیه انتظار
   m_lastFilterBarTime = 0;  // ریست زمان فیلتر
   m_isCleanedForThisCycle = false;  // ریست فلگ پاکسازی چرخه
   // (جدید) ریست متغیرهای ابطال جهت‌ها در Init
   m_buyAttemptDisabled = false;  // ریست فلگ غیرفعال خرید
   m_sellAttemptDisabled = false;  // ریست فلگ غیرفعال فروش
   m_isBuyAttempt = false;  // ریست جهت سیگنال
   m_breakerCandleTime = 0;  // ریست زمان بریک
   m_confirmationCandleTime = 0;  // ریست زمان تاییدیه
   // چاپ موفقیت با CLogger
   CLogger::Log("رنج " + IntegerToString(index) + " مقداردهی شد.", index);  // چاپ موفقیت
   return true;  // بازگشت موفقیت
}

// دفع رنج: آزادسازی هندل‌های ATR
// IndicatorRelease هندل‌ها را آزاد می‌کند
void CRange::Deinit()  // تابع دفع
{
   if(m_slAtrHandle != INVALID_HANDLE) IndicatorRelease(m_slAtrHandle);  // آزادسازی هندل SL
   if(m_trailingAtrHandle != INVALID_HANDLE) IndicatorRelease(m_trailingAtrHandle);  // آزادسازی هندل تریلینگ
   CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " دفع شد.", m_rangeIndex);  // چاپ دیباگ
}

// به‌روزرسانی در کندل جدید: اجرای ماشین حالت
// سوئیچ بر اساس حالت فعلی برای کنترل جریان
void CRange::UpdateOnNewBar()  // تابع به‌روزرسانی
{

     // ==================== شروع اصلاحیه اصلی ====================
   // قدم اول: قبل از هر کاری و فارغ از هر حالتی، زمان پاکسازی رو چک کن
   // این بلوک تضمین می‌کنه که پاکسازی همیشه در اولویت قرار داره.
   if (m_cleanupTime != 0 && TimeCurrent() >= m_cleanupTime && !m_isCleanedForThisCycle)
   {
       CLogger::Log("زمان پاکسازی فرا رسید (حالت فعلی: " + EnumToString(m_currentState) + "). اجرای پاکسازی نرم.", m_rangeIndex);
       
       // مستقیماً SoftCleanup رو اجرا میکنیم
       SoftCleanup();
       
       // حالت رو به IDLE تغییر میدیم تا برای روز بعد آماده بشه
       m_currentState = RANGE_IDLE;
       
       // با return از تابع خارج میشیم تا هیچ منطق معاملاتی دیگه‌ای در این کندل اجرا نشه
       return;
   }
   // ==================== پایان اصلاحیه اصلی =====================

   // لاگ ورود به تابع برای ردیابی
   CLogger::Log("------ در حالت " + EnumToString(m_currentState) + " ------", m_rangeIndex);  // عنوان حالت

   // سوئیچ بر اساس حالت فعلی برای اجرای تابع مربوطه
   switch(m_currentState)  // سوئیچ بر اساس حالت فعلی
   {
      case RANGE_IDLE:  // حالت بیکار
     {
        // چک اگر زمان وارد محدوده رنج شده باشد
         datetime currentTime = TimeCurrent();  // زمان فعلی
         datetime startTime, endTime;  // زمان شروع و پایان
         if(CTimeHelper::CalculateRangeTimes(m_startHour, m_startMinute, m_endHour, m_endMinute, startTime, endTime))  // محاسبه زمان‌ها
         {
            if(currentTime >= startTime && currentTime < endTime)  // چک داخل محدوده
            {
               CLogger::Log("زمان رنج فرا رسید. انتقال به RANGE_IDENTIFYING.", m_rangeIndex);  // لاگ انتقال
               m_currentState = RANGE_IDENTIFYING;  // تغییر به شناسایی
            }
         }
         break;  // خروج از کیس
     }  
      case RANGE_IDENTIFYING:  // در حال شناسایی
         IdentifyAndValidateRange();  // شناسایی رنج
         break;  // خروج
      case RANGE_ARMED:  // مسلح و انتظار
         WaitForBreakerCandle();  // انتظار بریک
         break;  // خروج
      case AWAITING_CONFIRMATION:  // انتظار تایید
         ProcessEntryAttempt();  // فرآیند ورود
         break;  // خروج
      case RANGE_AWAITING_PULLBACK_TOUCH:  // انتظار لمس خط پولبک
         {
            // در هر کندل جدید، چک میکنیم آیا کندل قبلی خط را لمس کرده است
            double prev_low = iLow(_Symbol, m_timeframe, 1);
            double prev_high = iHigh(_Symbol, m_timeframe, 1);

            bool touchDetected = m_isBuyAttempt ? (prev_low <= m_potentialBuyPrice) : (prev_high >= m_potentialSellPrice);

            if(touchDetected)
            {
                CLogger::Log("لمس خط پولبک در کندل قبلی تایید شد. در حال کاشتن تله Stop Order.", m_rangeIndex);
                PlaceReversalStopOrder(m_isBuyAttempt); // تابع جدید ما اینجا صدا زده میشود
            }
            break;
         }
      case RANGE_AWAITING_REVERSAL_TRIGGER: // انتظار فعال شدن Stop Order
         {
            // --- شروع تسک ۱: قانون ابطال با SL ---
            if (m_pendingOrderTicket != 0 && OrderSelect(m_pendingOrderTicket))
            {
                double stopLossPrice = OrderGetDouble(ORDER_SL);
                double prev_low = iLow(_Symbol, m_timeframe, 1);
                double prev_high = iHigh(_Symbol, m_timeframe, 1);
                bool invalidated = false;

                if (m_isBuyAttempt && prev_low <= stopLossPrice) invalidated = true;
                else if (!m_isBuyAttempt && prev_high >= stopLossPrice) invalidated = true;

                if (invalidated)
                {
                    CLogger::Log("سیگنال پولبک باطل شد! قیمت به سطح SL رسید قبل از فعال شدن.", m_rangeIndex);
                    CTrade trade;
                    trade.OrderDelete(m_pendingOrderTicket);
                    m_pendingOrderTicket = 0;
                    // برای این جهت دیگر تلاش نمیکنیم چون ناموفق بود
                    if (m_isBuyAttempt) m_buyAttemptDisabled = true; else m_sellAttemptDisabled = true;
                    ResetToArmedState();
                    break; // از این کیس خارج شو
                }
            }
            // --- پایان تسک ۱ ---

            // چک فعال شدن Stop Order: جستجو در پوزیشن‌های باز
            bool orderActivated = false;  // فلگ
            for(int pos = 0; pos < PositionsTotal(); pos++)  // حلقه پوزیشن‌ها
            {
               if(PositionGetSymbol(pos) == _Symbol && PositionGetInteger(POSITION_MAGIC) == m_magicNumber)  // چک
               {
                  ulong posTicket = PositionGetInteger(POSITION_TICKET);  // تیکت
                  if(posTicket != m_activeTicket)  // جدید
                  {
                     m_activeTicket = posTicket;  // ذخیره
                     double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);  // قیمت
                     g_tradeManager.RegisterTrade(posTicket, m_magicNumber, m_rangeIndex, m_initialSlDistance, openPrice, m_rrRatio, m_partialClosePercent, m_trailingMode, m_trailingAtrPeriod, m_trailingAtrMultiplier, m_timeframe, m_trailingAtrHandle, m_trendFilterTimeframe);  // ثبت
                     m_pendingOrderTicket = 0;  // ریست
                     m_currentState = RANGE_TRADE_ACTIVE;  // تغییر
                     orderActivated = true;  // فلگ
                     CLogger::Log("Stop Order فعال شد. معامله واگذار به مدیر معاملات. تیکت: " + IntegerToString(posTicket), m_rangeIndex);  // لاگ
                     DisableOppositePath(m_isBuyAttempt);  // غیرفعال کردن مخالف
                     if (m_isBuyAttempt) m_buyAttemptDisabled = true; else m_sellAttemptDisabled = true; // یک شانس برای هر جهت
                     break;
                  }
               }
            }
            if(!orderActivated)  // اگر نه، منتظر بمان
            {
               CLogger::Log("منتظر فعال شدن Stop Order رنج " + IntegerToString(m_rangeIndex) + ". تیکت: " + IntegerToString(m_pendingOrderTicket), m_rangeIndex);  // لاگ
            }
            break;
         }
      case RANGE_TRADE_ACTIVE:  // معامله فعال
         // هیچ عملی، منتظر پاکسازی
         CLogger::Log("معامله فعال است. منتظر پاکسازی.", m_rangeIndex);  // لاگ وضعیت
         break;  // خروج
      case RANGE_EXPIRED:  // منقضی
         SoftCleanup();  // پاکسازی نرم
         m_currentState = RANGE_IDLE;  // بازگشت به بیکار
         break;  // خروج
   }
}

// شناسایی و ولید رنج: محاسبه سقف/کف، چک ارتفاع، محاسبه ثابت افست و رسم مستطیل اگر معتبر باشد
// این تابع رنج را بر اساس زمان و داده‌های کندل محاسبه و ولید می‌کند
void CRange::IdentifyAndValidateRange()  // تابع شناسایی
{
   CLogger::Log("شناسایی رنج " + IntegerToString(m_rangeIndex) + "...", m_rangeIndex);  // چاپ دیباگ برای شناسایی

   datetime startTime, endTime;  // متغیرهای زمان شروع و پایان
   // محاسبه زمان‌ها با CTimeHelper
   if(!CTimeHelper::CalculateRangeTimes(m_startHour, m_startMinute, m_endHour, m_endMinute, startTime, endTime))  // محاسبه زمان‌ها
   {
      CLogger::Log("خطا در محاسبه زمان رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);  // چاپ خطا
      m_currentState = RANGE_EXPIRED;  // تنظیم به منقضی
      return;  // خروج
   }

   // چک برای جلوگیری از پردازش تکراری رنج در یک روز (با چک نامعتبر بودن آخرین)
   // این شرط از محاسبات مکرر جلوگیری می‌کند
   if(endTime == m_lastEndTime && !m_lastInvalid) return;  // اگر همان پایان قبلی و معتبر، پرش
   if(endTime == m_lastEndTime && m_lastInvalid) return;  // اگر همان و نامعتبر، پرش
   if(TimeCurrent() < endTime) return;  // اگر هنوز پایان نرسیده، پرش

   m_rangeEndTime = endTime;  // ذخیره زمان پایان کامل برای پاکسازی دقیق

   // iBarShift شیفت کندل را بر اساس زمان برمی‌گرداند
   int startShift = iBarShift(_Symbol, m_timeframe, startTime);  // شیفت شروع
   int endShift = iBarShift(_Symbol, m_timeframe, endTime);  // شیفت پایان

   if(startShift < 0 || endShift < 0)  // چک شیفت معتبر (برای Edge Case بدون کندل)
   {
      CLogger::Log("خطا: کندلی در بازه زمانی مشخص شده برای رنج " + IntegerToString(m_rangeIndex) + " یافت نشد.", m_rangeIndex);  // چاپ خطا
      m_lastInvalid = true;  // تنظیم فلگ نامعتبر
      m_lastEndTime = endTime;  // ذخیره پایان
      m_currentState = RANGE_EXPIRED;  // تنظیم به منقضی
      return;  // خروج
   }

   int bars = startShift - endShift + 1;  // تعداد بارها در رنج
   if(bars <= 0)  // چک تعداد معتبر
   {
      CLogger::Log("خطا: تعداد بارها نامعتبر برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);  // چاپ خطا
      m_lastInvalid = true;  // تنظیم فلگ
      m_lastEndTime = endTime;  // ذخیره پایان
      m_currentState = RANGE_EXPIRED;  // تنظیم به منقضی
      return;  // خروج
   }

   // محاسبه سقف و کف رنج با iHighest/iLowest
   int highestIdx = iHighest(_Symbol, m_timeframe, MODE_HIGH, bars, endShift);  // ایندکس سقف
   int lowestIdx = iLowest(_Symbol, m_timeframe, MODE_LOW, bars, endShift);  // ایندکس کف
   m_rangeHigh = iHigh(_Symbol, m_timeframe, highestIdx);  // سقف رنج
   m_rangeLow = iLow(_Symbol, m_timeframe, lowestIdx);  // کف رنج

   double rangeHeight = (m_rangeHigh - m_rangeLow) / _Point;  // ارتفاع به پوینت
   CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + ": سقف=" + DoubleToString(m_rangeHigh, _Digits) + ", کف=" + DoubleToString(m_rangeLow, _Digits) + ", ارتفاع=" + DoubleToString(rangeHeight, 0) + " پوینت", m_rangeIndex);  // چاپ دیباگ

   // چک کیفیت رنج (ارتفاع در محدوده مجاز)
   if(rangeHeight < m_minRangePoints || rangeHeight > m_maxRangePoints)  // شرط چک ارتفاع
   {
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " بی‌کیفیت است. ارتفاع خارج از محدوده مجاز.", m_rangeIndex);  // چاپ خطا
      m_lastInvalid = true;  // تنظیم فلگ
      m_lastEndTime = endTime;  // ذخیره پایان
      m_currentState = RANGE_EXPIRED;  // تنظیم به منقضی
      return;  // خروج
   }

   // --- START: Calculate and Fix Offset Value --- (محاسبه ثابت افست در لحظه شناسایی برای جلوگیری از جابجایی)
   // این بخش افست را ثابت می‌کند
   if(m_placementMode == PLACEMENT_ATR)  // حالت ATR
   {
      double atr_buffer[];  // بافر ATR (دینامیک بدون اندازه ثابت)
      ArraySetAsSeries(atr_buffer, true);  // تنظیم سری آرایه
      if(CopyBuffer(m_atrHandle, 0, 1, 1, atr_buffer) > 0)  // کپی ATR فعلی (shift 1 برای کندل بسته)
      {
         m_fixedOffsetValue = atr_buffer[0] * m_atrMultiplier;  // محاسبه و ذخیره ثابت
      }
      else  // شرط شکست کپی
      {
         CLogger::Log("خطا در گرفتن ATR برای تثبیت افست رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);  // چاپ خطا
         m_currentState = RANGE_EXPIRED;  // تنظیم به منقضی
         return;  // خروج
      }
   }
   else  // حالت درصد
   {
      m_fixedOffsetValue = (m_rangeHigh - m_rangeLow) * m_atrMultiplier / 100.0;  // محاسبه ثابت درصد
   }
   // --- END: Calculate and Fix Offset Value ---

   // رسم مستطیل رنج اگر معتبر باشد با ObjectCreate
   if(!ObjectCreate(0, m_rangeObjectName, OBJ_RECTANGLE, 0, startTime, m_rangeHigh, endTime, m_rangeLow))  // رسم مستطیل
   {
      CLogger::Log("خطا در رسم مستطیل رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(GetLastError()), m_rangeIndex);  // چاپ خطا
   }
   else  // شرط موفقیت رسم
   {
      ObjectSetInteger(0, m_rangeObjectName, OBJPROP_COLOR, m_color);  // تنظیم رنگ
      ObjectSetInteger(0, m_rangeObjectName, OBJPROP_STYLE, STYLE_SOLID);  // تنظیم استایل
      ObjectSetInteger(0, m_rangeObjectName, OBJPROP_WIDTH, 1);  // تنظیم عرض
      ObjectSetInteger(0, m_rangeObjectName, OBJPROP_FILL, true);  // توپر کردن مستطیل (شیشه‌ای)
      ObjectSetInteger(0, m_rangeObjectName, OBJPROP_BACK, true);  // پس‌زمینه برای شفافیت
   }
   
   // ++++++++++++++++ START: کد اضافه شده از ArmAndWait ++++++++++++++++
   CLogger::Log("مسلح کردن رنج " + IntegerToString(m_rangeIndex) + "...", m_rangeIndex);

   // استفاده از افست ثابت محاسبه‌شده در شناسایی (برای جلوگیری از جابجایی خطوط)
   m_potentialBuyPrice = NormalizePrice(m_rangeHigh + m_fixedOffsetValue);
   m_potentialSellPrice = NormalizePrice(m_rangeLow - m_fixedOffsetValue);

   datetime currentTime = TimeCurrent();
   // رسم خط خرید
   if(!ObjectCreate(0, m_buyLineName, OBJ_HLINE, 0, currentTime, m_potentialBuyPrice))
   {
      CLogger::Log("خطا در رسم خط BUY برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);
   }
   else
   {
      ObjectSetInteger(0, m_buyLineName, OBJPROP_COLOR, clrGreen);
      ObjectSetInteger(0, m_buyLineName, OBJPROP_STYLE, STYLE_DASH);
   }
   // رسم خط فروش
   if(!ObjectCreate(0, m_sellLineName, OBJ_HLINE, 0, currentTime, m_potentialSellPrice))
   {
      CLogger::Log("خطا در رسم خط SELL برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);
   }
   else
   {
      ObjectSetInteger(0, m_sellLineName, OBJPROP_COLOR, clrRed);
      ObjectSetInteger(0, m_sellLineName, OBJPROP_STYLE, STYLE_DASH);
   }
   //ریست پرچم پکسازی  برای رنج جدید 
   m_isCleanedForThisCycle =  false;
   // محاسبه زمان پاکسازی
   m_cleanupTime = CTimeHelper::CalculateCleanupTime(m_rangeEndTime, m_cleanupHours);
   CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " مسلح شد. Potential Buy: " + DoubleToString(m_potentialBuyPrice, _Digits) + ", Sell: " + DoubleToString(m_potentialSellPrice, _Digits), m_rangeIndex);
   // ++++++++++++++++ END: کد اضافه شده از ArmAndWait ++++++++++++++++

   m_lastInvalid = false;  // ریست فلگ نامعتبر
   m_lastEndTime = endTime;  // ذخیره پایان
   m_currentState = RANGE_ARMED;  // تغییر حالت به مسلح
   CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " معتبر است. تغییر حالت به ARMED.", m_rangeIndex);  // چاپ دیباگ
}

// انتظار برای کندل بریک: چک کلوز بالای/پایین افست برای شروع تایید ورود (اصلاح شده برای چک disabled و ذخیره جهت)
// این تابع همیشه برای هر دو جهت آماده است و شکست معتبر را تشخیص می‌دهد
void CRange::WaitForBreakerCandle()  // تابع انتظار بریک (اصلاح شده)
{
   // iClose کلوز کندل قبلی (shift 1) را برمی‌گرداند
   double close1 = iClose(_Symbol, m_timeframe, 1);  // کلوز کندل قبلی
   if(close1 == 0)  // چک مقدار معتبر
   {
      CLogger::Log("خطا: iClose مقدار نامعتبر برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);  // چاپ خطا
      return;  // خروج
   }

   // چک شکست خرید: فقط اگر disabled نباشد
   if(!m_buyAttemptDisabled && close1 > m_potentialBuyPrice)  // چک شکست خرید با فلگ disabled
   {
      m_breakerCandleLevel = iHigh(_Symbol, m_timeframe, 1);  // سطح های کندل شکست
      m_isBuyAttempt = true;  // ذخیره جهت سیگنال (خرید)
      m_breakerCandleTime = iTime(_Symbol, m_timeframe, 1);  // ذخیره زمان بریک
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " - BUY Breaker Candle detected! Level: " + DoubleToString(m_breakerCandleLevel, _Digits), m_rangeIndex);  // چاپ دیباگ
      m_waitCounter = 0;  // ریست شمارنده برای حالت قدیمی
      m_currentState = AWAITING_CONFIRMATION;  // تغییر حالت به انتظار ورود
      return;  // خروج پس از تشخیص (فقط یک جهت در هر کندل)
   }
   // چک شکست فروش: فقط اگر disabled نباشد
   else if(!m_sellAttemptDisabled && close1 < m_potentialSellPrice)  // چک شکست فروش با فلگ disabled
   {
      m_breakerCandleLevel = iLow(_Symbol, m_timeframe, 1);  // سطح لو کندل شکست
      m_isBuyAttempt = false;  // ذخیره جهت سیگنال (فروش)
      m_breakerCandleTime = iTime(_Symbol, m_timeframe, 1);  // ذخیره زمان بریک
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " - SELL Breaker Candle detected! Level: " + DoubleToString(m_breakerCandleLevel, _Digits), m_rangeIndex);  // چاپ دیباگ
      m_waitCounter = 0;  // ریست شمارنده برای حالت قدیمی
      m_currentState = AWAITING_CONFIRMATION;  // تغییر حالت به انتظار ورود
      return;  // خروج پس از تشخیص
   }
   // اگر هیچ شکستی نبود، منتظر بمان (حالت ARMED حفظ می‌شود)
}

// فرآیند تلاش ورود: چک ابطال، تایید قیمت و فیلتر روند، اجرای معامله اگر تایید شد (نسخه کاملاً صحیح)
void CRange::ProcessEntryAttempt()
{
   // قدم اول: تشخیص جهت معتبر از متغیر ذخیره‌شده
   bool isBuyAttempt = m_isBuyAttempt;
   double close1 = iClose(_Symbol, m_timeframe, 1);

   // قدم دوم: اجرای استراتژی تایید/ابطال با switch
   switch(Inp_Confirmation_Strategy)
   {
      case CONFIRMATION_TIMEOUT:
         m_waitCounter++;
         if(m_waitCounter > Inp_Confirmation_Timeout)
         {
            if(isBuyAttempt) m_buyAttemptDisabled = true;
            else m_sellAttemptDisabled = true;
            CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + ": مهلت تایید تمام شد. ابطال دائمی جهت " + (isBuyAttempt ? "خرید" : "فروش") + ".", m_rangeIndex);
            ResetToArmedState();
            return;
         }
         break;

      case CONFIRMATION_PRICE_INVALIDATION:
      { // آکولاد باز برای شروع محدوده case
         bool isInvalid = false;
         if(Inp_Invalidation_Mode == INVALIDATION_RANGE_REENTRY)
         {
            if(isBuyAttempt && close1 < m_rangeHigh) isInvalid = true;
            if(!isBuyAttempt && close1 > m_rangeLow) isInvalid = true;
         }
         else
         {
            if(isBuyAttempt && close1 < m_potentialBuyPrice) isInvalid = true;
            if(!isBuyAttempt && close1 > m_potentialSellPrice) isInvalid = true;
         }

         if(isInvalid)
         {
            CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + ": شرط ابطال قیمتی رخ داد. ریست موقت.", m_rangeIndex);
            ResetToArmedState();
            return;
         }
         break;
      } // آکولاد بسته برای پایان محدوده case
   }

   // قدم سوم: تایید قیمت اختیاری (این بخش باید خارج از switch باشه)
   if(Inp_PriceConfirmation_Enabled)
   {
      bool priceConfirmed = (isBuyAttempt ? (close1 > m_breakerCandleLevel) : (close1 < m_breakerCandleLevel));
      if(priceConfirmed) m_confirmationCandleTime = iTime(_Symbol, m_timeframe, 1);  // ذخیره زمان اگر تایید شد
      if(!priceConfirmed)
      {
         CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + ": تایید قیمت برقرار نیست. صبر برای کندل بعدی.", m_rangeIndex);
         return;
      }
   }

   // قدم چهارم: اجرای فیلتر روند (این بخش هم باید خارج از switch باشه)
   ENUM_TREND_DIRECTION currentTrend = g_trendFilter.GetTrendDirection(m_trendFilterTimeframe);
   bool filterConfirmed = false;
   if(!Inp_IchimokuFilter_Enabled)
   {
      filterConfirmed = true;
   }
   else
   {
      if(isBuyAttempt && currentTrend == TREND_BUY) filterConfirmed = true;
      else if(!isBuyAttempt && currentTrend == TREND_SELL) filterConfirmed = true;
      else if(currentTrend == TREND_NEUTRAL)
      {
         CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + ": روند خنثی. صبر برای جهت مشخص.", m_rangeIndex);
         return;
      }
   }

   // اجرای سفارش اگر فیلتر تایید شد (دوراهی تصمیم‌گیری)
   if(filterConfirmed)
   {
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + ": تمام تاییدها برقرار. تصمیم‌گیری ورود تطبیقی.", m_rangeIndex);
      if(Inp_AdaptiveEntry_Enabled && BreakoutAnalyzer::IsBreakoutExplosive(this))  // چک انفجاری بودن
      {
         ExecuteMarketOrder(isBuyAttempt);  // ورود آنی (مارکت)
      }
      else
      {
         PlacePullbackStrategyOrders(isBuyAttempt);  // ورود پولبک (لیمیت یا استاپ)
      }
   }
}

// ریست به حالت مسلح: ریست سطح بریک بدون حذف خطوط برای حفظ فرصت‌ها
// این تابع برای ابطال بدون پاکسازی استفاده می‌شود
void CRange::ResetToArmedState()  // تابع ریست (اصلاح شده)
{
   CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + ": ریست به حالت مسلح (حفظ خطوط).", m_rangeIndex);  // چاپ دیباگ برای ریست
   m_breakerCandleLevel = 0;  // پاک کردن سطح کندل شکننده
   m_waitCounter = 0;  // ریست شمارنده برای حالت بعدی
   m_isBuyAttempt = false;  // ریست جهت سیگنال برای تشخیص جدید
   m_breakerCandleTime = 0;  // ریست زمان بریک
   m_confirmationCandleTime = 0;  // ریست زمان تاییدیه
   m_currentState = RANGE_ARMED;  // ریست حالت به مسلح و انتظار
   // نکته کلیدی: هیچ خط گرافیکی یا مسیری اینجا حذف نمی‌شود تا فرصت دوباره شکل گیرد
}

// (جدید) اجرای سفارش مارکت: محاسبه SL با استراتژی جدید، حجم و ارسال سفارش مارکت
// این تابع ورود آنی را ثبت می‌کند
void CRange::ExecuteMarketOrder(bool isBuy)  // اجرای سفارش مارکت
{
   double price = isBuy ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);  // قیمت مارکت
   double adjustment;  // بافر SL

   if(m_slCalcMode == SL_CALC_ATR)  // حالت ATR برای بافر SL
   {
      double atr_buffer[];  // آرایه ATR
      ArraySetAsSeries(atr_buffer, true);
      if(CopyBuffer(m_slAtrHandle, 0, 1, 1, atr_buffer) <= 0)
      {
         CLogger::Log("خطا در گرفتن ATR برای SL رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);
         return;
      }
      adjustment = atr_buffer[0] * m_slAtrMultiplier;
   }
   else
   {
      adjustment = (m_rangeHigh - m_rangeLow) * m_slAtrMultiplier / 100.0;
   }

   double basePoint = m_slStrategy == SL_OPPOSITE_SIDE ? (isBuy ? m_rangeLow : m_rangeHigh) : (isBuy ? m_rangeHigh : m_rangeLow);
   double slPrice = isBuy ? NormalizePrice(basePoint - adjustment) : NormalizePrice(basePoint + adjustment);
   double slDistance = MathAbs(price - slPrice);
   m_initialSlDistance = slDistance;

   long stops_level = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
   double minStop = stops_level * _Point + _Point;
   if(slDistance <= 0 || slDistance < minStop)
   {
      CLogger::Log("خطا: slDistance نامعتبر برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);
      m_currentState = RANGE_EXPIRED;
      return;
   }

   double lotSize = CRiskManager::CalculateLotSize(InpRiskPercent, slDistance);
   if(lotSize == 0)
   {
      CLogger::Log("خطا در محاسبه حجم برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);
      m_currentState = RANGE_EXPIRED;
      return;
   }

   double margin_required;
   if(!OrderCalcMargin(isBuy ? ORDER_TYPE_BUY : ORDER_TYPE_SELL, _Symbol, lotSize, price, margin_required))
   {
      CLogger::Log("خطا در محاسبه مارجین برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);
      m_currentState = RANGE_EXPIRED;
      return;
   }
   if(margin_required > AccountInfoDouble(ACCOUNT_MARGIN_FREE))
   {
      CLogger::Log("مارجین کافی نیست برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);
      m_currentState = RANGE_EXPIRED;
      return;
   }

   CTrade trade;
   MqlTradeRequest request;
   MqlTradeResult result;
   ZeroMemory(request);
   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = lotSize;
   request.type = isBuy ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
   request.price = price;
   request.sl = slPrice;
   request.tp = 0.0;
   request.magic = m_magicNumber;
   request.comment = StringFormat("R%d;H:%.5f;L:%.5f;SLD:%.5f", m_rangeIndex, m_rangeHigh, m_rangeLow, m_initialSlDistance);
   request.deviation = 10;
   if(!trade.OrderSend(request, result) || result.deal == 0)
   {
      CLogger::Log("خطا در ثبت سفارش مارکت برای رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(result.retcode), m_rangeIndex);
      m_currentState = RANGE_EXPIRED;
      return;
   }
   m_activeTicket = result.deal;
   double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
   g_tradeManager.RegisterTrade(m_activeTicket, m_magicNumber, m_rangeIndex, m_initialSlDistance, openPrice, m_rrRatio, m_partialClosePercent, m_trailingMode, m_trailingAtrPeriod, m_trailingAtrMultiplier, m_timeframe, m_trailingAtrHandle, m_trendFilterTimeframe);
   m_currentState = RANGE_TRADE_ACTIVE;
   CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " - " + (isBuy ? "BUY" : "SELL") + " Market Order Placed! Ticket: " + (string)m_activeTicket, m_rangeIndex);
   DisableOppositePath(isBuy);
   // یک شانس برای هر جهت: غیرفعال کردن تلاش مجدد برای این جهت
   if (isBuy) m_buyAttemptDisabled = true; else m_sellAttemptDisabled = true;
}



// (جدید) تابع برای کاشتن Stop Order در استراتژی پولبک
// این تابع Stop Order را به صورت دینامیک (با buffer) می‌کارد، SL و حجم را محاسبه می‌کند
void CRange::PlaceReversalStopOrder(bool isBuy)
{
   // 1. محاسبه متغیرهای اولیه
   double stopBuffer = 5 * _Point; // این مقدار میتواند در آینده به ورودی تبدیل شود
   double currentAsk = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double currentBid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double stopPrice = 0;
   double entryPriceForSL = 0; // قیمتی که SL بر اساس آن محاسبه میشود

   // 2. محاسبه دینامیک قیمت Stop Order
   if (isBuy)
   {
      // قیمت استاپ، کمی بالاتر از بیشینه (قیمت فعلی، خط شکست) خواهد بود
       stopPrice = NormalizePrice(fmax(m_potentialBuyPrice, currentAsk) + stopBuffer);
       entryPriceForSL = stopPrice; // برای محاسبه حجم، قیمت ورود را همان قیمت استاپ در نظر میگیریم
   }
   else
   {
       // قیمت استاپ، کمی پایین‌تر از کمینه (قیمت فعلی، خط شکست) خواهد بود
       stopPrice = NormalizePrice(fmin(m_potentialSellPrice, currentBid) - stopBuffer);
       entryPriceForSL = stopPrice;
   }

   // 3. محاسبه دقیق SL و حجم (این بخش شبیه ExecuteMarketOrder است)
   double adjustment;
   if(m_slCalcMode == SL_CALC_ATR) {
       double atr_buffer[];
       ArraySetAsSeries(atr_buffer, true);
       if(CopyBuffer(m_slAtrHandle, 0, 1, 1, atr_buffer) > 0)
           adjustment = atr_buffer[0] * m_slAtrMultiplier;
       else { CLogger::Log("خطا در گرفتن ATR برای SL پولبک.", m_rangeIndex); return; }
   } else {
       adjustment = (m_rangeHigh - m_rangeLow) * m_slAtrMultiplier / 100.0;
   }

   double basePoint = m_slStrategy == SL_OPPOSITE_SIDE ? (isBuy ? m_rangeLow : m_rangeHigh) : (isBuy ? m_rangeHigh : m_rangeLow);
   double slPrice = isBuy ? NormalizePrice(basePoint - adjustment) : NormalizePrice(basePoint + adjustment);
   m_initialSlDistance = MathAbs(entryPriceForSL - slPrice); // SL Distance بر اساس قیمت استاپ محاسبه میشود

   double lotSize = CRiskManager::CalculateLotSize(InpRiskPercent, m_initialSlDistance);
   if (lotSize == 0) { CLogger::Log("حجم صفر برای سفارش پولبک.", m_rangeIndex); ResetToArmedState(); return; }

   // 4. ساخت و ارسال درخواست Stop Order
   CTrade trade;
   MqlTradeRequest request;
   MqlTradeResult result;
   ZeroMemory(request);

   request.action = TRADE_ACTION_PENDING;
   request.symbol = _Symbol;
   request.volume = lotSize;
   request.type = isBuy ? ORDER_TYPE_BUY_STOP : ORDER_TYPE_SELL_STOP;
   request.price = stopPrice;
   request.sl = slPrice;
   request.magic = m_magicNumber;
   request.comment = StringFormat("PB;S;R%d;H:%.5f;L:%.5f;SLD:%.5f", m_rangeIndex, m_rangeHigh, m_rangeLow, m_initialSlDistance);
   request.type_time = ORDER_TIME_GTC; // یا میتوانی انقضا تعیین کنی

   if (!trade.OrderSend(request, result) || result.order == 0)
   {
       CLogger::Log("خطا در کاشتن Stop Order پولبک: " + IntegerToString(result.retcode), m_rangeIndex);
       ResetToArmedState();
       return;
   }

   m_pendingOrderTicket = result.order;
   m_currentState = RANGE_AWAITING_REVERSAL_TRIGGER;
   CLogger::Log("تله Stop Order پولبک با تیکت " + (string)m_pendingOrderTicket + " کاشته شد.", m_rangeIndex);
}

// ثبت استراتژی پولبک: شروع انتظار برای لمس خط پولبک و سپس ثبت Stop Order
// این تابع استراتژی جدید پولبک را مدیریت می‌کند
void CRange::PlacePullbackStrategyOrders(bool isBuy)  // ثبت استراتژی پولبک
{
    // این تابع فقط حالت را برای شروع فرآیند پولبک تنظیم می‌کند
    m_currentState = RANGE_AWAITING_PULLBACK_TOUCH;
    CLogger::Log("تصمیم به استراتژی پولبک گرفته شد. انتقال به حالت انتظار برای لمس خط.", m_rangeIndex);

    // OCO: به محض تصمیم به پولبک برای یک جهت، مسیر مخالف باید غیرفعال شود
    DisableOppositePath(isBuy);
}

// غیرفعال کردن مسیر مخالف: حذف خط و ریست قیمت بالقوه برای جلوگیری از سیگنال دوگانه
// این تابع OCO را شبیه‌سازی می‌کند
void CRange::DisableOppositePath(bool isBuy)  // تابع غیرفعال کردن
{
   if(isBuy)  // برای خرید
   {
      m_potentialSellPrice = 0;  // ریست قیمت فروش
      ObjectDelete(0, m_sellLineName);  // حذف خط فروش
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " - SELL path deactivated (OCO).", m_rangeIndex);  // چاپ دیباگ
   }
   else  // برای فروش
   {
      m_potentialBuyPrice = 0;  // ریست قیمت خرید
      ObjectDelete(0, m_buyLineName);  // حذف خط خرید
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " - BUY path deactivated (OCO).", m_rangeIndex);  // چاپ دیباگ
   }
}

// پاکسازی نرم: ریست متغیرها و حذف اشیاء بدون بستن معامله برای آماده‌سازی رنج بعدی
// این تابع برای ریست روزانه بدون بستن معامله است (اصلاح شده برای ریست متغیرهای جدید و حذف سفارش پندینگ)
void CRange::SoftCleanup()  // تابع پاکسازی نرم (اصلاح شده)
{
   CLogger::Log("پاکسازی نرم رنج " + IntegerToString(m_rangeIndex) + "...", m_rangeIndex);  // چاپ دیباگ برای پاکسازی نرم

   // حذف سفارش پندینگ اگر وجود داشته باشد (برای جلوگیری از یتیم ماندن)
   if(m_pendingOrderTicket != 0)  // چک تیکت معتبر
   {
      CTrade trade;  // نمونه معامله برای حذف
      if(OrderSelect(m_pendingOrderTicket))  // انتخاب سفارش
      {
         if(trade.OrderDelete(m_pendingOrderTicket))  // حذف سفارش
         {
            CLogger::Log("سفارش پندینگ رنج " + IntegerToString(m_rangeIndex) + " حذف شد (پاکسازی). تیکت: " + IntegerToString(m_pendingOrderTicket), m_rangeIndex);  // لاگ حذف
         }
         else
         {
            CLogger::Log("خطا در حذف سفارش پندینگ رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(trade.ResultRetcode()), m_rangeIndex);  // لاگ خطا
         }
      }
      m_pendingOrderTicket = 0;  // ریست تیکت
   }

   // ۱. پاکسازی متغیرهای مربوط به تلاش برای ورود
   m_potentialBuyPrice = 0;  // ریست قیمت خرید
   m_potentialSellPrice = 0;  // ریست قیمت فروش
   m_breakerCandleLevel = 0;  // ریست سطح بریک
   m_waitCounter = 0;  // ریست شمارنده

   // ۲. حذف تمام اشیاء گرافیکی مربوط به رنج
   ObjectDelete(0, m_buyLineName);  // حذف خط خرید
   ObjectDelete(0, m_sellLineName);  // حذف خط فروش
   ObjectDelete(0, m_rangeObjectName);  // حذف مستطیل رنج

   // ۳. ریست کردن متغیرهای کنترلی برای شناسایی رنج بعدی
   m_lastEndTime = 0;  // << بسیار مهم: این خط باگ اصلی قفل شدن را حل می‌کند
   m_lastInvalid = false;  // ریست فلگ نامعتبر

   // ۴. ریست کردن کش‌ها
   ResetCaches();  // ریست کش‌ها

   // ریست متغیر معامله
   m_activeTicket = 0;  // ریست تیکت
   
   // (جدید) ریست متغیرهای ابطال جهت‌ها در پاکسازی نرم (برای رنج جدید)
   m_buyAttemptDisabled = false;  // ریست فلگ غیرفعال خرید
   m_sellAttemptDisabled = false;  // ریست فلگ غیرفعال فروش
   m_isBuyAttempt = false;  // ریست جهت سیگنال
   m_breakerCandleTime = 0;  // ریست زمان بریک
   m_confirmationCandleTime = 0;  // ریست زمان تاییدیه

   // ۵. اضافه کردن علامت پاکسازی روی کندل فعلی (کد 217 برای OBJ_ARROW)
   string cleanupMarkerName = "Cleanup_Marker_" + IntegerToString(m_rangeIndex);  // نام علامت پاکسازی
   datetime currentTime = TimeCurrent();  // زمان فعلی برای علامت
   double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);  // قیمت فعلی برای علامت
   if(!ObjectCreate(0, cleanupMarkerName, OBJ_ARROW, 0, currentTime, currentPrice))  // رسم علامت
   {
      CLogger::Log("خطا در رسم علامت پاکسازی برای رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(GetLastError()), m_rangeIndex);  // چاپ خطا
   }
   else  // شرط موفقیت
   {
      ObjectSetInteger(0, cleanupMarkerName, OBJPROP_ARROWCODE, 217);  // کد علامت (217)
      ObjectSetInteger(0, cleanupMarkerName, OBJPROP_COLOR, clrYellow);  // رنگ زرد برای تمایز
   }

   // 6. تنظیم فلگ پاکسازی چرخه
   m_isCleanedForThisCycle = true;  // فلگ پاکسازی انجام شده
   m_cleanupTime = 0;  // ساعت پاکسازی را صفر کن تا این فرآیند تکرار نشود
   CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " پاکسازی نرم شد.", m_rangeIndex);  // چاپ موفقیت
}

// پاکسازی سخت: بستن معامله اگر باز باشد و سپس پاکسازی نرم (برای تعطیلات یا دفع)
// تغییرات 2.30: ریست دستی فلگ‌ها قبل از SoftCleanup و حذف سفارش پندینگ اگر وجود داشته باشد
void CRange::HardCleanup()  // تابع پاکسازی سخت
{
   CLogger::Log("پاکسازی سخت رنج " + IntegerToString(m_rangeIndex) + "...", m_rangeIndex);  // چاپ دیباگ برای پاکسازی سخت

   if(m_activeTicket != 0)  // چک معامله باز
   {
      if(g_tradeManager.ClosePosition(m_activeTicket))  // بستن کامل معامله از مدیر معاملات
      {
         CLogger::Log("معامله با تیکت " + (string)m_activeTicket + " بسته شد (سخت).", m_rangeIndex);  // چاپ دیباگ
      }
      // ریست کردن متغیرهای مربوط به معامله باز قبل از SoftCleanup
      m_activeTicket = 0;  // ریست تیکت پس از بستن
   }

   SoftCleanup();  // فراخوانی پاکسازی نرم پس از بستن و ریست متغیرها
   CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " پاکسازی سخت شد.", m_rangeIndex);  // چاپ موفقیت
}

// چک پاکسازی: چک زمان انقضا و فراخوانی پاکسازی مناسب بر اساس حالت (با معامله: فقط مسیرها، بدون: نرم)
// این تابع در OnTick فراخوانی می‌شود
void CRange::CheckCleanup()  // تابع چک پاکسازی
{
   // اگر زمان پاکسازی نرسیده یا قبلاً انجام شده، خارج شو
   if(m_cleanupTime == 0 || TimeCurrent() < m_cleanupTime || m_isCleanedForThisCycle) return;  // چک زمان و فلگ

   CLogger::Log("زمان پاکسازی فرا رسید...", m_rangeIndex);  // چاپ دیباگ
   m_currentState = RANGE_EXPIRED;  // تغییر به منقضی برای اجرای پاکسازی
}

// ریست کش‌ها: صفر کردن کش ATRها برای رنج جدید (برای جلوگیری از استفاده از داده‌های کهنه)
// این تابع کش‌ها را صفر می‌کند
void CRange::ResetCaches()  // تابع ریست کش
{
   m_cachedATR = 0;  // ریست کش ATR افست
   m_cachedSlATR = 0;  // ریست کش ATR SL
   m_cachedTrailingATR = 0;  // ریست کش ATR تریلینگ
   CLogger::Log("کش‌های ATR برای رنج " + IntegerToString(m_rangeIndex) + " ریست شدند.", m_rangeIndex);  // چاپ دیباگ
}

// گرفتن ATR کش‌شده اصلی: اگر کش خالی باشد، از هندل کپی می‌گیرد (فقط برای ورود استفاده شود)
// CopyBuffer بافر را کپی می‌کند
double CRange::GetCachedATR()  // تابع گرفتن ATR
{
   if(m_cachedATR <= 0)  // چک کش خالی
   {
      double atr[];  // آرایه ATR (دینامیک بدون اندازه ثابت)
      ArraySetAsSeries(atr, true);  // تنظیم سری
      if(CopyBuffer(m_atrHandle, 0, 1, 1, atr) <= 0)  // کپی بافر
      {
         CLogger::Log("خطا در گرفتن ATR برای رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(GetLastError()), m_rangeIndex);  // چاپ خطا
         return 0;  // بازگشت صفر
      }
      m_cachedATR = atr[0];  // ذخیره در کش
   }
   return m_cachedATR;  // بازگشت کش
}

// گرفتن ATR کش‌شده برای SL: مشابه برای بهینه‌سازی محاسبات SL (فقط برای ورود استفاده شود)
double CRange::GetSlATR()  // تابع گرفتن SL ATR
{
   if(m_cachedSlATR <= 0)  // چک کش خالی
   {
      double atr[];  // آرایه ATR (دینامیک بدون اندازه ثابت)
      ArraySetAsSeries(atr, true);  // تنظیم سری
      if(CopyBuffer(m_slAtrHandle, 0, 1, 1, atr) <= 0)  // کپی بافر
      {
         CLogger::Log("خطا در گرفتن ATR برای SL رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(GetLastError()), m_rangeIndex);  // چاپ خطا
         return 0;  // بازگشت صفر
      }
      m_cachedSlATR = atr[0];  // ذخیره در کش
   }
   return m_cachedSlATR;  // بازگشت کش
}

// گرفتن ATR کش‌شده برای تریلینگ: مشابه برای بهینه‌سازی تریلینگ (فقط برای ورود استفاده شود، برای مدیریت پویا استفاده نشود)
double CRange::GetTrailingATR()  // تابع گرفتن تریلینگ ATR
{
   if(m_cachedTrailingATR <= 0)  // چک کش خالی
   {
      double atr[];  // آرایه ATR (دینامیک بدون اندازه ثابت)
      ArraySetAsSeries(atr, true);  // تنظیم سری
      if(CopyBuffer(m_trailingAtrHandle, 0, 1, 1, atr) <= 0)  // کپی بافر
      {
         CLogger::Log("خطا در گرفتن ATR برای تریلینگ رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(GetLastError()), m_rangeIndex);  // چاپ خطا
         return 0;  // بازگشت صفر
      }
      m_cachedTrailingATR = atr[0];  // ذخیره در کش
   }
   return m_cachedTrailingATR;  // بازگشت کش
}

#endif // پایان چک include













//+------------------------------------------------------------------+
//|                                                     TradeManager.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CTradeManager را تعریف می‌کند که عملیات معاملاتی پیشرفته را مدیریت می‌کند.
// استراتژی کلی اکسپرت: این کلاس بخشی از مدیریت معامله در استراتژی شکست رنج است، 
// جایی که پس از باز شدن معامله، خروج پله‌ای (هنگام رسیدن به RR)، انتقال SL به ورود (برای حفظ سرمایه)، 
// تریلینگ (برای قفل سود) و بستن کامل (در پاکسازی سخت) انجام می‌شود. 
// این عملیات ریسک را کنترل و سود را به حداکثر می‌رساند.
// منطق فایل TradeManager.mqh: کلاس شامل متدهای استاتیک برای بستن جزئی (PartialClose با چک حجم مجاز)، 
// انتقال SL به بریک‌اون (MoveSLToBreakEven با نرمالایز قیمت)، 
// تریلینگ استاپ (TrailingStop با محاسبه فاصله ATR یا Senkou Span B و چک حداقل تغییر برای جلوگیری از به‌روزرسانی‌های بیهوده)، 
// و بستن کامل (ClosePosition). 
// تمام متدها PositionSelectByTicket را چک می‌کنند و از CTrade برای ارسال درخواست استفاده می‌کنند. 
// این فایل توسط CActiveTradeManager برای مدیریت معاملات در ManageAllTrades فراخوانی می‌شود و هیچ وابستگی خارجی ندارد جز Trade.mqh. 
// تغییرات جدید: اضافه منطق TRAILING_ICHIMOKU_B در TrailingStop با استفاده از GetSenkouSpanB و بافر ثابت (10 * _Point). 
// همچنین تغییر PartialClose به روش بستن مخالف برای سازگاری با بروکرها.
// تغییرات نسخه 2.30: جایگزینی Print با CLogger::Log، کامنت‌گذاری دقیق هر خط، بدون تغییر در منطق.

int INP_minichange = 5;

#ifndef TRADE_MANAGER_MQH  // چک وجود
#define TRADE_MANAGER_MQH  // تعریف ماکرو

#include <Trade\Trade.mqh>  // کلاس معامله برای عملیات

// کلاس CTradeManager برای عملیات معاملاتی استاتیک (بدون نیاز به نمونه‌سازی)
// تمام متدها استاتیک هستند برای سادگی فراخوانی
class CTradeManager  // کلاس مدیریت معامله
{
public:
   // بستن جزئی پوزیشن: محاسبه و بستن حجم مشخص با چک اضافی Magic برای امنیت
   // این متد با معامله مخالف جزئی می‌بندد
   static bool PartialClose(ulong ticket, double volume)  // بستن جزئی با تیکت و حجم
   {
      if(!PositionSelectByTicket(ticket))  // چک انتخاب پوزیشن
      {
         CLogger::Log("خطا: پوزیشن با تیکت " + (string)ticket + " برای بستن جزئی یافت نشد.");  // چاپ خطا
         return false;  // بازگشت شکست
      }

      // گرفتن اطلاعات ضروری از پوزیشن اصلی
      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);  // نوع پوزیشن
      string symbolName = PositionGetString(POSITION_SYMBOL);  // نماد

      // آماده کردن درخواست معامله جدید (مخالف پوزیشن اصلی)
      CTrade trade;  // نمونه کلاس معامله
      MqlTradeRequest request;  // درخواست معامله
      MqlTradeResult result;  // نتیجه معامله
      ZeroMemory(request);  // صفر کردن درخواست

      request.action   = TRADE_ACTION_DEAL;              // نوع عملیات: معامله
      request.symbol   = symbolName;                     // نماد معامله
      request.volume   = volume;                         // حجمی که می‌خواهیم ببندیم
      request.deviation = 10;                            // انحراف مجاز قیمت
      request.magic    = (long)PositionGetInteger(POSITION_MAGIC); // مجیک نامبر باید یکی باشه

      // لینک کردن این درخواست به پوزیشن باز موجود
      request.position = ticket; // لینک به پوزیشن برای بستن جزئی

      // تعیین نوع معامله مخالف
      if(posType == POSITION_TYPE_BUY)  // اگر پوزیشن خرید، برای بستن جزئی فروش می‌زنیم
      {
         request.price = SymbolInfoDouble(symbolName, SYMBOL_BID);  // برای بستن خرید، با قیمت BID می‌فروشیم
         request.type = ORDER_TYPE_SELL;  // نوع فروش
      }
      else  // اگر پوزیشن فروش، برای بستن جزئی خرید می‌زنیم
      {
         request.price = SymbolInfoDouble(symbolName, SYMBOL_ASK);  // برای بستن فروش، با قیمت ASK می‌خریم
         request.type = ORDER_TYPE_BUY;  // نوع خرید
      }

      // ارسال درخواست و بررسی نتیجه
      if(trade.OrderSend(request, result))  // ارسال درخواست معامله مخالف
      {
         if(result.retcode == TRADE_RETCODE_DONE || result.retcode == TRADE_RETCODE_PLACED)  // چک موفقیت
         {
            if(InpDebugMode) CLogger::Log("بخشی از پوزیشن با تیکت " + (string)ticket + " (حجم " + DoubleToString(volume, 2) + ") با موفقیت بسته شد.");  // چاپ موفقیت
            return true;  // بازگشت موفقیت
         }
      }

      CLogger::Log("خطا در بستن بخشی از پوزیشن با تیکت " + (string)ticket + ": " + IntegerToString(result.retcode) + " - " + result.comment);  // چاپ خطا
      return false;  // بازگشت شکست
   }

   // انتقال SL به بریک‌اون: نرمالایز قیمت و تغییر SL به نقطه ورود
   // NormalizeDouble قیمت را نرمال می‌کند
   static bool MoveSLToBreakEven(ulong ticket, double breakEvenPrice)  // انتقال SL به ورود
   {
      if(!PositionSelectByTicket(ticket))  // چک انتخاب پوزیشن
      {
         CLogger::Log("خطا: پوزیشن با تیکت " + (string)ticket + " یافت نشد.");  // چاپ خطا
         return false;  // بازگشت شکست
      }

      CTrade trade;  // نمونه کلاس معامله
      breakEvenPrice = NormalizeDouble(breakEvenPrice, _Digits);  // نرمالایز قیمت
      if(trade.PositionModify(ticket, breakEvenPrice, PositionGetDouble(POSITION_TP)))  // تغییر SL
      {
         CLogger::Log("استاپ لاس پوزیشن " + (string)ticket + " به نقطه ورود منتقل شد.");  // چاپ موفقیت
         return true;  // بازگشت موفقیت
      }
      else  // شرط شکست
      {
         CLogger::Log("خطا در انتقال استاپ لاس پوزیشن " + (string)ticket + ": " + IntegerToString(trade.ResultRetcode()));  // چاپ خطا
         return false;  // بازگشت شکست
      }
   }

   // اعمال تریلینگ استاپ: محاسبه فاصله جدید، چک حداقل تغییر و تغییر SL (محاسبه پویا ATR یا Senkou Span B هر بار)
   // این متد پویا محاسبه می‌کند
   static bool TrailingStop(ulong ticket, ENUM_TRAILING_MODE mode, int atrPeriod, double atrMultiplier, ENUM_TIMEFRAMES timeframe, int atrHandle, ENUM_TIMEFRAMES trendTf)  // تریلینگ با پارامترها و تایم‌فریم فیلتر
   {
      if(!PositionSelectByTicket(ticket))  // چک انتخاب پوزیشن
      {
         CLogger::Log("خطا: پوزیشن با تیکت " + (string)ticket + " یافت نشد.");  // چاپ خطا
         return false;  // بازگشت شکست
      }

      double sl = PositionGetDouble(POSITION_SL);  // SL فعلی
      if(sl == 0)  // چک SL صفر
      {
         CLogger::Log("هشدار: SL اولیه صفر است برای پوزیشن " + (string)ticket + ". تریلینگ skip شد.");  // چاپ هشدار
         return false;  // بازگشت شکست
      }

      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);  // نوع پوزیشن
      double currentPrice = posType == POSITION_TYPE_BUY ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);  // قیمت فعلی

      double trailingDistance;  // فاصله تریلینگ
      if(mode == TRAILING_ATR)  // چک حالت ATR
      {
         double atr[];  // آرایه ATR (دینامیک بدون اندازه ثابت)
         ArraySetAsSeries(atr, true);  // تنظیم سری
         if(CopyBuffer(atrHandle, 0, 1, 1, atr) <= 0)  // کپی بافر
         {
            CLogger::Log("خطا در گرفتن ATR برای تریلینگ: " + IntegerToString(GetLastError()));  // چاپ خطا
            return false;  // بازگشت شکست
         }
         trailingDistance = atr[0] * atrMultiplier;  // محاسبه پویا هر بار بدون کش
      }
      else if(mode == TRAILING_ICHIMOKU_B)  // حالت جدید: TRIALING بر اساس Senkou Span B
      {
         double senkouB = g_trendFilter.GetSenkouSpanB(trendTf);  // گرفتن Senkou Span B از فیلتر روند
         if(senkouB == 0)  // چک مقدار معتبر
         {
            CLogger::Log("خطا در گرفتن Senkou Span B برای تریلینگ.");  // چاپ خطا
            return false;  // بازگشت شکست
         }
         double buffer = 10 * _Point;  // بافر ثابت (10 پوینت) برای فاصله از خط
         trailingDistance = buffer;  // فاصله بر اساس بافر (برای تنظیم SL نسبت به Senkou B)
         // برای خرید: SL کمی پایین‌تر از Senkou B
         // برای فروش: SL کمی بالاتر از Senkou B
      }
      else  // حالت نامعتبر (برای ایمنی)
      {
         return false;  // بازگشت شکست
      }

      double trailing = posType == POSITION_TYPE_BUY ? currentPrice - trailingDistance : currentPrice + trailingDistance;  // محاسبه SL جدید
      trailing = NormalizeDouble(trailing, _Digits);  // نرمالایز
      if((posType == POSITION_TYPE_BUY && trailing > sl) || (posType == POSITION_TYPE_BUY && trailing < sl))  // چک بهبود
      {
         if(MathAbs(trailing - sl) < _Point * INP_minichange) return true;  // بدون تغییر اگر کم
         CTrade trade;  // نمونه
         if(trade.PositionModify(ticket, trailing, PositionGetDouble(POSITION_TP)))  // تغییر
         {
            CLogger::Log("تریلینگ SL به‌روزرسانی شد برای تیکت " + (string)ticket);  // لاگ
            return true;
         }
      }
      return true;
   }

   // بستن کامل پوزیشن: انتخاب و بستن با چک نتیجه
   // PositionClose پوزیشن را می‌بندد
   static bool ClosePosition(ulong ticket)  // بستن کامل با تیکت
   {
      if(!PositionSelectByTicket(ticket))  // چک انتخاب پوزیشن
      {
         CLogger::Log("خطا: پوزیشن با تیکت " + (string)ticket + " یافت نشد.");  // چاپ خطا
         return false;  // بازگشت شکست
      }

      CTrade trade;  // نمونه معامله
      if(trade.PositionClose(ticket))  // بستن کامل
      {
         CLogger::Log("پوزیشن با تیکت " + (string)ticket + " بسته شد.");  // چاپ موفقیت
         return true;  // بازگشت موفقیت
      }
      else  // شرط شکست
      {
         CLogger::Log("خطا در بستن پوزیشن با تیکت " + (string)ticket + ": " + IntegerToString(trade.ResultRetcode()));  // چاپ خطا
         return false;  // بازگشت شکست
      }
   }
};

#endif  // پایان






//+------------------------------------------------------------------+
//|                                          CActiveTradeManager.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CActiveTradeManager را تعریف می‌کند که مدیریت تمام معاملات باز را بر عهده دارد.
// استراتژی کلی: این کلاس معاملات باز را از CRange دریافت می‌کند و مدیریت می‌کند (پله‌ای، ریسک-فری، تریلینگ).
// منطق فایل: آرایه ManagedTrade برای ذخیره اطلاعات هر معامله، ماشین حالت داخلی برای هر معامله (TRADE_PARTIAL_CLOSE, TRADE_RISK_FREE, TRADE_TRAILING).
// RegisterTrade معامله را اضافه می‌کند، ManageAllTrades تمام معاملات را مدیریت می‌کند و حالت‌ها را بروزرسانی می‌کند.
// ClosePosition برای بستن کامل استفاده می‌شود.
// تغییرات جدید: کلاس جدید بر اساس بلوپرینت، با ماشین حالت داخلی برای هر معامله.
// تغییرات نسخه 2.30: بدون تغییر در منطق، فقط کامنت‌گذاری به‌روزرسانی شده برای سازگاری با پولبک.

int INP_breakEvenBuffer = 5;

#ifndef ACTIVE_TRADE_MANAGER_MQH
#define ACTIVE_TRADE_MANAGER_MQH

#include "TradeManager.mqh"  // برای PartialClose, MoveSLToBreakEven, TrailingStop
#include "Logger.mqh"  // برای لاگ

// enum برای حالت‌های مدیریت هر معامله (ماشین حالت داخلی)
enum ENUM_TRADE_MANAGEMENT_STATE
{
   TRADE_PARTIAL_CLOSE,   // مرحله خروج پله‌ای
   TRADE_RISK_FREE,       // مرحله ریسک-فری
   TRADE_TRAILING         // مرحله تریلینگ
};

// ساختار برای هر معامله مدیریت‌شده
struct ManagedTrade
{
   ulong ticket;  // تیکت معامله
   long magicNumber;  // مجیک برای تمایز
   int rangeIndex;  // ایندکس رنج (1-4)
   double initialSlDistance;  // فاصله SL اولیه
   double entryPrice;  // قیمت ورود
   bool isPartialClosed;  // فلگ پله‌ای
   bool isRiskFree;  // فلگ ریسک-فری
   double rrRatio;  // نسبت RR
   double partialClosePercent;  // درصد پله‌ای
   ENUM_TRAILING_MODE trailingMode;  // حالت تریلینگ
   int trailingAtrPeriod;  // دوره ATR تریلینگ
   double trailingAtrMultiplier;  // ضریب تریلینگ
   ENUM_TIMEFRAMES timeframe;  // تایم‌فریم
   int atrHandle;  // هندل ATR
   ENUM_TIMEFRAMES trendTf;  // تایم‌فریم فیلتر
   ENUM_TRADE_MANAGEMENT_STATE currentState;  // حالت فعلی مدیریت
};

// کلاس CActiveTradeManager برای مدیریت تمام معاملات باز
class CActiveTradeManager
{
private:
   ManagedTrade m_managedTrades[];  // آرایه معاملات مدیریت‌شده

public:
   CActiveTradeManager() {}  // سازنده

   // ثبت معامله جدید: اضافه به آرایه و تنظیم حالت اولیه
   void RegisterTrade(ulong ticket, long magicNumber, int rangeIndex, double initialSlDistance, double entryPrice, double rrRatio, double partialClosePercent,
                      ENUM_TRAILING_MODE trailingMode, int trailingAtrPeriod, double trailingAtrMultiplier, ENUM_TIMEFRAMES timeframe, int atrHandle, ENUM_TIMEFRAMES trendTf)
   {
      int size = ArraySize(m_managedTrades);  // اندازه فعلی آرایه
      ArrayResize(m_managedTrades, size + 1);  // افزایش اندازه
      
      // دسترسی مستقیم به عنصر آرایه به جای استفاده از رفرنس
      m_managedTrades[size].ticket = ticket;  // تنظیم تیکت
      m_managedTrades[size].magicNumber = magicNumber;  // تنظیم مجیک
      m_managedTrades[size].rangeIndex = rangeIndex;  // تنظیم ایندکس رنج
      m_managedTrades[size].initialSlDistance = initialSlDistance;  // تنظیم فاصله SL
      m_managedTrades[size].entryPrice = entryPrice;  // تنظیم قیمت ورود
      m_managedTrades[size].isPartialClosed = false;  // ریست فلگ پله‌ای
      m_managedTrades[size].isRiskFree = false;  // ریست فلگ ریسک-فری
      m_managedTrades[size].rrRatio = rrRatio;  // تنظیم RR
      m_managedTrades[size].partialClosePercent = partialClosePercent;  // تنظیم درصد پله‌ای
      m_managedTrades[size].trailingMode = trailingMode;  // تنظیم حالت تریلینگ
      m_managedTrades[size].trailingAtrPeriod = trailingAtrPeriod;  // تنظیم دوره ATR
      m_managedTrades[size].trailingAtrMultiplier = trailingAtrMultiplier;  // تنظیم ضریب
      m_managedTrades[size].timeframe = timeframe;  // تنظیم تایم‌فریم
      m_managedTrades[size].atrHandle = atrHandle;  // تنظیم هندل ATR
      m_managedTrades[size].trendTf = trendTf;  // تنظیم تایم‌فریم فیلتر
      m_managedTrades[size].currentState = TRADE_PARTIAL_CLOSE;  // حالت اولیه: پله‌ای
      CLogger::Log("معامله جدید ثبت شد. تیکت: " + (string)ticket + ", رنج: " + IntegerToString(rangeIndex));  // لاگ ثبت
   }

   // مدیریت تمام معاملات: حلقه روی آرایه، چک بسته شدن، و اجرای ماشین حالت داخلی
   void ManageAllTrades()
   {
      for(int i = ArraySize(m_managedTrades) - 1; i >= 0; i--)  // حلقه از انتها برای حذف ایمن
      {
         // دسترسی مستقیم به عنصر آرایه به جای استفاده از رفرنس
         if(!PositionSelectByTicket(m_managedTrades[i].ticket))  // چک باز بودن
         {
            CLogger::Log("معامله با تیکت " + (string)m_managedTrades[i].ticket + " بسته شده. حذف از لیست.", m_managedTrades[i].rangeIndex);  // لاگ بسته شدن
           
           int rangeIdx_to_reset = m_managedTrades[i].rangeIndex;
           ArrayRemove(m_managedTrades, i, 1);  // حذف از آرایه
            g_ranges[rangeIdx_to_reset- 1].SetCurrentState(RANGE_IDLE);  // اطلاع به رنج مربوطه
            continue;  // پرش
         }

         // لاگ ورود به مدیریت معامله
         CLogger::Log("------ مدیریت معامله تیکت " + (string)m_managedTrades[i].ticket + " در حالت " + EnumToString(m_managedTrades[i].currentState) + " ------", m_managedTrades[i].rangeIndex);  // عنوان حالت مدیریت

         switch(m_managedTrades[i].currentState)  // ماشین حالت داخلی
         {
            case TRADE_PARTIAL_CLOSE:  // مرحله پله‌ای
            { // آکولاد برای حل اخطار کامپایلر اضافه شد
               double currentPrice = PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
               double currentProfit = (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY ? (currentPrice - m_managedTrades[i].entryPrice) : (m_managedTrades[i].entryPrice - currentPrice));
               double targetProfit = m_managedTrades[i].initialSlDistance * m_managedTrades[i].rrRatio;
               
               if(currentProfit >= targetProfit)  // چک رسیدن
               {
                  double volume = PositionGetDouble(POSITION_VOLUME);  // حجم فعلی
                  double closeVolume = MathFloor((volume * m_managedTrades[i].partialClosePercent / 100.0) / g_volumeStep) * g_volumeStep;  // حجم پله‌ای
                  if(closeVolume >= g_volumeMin && closeVolume < volume)  // چک معتبر
                  {
                     if(CTradeManager::PartialClose(m_managedTrades[i].ticket, closeVolume))  // بستن پله‌ای
                     {
                        m_managedTrades[i].isPartialClosed = true;  // تنظیم فلگ
                        m_managedTrades[i].currentState = TRADE_RISK_FREE;  // انتقال به ریسک-فری
                        CLogger::Log("خروج پله‌ای انجام شد. انتقال به RISK_FREE.", m_managedTrades[i].rangeIndex);  // لاگ انتقال
                     }
                  }
               }
               break;
            } // پایان آکولاد
            case TRADE_RISK_FREE:  // مرحله ریسک-فری
               if(!m_managedTrades[i].isRiskFree)  // چک فلگ
               {
                  double breakEvenBuffer = _Point * INP_breakEvenBuffer;  // بافر
                  double newSL = (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) ? m_managedTrades[i].entryPrice + breakEvenBuffer : m_managedTrades[i].entryPrice - breakEvenBuffer;  // SL جدید
                  if(CTradeManager::MoveSLToBreakEven(m_managedTrades[i].ticket, newSL))  // انتقال
                  {
                     m_managedTrades[i].isRiskFree = true;  // تنظیم فلگ
                     m_managedTrades[i].currentState = TRADE_TRAILING;  // انتقال به تریلینگ
                     CLogger::Log("ریسک-فری انجام شد. انتقال به TRAILING.", m_managedTrades[i].rangeIndex);  // لاگ انتقال
                  }
               }
               break;
            case TRADE_TRAILING:  // مرحله تریلینگ
               CTradeManager::TrailingStop(m_managedTrades[i].ticket, m_managedTrades[i].trailingMode, m_managedTrades[i].trailingAtrPeriod, m_managedTrades[i].trailingAtrMultiplier, m_managedTrades[i].timeframe, m_managedTrades[i].atrHandle, m_managedTrades[i].trendTf);  // تریلینگ
               break;
         }
      }
   }

   // بستن کامل معامله: فراخوانی از HardCleanup
   bool ClosePosition(ulong ticket)
   {
      return CTradeManager::ClosePosition(ticket);  // استفاده از TradeManager برای بستن
   }

   // تنظیم فلگ پله‌ای برای بازیابی
   void SetPartialClosedFlag(ulong ticket, bool value)
   {
      for(int i = 0; i < ArraySize(m_managedTrades); i++)
      {
         if(m_managedTrades[i].ticket == ticket)
         {
            m_managedTrades[i].isPartialClosed = value;  // تنظیم فلگ
            break;
         }
      }
   }
};

// مقداردهی اولیه متغیر استاتیک
string CLogger::m_lastMessage = "";  // اولیه برای لاگ

#endif









//+------------------------------------------------------------------+
//|                                                     RiskManager.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CRiskManager را تعریف می‌کند که محاسبه ریسک و حجم را مدیریت می‌کند.
// استراتژی کلی اکسپرت: ریسک هر معامله بر اساس درصد موجودی حساب و فاصله SL محاسبه می‌شود تا زیان محدود شود. 
// این کلاس حجم را طوری تعیین می‌کند که زیان SL برابر درصد ریسک باشد، مستقل از نوع نماد (فارکس، شاخص، JPY).
// منطق فایل RiskManager.mqh: متد استاتیک CalculateLotSize فاصله SL (قیمت واقعی) را می‌گیرد، 
// ریسک به ازای هر لات را با فرمول slDistance * (g_tickValue / g_tickSize) محاسبه می‌کند 
// (برای سازگاری با نمادهای مختلف)، حجم را بر اساس ریسک مطلوب تعیین می‌کند و به گام حجم راند می‌کند. 
// چک‌های ولید برای جلوگیری از حجم نامعتبر اضافه شده. 
// این فایل توسط CRange برای محاسبه حجم در PlacePullbackOrder فراخوانی می‌شود. 
// تغییرات: هیچ تغییری لازم نبود، اما کامنت‌ها به‌روزرسانی شد.
// تغییرات نسخه 2.30: جایگزینی Print با CLogger::Log، کامنت‌گذاری دقیق. هیچ تغییری اعمال نشده زیرا بلوپرینت تغییری مشخص نکرده.

#ifndef RISK_MANAGER_MQH  // چک
#define RISK_MANAGER_MQH  // تعریف

extern double g_tickValue;  // ارزش تیک خارجی (از Elemento کش‌شده)
extern double g_tickSize;  // اندازه تیک خارجی
extern double g_volumeStep;  // گام حجم خارجی
extern double g_volumeMin;  // حداقل حجم خارجی
extern double g_volumeMax;  // حداکثر حجم خارجی

// کلاس CRiskManager برای محاسبه حجم معاملاتی بر اساس ریسک
// متد استاتیک برای سادگی
class CRiskManager  // کلاس ریسک
{
public:
   // محاسبه حجم: بر اساس درصد ریسک و فاصله SL، با فرمول سازگار برای تمام نمادها
   static double CalculateLotSize(double riskPercent, double slDistance)  // محاسبه لات با ریسک و فاصله SL
   {
      if(g_tickValue == 0 || g_tickSize == 0)  // چک مقادیر کش معتبر
      {
         CLogger::Log("خطا: tickValue یا tickSize صفر است. محاسبه حجم ممکن نیست.");  // چاپ خطا
         return 0;  // بازگشت صفر
      }

      // اگر g_tickSizeصفر باشد (نادر)، default به _Point برای سازگاری
      if(g_tickSize == 0) g_tickSize = _Point;  // تنظیم پیش‌فرض اندازه تیک

      double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);  // موجودی حساب
      double riskPerLot = slDistance * (g_tickValue / g_tickSize);  // ریسک به ازای هر لات

      if (riskPerLot <= 0)  // چک ریسک معتبر
      {
          CLogger::Log("خطا: ریسک به ازای هر لات نامعتبر است. slDistance=" + DoubleToString(slDistance, _Digits));  // چاپ خطا
          return 0;  // بازگشت صفر
      }

      double riskAmount = riskPercent / 100.0 * accountBalance;  // مقدار ریسک مطلق
      double lotSize = riskAmount / riskPerLot;  // حجم اولیه

      lotSize = MathRound(lotSize / g_volumeStep) * g_volumeStep;  // راند به گام حجم
      lotSize = MathMax(g_volumeMin, MathMin(g_volumeMax, lotSize));  // محدود به min/max

      if(lotSize < g_volumeMin)  // چک کمتر از حداقل
      {
         CLogger::Log("خطا: حجم محاسبه شده (" + DoubleToString(lotSize, 2) + ") کمتر از حداقل (" + DoubleToString(g_volumeMin, 2) + ") است.");  // چاپ خطا
         return 0;  // بازگشت صفر
      }

      if(InpDebugMode) CLogger::Log("حجم محاسبه شده: " + DoubleToString(lotSize, 2) + ", slDistance=" + DoubleToString(slDistance, _Digits) + ", riskPerLot=" + DoubleToString(riskPerLot, 2));  // چاپ دیباگ
      return lotSize;  // بازگشت حجم
   }
};

#endif  // پایان|





//+------------------------------------------------------------------+
//|                                                     TimeHelper.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CTimeHelper را تعریف می‌کند که محاسبات زمانی را مدیریت می‌کند.
// استراتژی کلی اکسپرت: زمان‌های رنج و پاکسازی بر اساس ساعات محلی سرور محاسبه می‌شود تا رنج‌ها دقیقاً در بازه‌های تعریف‌شده عمل کنند و پس از انقضا پاک شوند.
// منطق فایل TimeHelper.mqh: متدهای استاتیک CalculateRangeTimes زمان شروع/پایان رنج را محاسبه می‌کند 
// (با مدیریت رنج‌های شبانه و تنظیم بر اساس روز فعلی)، 
// و CalculateCleanupTime زمان انقضا را بر اساس ساعت‌های پاکسازی اضافه می‌کند. 
// این فایل توسط CRange برای تعیین زمان‌ها استفاده می‌شود و وابستگی به TimeCurrent دارد. 
// تغییرات جدید در نسخه 2.30: اصلاح CalculateRangeTimes برای مدیریت DST با GMT offset و حلقه برای روز معاملاتی قبلی، 
// اصلاح CalculateCleanupTime برای پذیرش datetime rangeEndTime و محاسبه ساده cleanupTime = rangeEndTime + cleanupHours * 3600 
// برای جلوگیری از باگ محاسبه در رنج‌های شبانه.
// تغییرات نسخه 2.30: کامنت‌گذاری دقیق، بدون Print (استاتیک).

#ifndef TIME_HELPER_MQH  // چک
#define TIME_HELPER_MQH  // تعریف

// کلاس CTimeHelper برای محاسبات زمانی رنج و پاکسازی
// متدها استاتیک برای سادگی
class CTimeHelper  // کلاس زمان
{
public:
   // محاسبه زمان شروع و پایان رنج: تنظیم بر اساس روز فعلی و مدیریت رنج‌های عبور از نیمه‌شب
   // TimeToStruct زمان را به ساختار تبدیل می‌کند
   static bool CalculateRangeTimes(int startHour, int startMinute, int endHour, int endMinute, datetime &startTime, datetime &endTime)  // محاسبه زمان رنج
   {
      long server_gmt_offset = TimeTradeServer()-TimeGMT();  // گرفتن افست GMT سرور (برای DST)
      datetime gmt_now = TimeGMT();  // زمان GMT فعلی
      MqlDateTime dt_gmt;  // ساختار زمان GMT
      TimeToStruct(gmt_now, dt_gmt);  // تبدیل به ساختار

      datetime gmt_today_start = gmt_now - (dt_gmt.hour * 3600 + dt_gmt.min * 60 + dt_gmt.sec);  // شروع روز GMT

      datetime gmt_start_time = gmt_today_start + startHour * 3600 + startMinute * 60;  // زمان شروع GMT
      datetime gmt_end_time = gmt_today_start + endHour * 3600 + endMinute * 60;  // زمان پایان GMT

      if(gmt_end_time <= gmt_start_time)  // چک رنج شبانه
      {
         gmt_end_time += 86400;  // اضافه روز
      }

      // حلقه هوشمند هوشمند برای پیدا کردن آخرین روز معاملاتی (برای آخر هفته‌ها و کریپتو)
      while(gmt_now < gmt_start_time)  // چک زمان فعلی قبل از شروع
      {
         gmt_start_time -= 86400;  // عقب بردن به روز قبل
         gmt_end_time -= 86400;  // عقب بردن پایان

         MqlDateTime check_day_dt;  // ساختار روز چک
         TimeToStruct(gmt_start_time, check_day_dt);  // تبدیل
         datetime session_from, session_to;  // زمان جلسه

         // اگر این روز جلسه معاملاتی ندارد (مثل شنبه برای فارکس)، یک روز دیگر عقب برو
         if(!SymbolInfoSessionTrade(_Symbol, (ENUM_DAY_OF_WEEK)check_day_dt.day_of_week, 0, session_from, session_to))  // چک جلسه
         {
            CLogger::Log("روز غیر معاملاتی شناسایی شد: " + TimeToString(gmt_start_time, TIME_DATE) + ". بررسی روز قبل...", 0);  // چاپ دیباگ
            continue;  // پرش
         }
         break;  // روز معاملاتی پیدا شد
      }

      startTime = (datetime)(gmt_start_time + server_gmt_offset);  // تنظیم زمان محلی شروع
      endTime = (datetime)(gmt_end_time + server_gmt_offset);  // تنظیم زمان محلی پایان

      if(InpDebugMode) CLogger::Log("محاسبه زمان رنج (GMT Aware): Start=" + TimeToString(startTime) + ", End=" + TimeToString(endTime));  // چاپ دیباگ
      return true;  // بازگشت موفقیت
   }

   // محاسبه زمان پاکسازی: اضافه کردن ساعت‌های پاکسازی به زمان پایان برای انقضا (نسخه اصلاح شده)
   // محاسبه ساده برای دقت
   static datetime CalculateCleanupTime(datetime rangeEndTime, int cleanupHours)  // محاسبه زمان پاکسازی
   {
      datetime cleanupTime = rangeEndTime + cleanupHours * 3600;  // به همین سادگی!
      if(InpDebugMode) CLogger::Log("زمان پاکسازی محاسبه شد: " + TimeToString(cleanupTime));  // چاپ دیباگ
      return cleanupTime;  // بازگشت زمان
   }
};

#endif  // پایان









//+------------------------------------------------------------------+
//|                                                     TrendFilter.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CTrendFilter را تعریف می‌کند که فیلتر روند بر اساس ایچیموکو را مدیریت می‌کند.
// استراتژی کلی اکسپرت: فیلتر روند برای جلوگیری از معاملات خلاف جهت استفاده می‌شود؛ 
// اگر ابر ایچیموکو فلت (خنثی) یا هم‌جهت باشد، معامله مجاز است، иначе رد می‌شود.
// منطق فایل TrendFilter.mqh: enum ENUM_TREND_DIRECTION برای خروجی (BUY/SELL/NEUTRAL). 
// تابع GetTrendDirection سنکو A/B را به طور دستی محاسبه می‌کند 
// (با استفاده از iHigh/iLow برای دوره‌های تنکان، کیجون و سنکو B)، 
// تفاوت را چک می‌کند (اگر کمتر از آستانه، خنثی)، 
// و جهت را تعیین می‌کند (A > B برای BUY). 
// این محاسبه دستی برای جلوگیری از مشکلات دسترسی به کندل‌های آینده در MT5 انجام می‌شود. 
// Init/Deinit خالی هستند زیرا هیچ هندلی ثابت نیست. 
// این فایل توسط CRange برای تأیید فیلتر مستقل فراخوانی می‌شود. 
// تغییرات جدید در نسخه 2.30: اضافه تابع GetSenkouSpanB برای بازگشت مقدار Senkou Span B برای استفاده در تریلینگ.
// اضافه کردن Inp_IchimokuMode برای انتخاب بین Kumo و Chikou.
// بازنویسی GetTrendDirection به switch، با private GetKumoTrend و GetChikouTrend.
// اضافه GetTrendDirectionForTime برای تحلیل در زمان خاص.

#ifndef TREND_FILTER_MQH  // چک
#define TREND_FILTER_MQH  // تعریف

// تعریف enum برای جهت روند (برای تصمیم‌گیری در فیلتر)
// این enum خروجی فیلتر را استاندارد می‌کند
enum ENUM_TREND_DIRECTION
{
   TREND_BUY,     // روند صعودی (سنکو A بالای B) - جهت خرید مجاز
   TREND_SELL,    // روند نزولی (سنکو A پایین B) - جهت فروش مجاز
   TREND_NEUTRAL  // روند خنثی (ابر فلت یا فیلتر خاموش) - هر جهتی مجاز
};

// کلاس CTrendFilter برای فیلتر روند پویا بر اساس ایچیموکو
// محاسبات دستی بدون هندل
class CTrendFilter  // کلاس فیلتر روند
{
private:
   // (جدید) محاسبه روند بر اساس ابر کومو (روش فعلی)
   ENUM_TREND_DIRECTION GetKumoTrend(ENUM_TIMEFRAMES timeframe, int shift)  // محاسبه ابر کومو
   {
      // محاسبه تنکان-سن
      int tenkanHighIdx = iHighest(_Symbol, timeframe, MODE_HIGH, Inp_Ichimoku_Tenkan, shift);  // ایندکس سقف تنکان
      int tenkanLowIdx = iLowest(_Symbol, timeframe, MODE_LOW, Inp_Ichimoku_Tenkan, shift);  // ایندکس کف تنکان
      double tenkanHigh = iHigh(_Symbol, timeframe, tenkanHighIdx);  // های تنکان
      double tenkanLow = iLow(_Symbol, timeframe, tenkanLowIdx);  // لو تنکان
      double tenkan = (tenkanHigh + tenkanLow) / 2.0;  // تنکان-سن

      // محاسبه کیجون-سن
      int kijunHighIdx = iHighest(_Symbol, timeframe, MODE_HIGH, Inp_Ichimoku_Kijun, shift);  // ایندکس سقف کیجون
      int kijunLowIdx = iLowest(_Symbol, timeframe, MODE_LOW, Inp_Ichimoku_Kijun, shift);  // ایندکس کف کیجون
      double kijunHigh = iHigh(_Symbol, timeframe, kijunHighIdx);  // های کیجون
      double kijunLow = iLow(_Symbol, timeframe, kijunLowIdx);  // لو کیجون
      double kijun = (kijunHigh + kijunLow) / 2.0;  // کیجون-سن

      // محاسبه سنکو اسپن A
      double senkouA = (tenkan + kijun) / 2.0;  // سنکو A

      // محاسبه سنکو اسپن B
      int senkouBHighIdx = iHighest(_Symbol, timeframe, MODE_HIGH, Inp_Ichimoku_SenkouB, shift);  // ایندکس سقف سنکو B
      int senkouBLowIdx = iLowest(_Symbol, timeframe, MODE_LOW, Inp_Ichimoku_SenkouB, shift);  // ایندکس کف سنکو B
      double senkouBHigh = iHigh(_Symbol, timeframe, senkouBHighIdx);  // های سنکو B
      double senkouBLow = iLow(_Symbol, timeframe, senkouBLowIdx);  // لو سنکو B
      double senkouB = (senkouBHigh + senkouBLow) / 2.0;  // سنکو B

      double diff = MathAbs(senkouA - senkouB) / _Point;  // تفاوت به پوینت
      if(diff < Inp_Ichimoku_FlatThreshold_Points) return TREND_NEUTRAL;  // فلت
      return senkouA > senkouB ? TREND_BUY : TREND_SELL;  // جهت
   }

   // (جدید) محاسبه روند بر اساس Chikou Span (روش جدید)
   ENUM_TREND_DIRECTION GetChikouTrend(ENUM_TIMEFRAMES timeframe, int shift)  // محاسبه چیکو اسپن
   {
      double chikou = iClose(_Symbol, timeframe, shift);  // چیکو = کلوز فعلی
      double price26Back = iClose(_Symbol, timeframe, shift + Inp_Ichimoku_Kijun);  // قیمت 26 کندل قبل
      if(chikou > price26Back) return TREND_BUY;  // صعودی
      if(chikou < price26Back) return TREND_SELL;  // نزولی
      return TREND_NEUTRAL;  // خنثی
   }

public:
   CTrendFilter() {}  // سازنده پیش‌فرض - هیچ مقداری اولیه ندارد

   // Init خالی (هیچ هندلی ثابت ساخته نمی‌شود، محاسبه دستی در GetTrendDirection)
   bool Init() { return true; }  // مقداردهی - همیشه موفقیت

   // Deinit خالی (هیچ منبعی ثابت برای آزادسازی نیست)
   void Deinit() {}  // دفع - هیچ عملی

   // گرفتن جهت روند: محاسبه دستی سنکو A/B بر اساس داده‌های گذشته (برای ابر آینده بدون نیاز به کندل آینده)
   // iHighest/iLowest ایندکس‌ها را پیدا می‌کنند
   ENUM_TREND_DIRECTION GetTrendDirection(ENUM_TIMEFRAMES timeframe)  // گرفتن جهت با تایم‌فریم
   {
      if(!Inp_IchimokuFilter_Enabled)  // چک فیلتر خاموش
      {
         return TREND_NEUTRAL;  // اگر فیلتر خاموش باشد، همیشه خنثی فرض می‌شود
      }

      switch(Inp_IchimokuMode)  // انتخاب روش
      {
         case MODE_KUMO_CLOUD: return GetKumoTrend(timeframe, 1);  // ابر کومو (shift 1)
         case MODE_CHIKOU_SPAN: return GetChikouTrend(timeframe, 1);  // چیکو اسپن (shift 1)
         default: return TREND_NEUTRAL;  // پیش‌فرض
      }
   }

   // (جدید) گرفتن جهت روند برای زمان خاص: برای تحلیل در BreakoutAnalyzer
   ENUM_TREND_DIRECTION GetTrendDirectionForTime(ENUM_TIMEFRAMES timeframe, datetime targetTime)  // جهت برای زمان خاص
   {
      int shift = iBarShift(_Symbol, timeframe, targetTime);  // شیفت بر اساس زمان
      if(shift < 0)  // چک معتبر
      {
         CLogger::Log("خطا در iBarShift برای زمان " + TimeToString(targetTime));  // چاپ خطا
         return TREND_NEUTRAL;  // خنثی پیش‌فرض
      }
      switch(Inp_IchimokuMode)  // انتخاب روش
      {
         case MODE_KUMO_CLOUD: return GetKumoTrend(timeframe, shift);  // ابر کومو
         case MODE_CHIKOU_SPAN: return GetChikouTrend(timeframe, shift);  // چیکو اسپن
         default: return TREND_NEUTRAL;  // پیش‌فرض
      }
   }

   // (جدید) گرفتن Senkou Span B: محاسبه دستی و بازگشت مقدار برای استفاده در تریلینگ
   // مشابه محاسبه در GetTrendDirection
   double GetSenkouSpanB(ENUM_TIMEFRAMES timeframe)  // گرفتن Senkou B با تایم‌فریم
   {
      // محاسبه سنکو اسپن B (برای ابر آینده)
      int senkouBHighIdx = iHighest(_Symbol, timeframe, MODE_HIGH, Inp_Ichimoku_SenkouB, 1);  // ایندکس سقف سنکو B
      int senkouBLowIdx = iLowest(_Symbol, timeframe, MODE_LOW, Inp_Ichimoku_SenkouB, 1);  // ایندکس کف سنکو B
      double senkouBHigh = iHigh(_Symbol, timeframe, senkouBHighIdx);  // های سنکو B
      double senkouBLow = iLow(_Symbol, timeframe, senkouBLowIdx);  // لو سنکو B
      double senkouB = (senkouBHigh + senkouBLow) / 2.0;  // محاسبه Senkou B

      if(senkouB == 0)  // چک مقدار معتبر (برای ایمنی)
      {
         if(InpDebugMode) CLogger::Log("خطا در محاسبه Senkou Span B.");  // چاپ خطا
      }
      return senkouB;  // بازگشت مقدار
   }
};

#endif  // پایان







//+------------------------------------------------------------------+
//|                                                   VisualManager.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CVisualManager را تعریف می‌کند که نمایش بصری روی چارت را مدیریت می‌کند.
// استراتژی کلی اکسپرت: نمایش وضعیت روند (Bullish/Bearish/Neutral) برای هر رنج فعال به طور جداگانه 
// برای کمک به کاربر در نظارت، بدون تأثیر بر منطق معاملاتی.
// منطق فایل VisualManager.mqh: کلاس شیء LABEL را برای نمایش متن کامل وضعیت هر رنج ایجاد می‌کند، 
// موقعیت، فونت را تنظیم می‌کند. 
// تابع UpdateTrendStatus متن چندخطی را به‌روزرسانی و چارت را redraw می‌کند. 
// Init شیء را می‌سازد و Deinit حذف می‌کند. 
// این فایل توسط Elemento.mq5 برای نمایش در OnTick فراخوانی می‌شود و اختیاری است 
// (اگر نمایش خاموش باشد، نادیده گرفته می‌شود). 
// تغییرات جدید: پشتیبانی از متن چندخطی برای نمایش هر رنج جداگانه.
// تغییرات نسخه 2.30: جایگزینی Print با CLogger::Log، کامنت‌گذاری دقیق. هیچ تغییری اعمال نشده زیرا بلوپرینت تغییری مشخص نکرده.

#ifndef VISUAL_MANAGER_MQH  // چک
#define VISUAL_MANAGER_MQH  // تعریف

// کلاس CVisualManager برای مدیریت نمایش متن روند هر رنج روی چارت
// OBJ_LABEL برای متن استفاده می‌شود
class CVisualManager  // کلاس نمایش
{
private:
   string m_trendStatusObjectName;  // نام منحصربه‌فرد شیء LABEL برای نمایش - ثابت "TrendStatus"

public:
   CVisualManager() : m_trendStatusObjectName("TrendStatus") {}  // سازنده - تنظیم نام شیء

   // مقداردهی: ایجاد شیء LABEL با تنظیمات فونت، رنگ و موقعیت اگر نمایش فعال باشد
   // ObjectCreate شیء را می‌سازد
   bool Init()  // مقداردهی مدیر نمایش
   {
      if(InpDebugMode) CLogger::Log("مقداردهی مدیر نمایش...");  // چاپ دیباگ برای شروع
      if(Inp_Visual_ShowTrendStatus)  // چک فعال بودن نمایش
      {
         if(!ObjectCreate(0, m_trendStatusObjectName, OBJ_LABEL, 0, 0, 0))  // ایجاد LABEL
         {
            CLogger::Log("خطا در ایجاد شیء نمایش روند: " + IntegerToString(GetLastError()));  // چاپ خطا
            return false;  // بازگشت شکست
         }

         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_XDISTANCE, Inp_Visual_X_Offset);  // تنظیم فاصله افقی
         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_YDISTANCE, Inp_Visual_Y_Offset);  // تنظیم فاصله عمودی
         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_CORNER, CORNER_LEFT_UPPER);  // تنظیم گوشه چپ بالا
         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_FONTSIZE, Inp_Visual_FontSize);  // تنظیم اندازه فونت
         ObjectSetString(0, m_trendStatusObjectName, OBJPROP_FONT, "Arial");  // تنظیم فونت
         ObjectSetString(0, m_trendStatusObjectName, OBJPROP_TEXT, "Initializing...");  // متن اولیه
         ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_COLOR, Inp_Visual_FontColor_Neutral);  // رنگ خنثی
      }
      if(InpDebugMode) CLogger::Log("مدیر نمایش با موفقیت مقداردهی شد.");  // چاپ موفقیت
      return true;  // بازگشت موفقیت
   }

   // دفع: حذف شیء LABEL برای پاکسازی چارت
   // ObjectDelete شیء را حذف می‌کند
   void Deinit()  // دفع مدیر نمایش
   {
      ObjectDelete(0, m_trendStatusObjectName);  // حذف شیء
      if(InpDebugMode) CLogger::Log("شیء نمایش روند حذف شد.");  // چاپ دیباگ
   }

   // به‌روزرسانی نمایش: تغییر متن کامل وضعیت روند هر رنج و redraw چارت
   // ChartRedraw چارت را به‌روزرسانی می‌کند
   void UpdateTrendStatus(string fullText)  // به‌روزرسانی متن نمایش
   {
      if(!Inp_Visual_ShowTrendStatus) return;  // خروج اگر نمایش خاموش

      ObjectSetString(0, m_trendStatusObjectName, OBJPROP_TEXT, fullText);  // تنظیم متن جدید
      ObjectSetInteger(0, m_trendStatusObjectName, OBJPROP_COLOR, Inp_Visual_FontColor_Neutral);  // رنگ خنثی برای متن چندخطی
      ChartRedraw();  // redraw چارت
   }
};

#endif  // پایان






//+------------------------------------------------------------------+
//|                                                        Logger.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// یک کتابخانه ساده و استاتیک برای مدیریت لاگ‌نویسی هوشمند
// این فایل برای جلوگیری از لاگ تکراری و نویز طراحی شده است.
// تغییرات نسخه 2.30: فایل جدید با CLogger استاتیک، m_lastMessage برای جلوگیری از تکرار، 
// فرمت استاندارد با پیشوند [Elemento] [Range X] >> پیام. هیچ تغییری اعمال نشده زیرا بلوپرینت تغییری مشخص نکرده.

#ifndef LOGGER_MQH  // چک وجود
#define LOGGER_MQH  // تعریف ماکرو

// کلاس CLogger استاتیک برای لاگ بدون نمونه‌سازی
class CLogger  // کلاس لاگ
{
private:
   static string m_lastMessage;  // برای ذخیره آخرین پیام و جلوگیری از تکرار (استاتیک برای اشتراک)

public:
   // تابع اصلی لاگ‌نویسی
   // این تابع پیام را با چک تکرار چاپ می‌کند
   static void Log(string message, int rangeIndex = 0)  // تابع لاگ با پیام و ایندکس اختیاری
   {
      // فقط اگر حالت دیباگ فعال باشد لاگ می‌نویسد
      if(!InpDebugMode)  // شرط دیباگ
         return;  // خروج بدون چاپ
         
      // اگر پیام جدید با پیام قبلی یکی باشد، آن را نادیده می‌گیرد
      if(message == m_lastMessage)  // چک تکرار
         return;  // خروج

      string prefix = "[Elemento]";  // پیشوند کلی
      
      if(rangeIndex > 0)  // اگر مربوط به یک رنج خاص باشد
      {
         prefix += " [Range " + IntegerToString(rangeIndex) + "]";  // اضافه ایندکس
      }
      
      Print(prefix + " " + message);  // چاپ پیام نهایی با Print (MT5 استاندارد)
      
      m_lastMessage = message;  // ذخیره پیام فعلی برای مقایسه بعدی
   }
};

// مقداردهی اولیه متغیر استاتیک (خارج از کلاس)
string CLogger::m_lastMessage = "";  // مقداردهی اولیه متغیر استاتیک

#endif  // پایان











//+------------------------------------------------------------------+
//|                                                BreakoutAnalyzer.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس BreakoutAnalyzer را تعریف می‌کند که تحلیل قدرت شکست را مدیریت می‌کند.
// استراتژی کلی: برای تشخیص شکست انفجاری (برای ورود مارکت) یا معمولی (برای پولبک) استفاده می‌شود.
// منطق فایل BreakoutAnalyzer.mqh: کلاس استاتیک با تابع IsBreakoutExplosive که قدرت کندل شکست را تحلیل می‌کند، 
// چک می‌کند اگر انفجاری باشد true برمی‌گرداند. 
// وابستگی به CRange برای دسترسی به اطلاعات کندل. 
// تغییرات جدید در نسخه 2.30: فایل جدید بر اساس بلوپرینت، با منطق کامل برای MODE_CANDLE_ONLY, MODE_CANDLE_CONFIRM, MODE_CANDLE_CONFIRM_ICHI.

#ifndef BREAKOUT_ANALYZER_MQH  // چک وجود
#define BREAKOUT_ANALYZER_MQH  // تعریف

class CRange;  // forward declaration to avoid circular include

// کلاس BreakoutAnalyzer برای تحلیل قدرت شکست (استاتیک)
class BreakoutAnalyzer  // کلاس تحلیل
{
public:
   // تحلیل قدرت شکست: اگر انفجاری باشد true، иначе false
   static bool IsBreakoutExplosive(const CRange& range)  // تحلیل با اشاره‌گر به رنج
   {
      if(!Inp_AdaptiveEntry_Enabled) return false;  // اگر خاموش، همیشه پولبک

      // قدم اول: فیلتر اولیه قدرت کندل (چک ضعیف نبودن)
      int breakerShift = iBarShift(_Symbol, range.GetTimeframe(), range.GetBreakerCandleTime());  // شیفت بریک
      double breakerOpen = iOpen(_Symbol, range.GetTimeframe(), breakerShift);  // اوپن بریک
      double breakerClose = iClose(_Symbol, range.GetTimeframe(), breakerShift);  // کلوز بریک
      double breakerHigh = iHigh(_Symbol, range.GetTimeframe(), breakerShift);  // های بریک
      double breakerLow = iLow(_Symbol, range.GetTimeframe(), breakerShift);  // لو بریک
      double bodySize = MathAbs(breakerClose - breakerOpen);  // اندازه بدنه
      double candleSize = breakerHigh - breakerLow;  // اندازه کل کندل
      double bodyRatio = bodySize / candleSize;  // نسبت بدنه
      if(bodyRatio < Inp_MinCandleBodyRatio) return false;  // ضعیف: رد سیگنال

      // قدم دوم: تحلیل بر اساس حالت
      switch(Inp_AdaptiveMode)
      {
         case MODE_CANDLE_ONLY:
            return bodyRatio >= Inp_ExplosiveCandleBodyRatio;  // چک انفجاری

         case MODE_CANDLE_CONFIRM:
            return range.GetConfirmationCandleTime() == iTime(_Symbol, range.GetTimeframe(), breakerShift - 1);  // چک تایید فوری

         case MODE_CANDLE_CONFIRM_ICHI:
            {
               if(range.GetConfirmationCandleTime() != iTime(_Symbol, range.GetTimeframe(), breakerShift - 1)) return false;  // چک تایید فوری
               ENUM_TREND_DIRECTION trendAtConfirm = g_trendFilter.GetTrendDirectionForTime(range.GetTrendFilterTimeframe(), range.GetConfirmationCandleTime());  // جهت در تایید
               return trendAtConfirm != TREND_NEUTRAL && (range.GetIsBuyAttempt() ? trendAtConfirm == TREND_BUY : trendAtConfirm == TREND_SELL);  // هم‌جهت
            }

         default: return false;  // پیش‌فرض
      }
   }
};

#endif  // پایان
