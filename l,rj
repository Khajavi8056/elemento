//+------------------------------------------------------------------+
//|                                              SMC_Pullback_EA.mq5 |
//|                       Copyright 2025, Your Name or Team          |
//|                       https://yourwebsite.com                    |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Your Name"
#property link      "https://yourwebsite.com"
#property version   "1.00"
#property strict
#property description "SMC Pullback on FVG with BOS Confirmation EA for MT5"

#include <Trade\Trade.mqh>  // برای کلاس CTrade

// ورودی‌ها برای تنظیمات
input double InpRiskPercent = 1.0;       // درصد ریسک هر معامله (1%)
input ENUM_TIMEFRAMES InpTimeframe = PERIOD_H4;  // تایم‌فریم (پیش‌فرض H4)
input double InpFVG_Threshold_Pips = 5.0;  // حداقل اندازه FVG به پیپ (برای تشخیص گپ)
input double InpRR_Ratio = 2.0;          // نسبت R:R برای TP (2:1)
input int InpMagicNumber = 123456;       // مجیک نامبر برای تمایز معاملات

// متغیرهای جهانی
datetime g_lastBarTime = 0;              // زمان آخرین کندل برای تشخیص کندل جدید
double g_lastHigh = 0.0;                 // آخرین High برای تشخیص BOS
double g_lastLow = 0.0;                  // آخرین Low برای تشخیص BOS
double g_fvgHigh = 0.0;                  // سقف FVG تشخیص داده‌شده
double g_fvgLow = 0.0;                   // کف FVG تشخیص داده‌شده
bool g_isBuyBOS = false;                 // فلگ BOS خرید
bool g_isSellBOS = false;                // فلگ BOS فروش
bool g_inTrade = false;                  // فلگ برای جلوگیری از معاملات متعدد

// کلاس معامله
CTrade g_trade;                          // نمونه CTrade برای باز کردن معاملات

// تابع شروع اکسپرت
int OnInit()
{
   // چک نماد و تایم‌فریم
   if(_Symbol != "EURUSD")
   {
      Print("این اکسپرت فقط برای EURUSD طراحی شده است.");
      return(INIT_PARAMETERS_INCORRECT);
   }
   
   // تنظیم اولیه سطوح
   g_lastHigh = iHigh(_Symbol, InpTimeframe, 1);
   g_lastLow = iLow(_Symbol, InpTimeframe, 1);
   
   Print("اکسپرت SMC Pullback شروع شد.");
   return(INIT_SUCCEEDED);
}

// تابع پایان اکسپرت
void OnDeinit(const int reason)
{
   Print("اکسپرت SMC Pullback پایان یافت. دلیل: ", reason);
}

// تابع اصلی هر تیک
void OnTick()
{
   // چک کندل جدید
   datetime currentTime = iTime(_Symbol, InpTimeframe, 0);
   if(currentTime == g_lastBarTime) return;
   g_lastBarTime = currentTime;
   
   // اگر در معامله هستیم، مدیریت معامله (چک دستی SL/TP لازم نیست، MT5 هندل می‌کند)
   if(g_inTrade)
   {
      // می‌توانید تریلینگ اضافه کنید اگر بخواهید، اما ساده نگه داشتیم
      return;
   }
   
   // گرفتن داده‌های کندل
   double high = iHigh(_Symbol, InpTimeframe, 1);
   double low = iLow(_Symbol, InpTimeframe, 1);
   double close = iClose(_Symbol, InpTimeframe, 1);
   double open = iOpen(_Symbol, InpTimeframe, 1);
   double currentPrice = (SymbolInfoDouble(_Symbol, SYMBOL_BID) + SymbolInfoDouble(_Symbol, SYMBOL_ASK)) / 2.0;
   
   // تشخیص BOS (Break of Structure)
   if(high > g_lastHigh)
   {
      g_isBuyBOS = true;
      g_isSellBOS = false;
      Print("BOS خرید تشخیص داده شد.");
   }
   else if(low < g_lastLow)
   {
      g_isSellBOS = true;
      g_isBuyBOS = false;
      Print("BOS فروش تشخیص داده شد.");
   }
   
   // به‌روزرسانی سطوح قبلی
   g_lastHigh = MathMax(g_lastHigh, high);
   g_lastLow = MathMin(g_lastLow, low);
   
   // تشخیص FVG (Fair Value Gap)
   double fvgThreshold = InpFVG_Threshold_Pips * _Point;
   if(g_isBuyBOS && close > open && (close - open) > fvgThreshold)
   {
      // FVG صعودی: گپ بین low و high قبلی
      g_fvgLow = low;
      g_fvgHigh = high;
      Print("FVG صعودی تشخیص داده شد: از ", g_fvgLow, " تا ", g_fvgHigh);
   }
   else if(g_isSellBOS && close < open && (open - close) > fvgThreshold)
   {
      // FVG نزولی
      g_fvgHigh = high;
      g_fvgLow = low;
      Print("FVG نزولی تشخیص داده شد: از ", g_fvgLow, " تا ", g_fvgHigh);
   }
   
   // چک pullback به FVG و ورود با کندل تأییدی (مثلاً engulfing ساده)
   if(g_fvgHigh > 0 && g_fvgLow > 0)
   {
      if(g_isBuyBOS && currentPrice <= g_fvgHigh && currentPrice >= g_fvgLow && close > open)  // pullback به FVG و کندل صعودی
      {
         // محاسبه SL و TP
         double sl = g_fvgLow - _Point * 10;  // زیر FVG با بافر
         double entry = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         double slDistance = entry - sl;
         double tp = entry + slDistance * InpRR_Ratio;
         
         // محاسبه حجم
         double lotSize = CalculateLotSize(slDistance);
         if(lotSize <= 0) return;
         
         // باز کردن معامله خرید
         if(g_trade.PositionOpen(_Symbol, ORDER_TYPE_BUY, lotSize, 0, entry, sl, tp, 0, 0, "SMC Buy", InpMagicNumber))
         {
            g_inTrade = true;
            Print("معامله خرید باز شد.");
         }
      }
      else if(g_isSellBOS && currentPrice >= g_fvgLow && currentPrice <= g_fvgHigh && close < open)  // pullback و کندل نزولی
      {
         double sl = g_fvgHigh + _Point * 10;  // بالای FVG با بافر
         double entry = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         double slDistance = sl - entry;
         double tp = entry - slDistance * InpRR_Ratio;
         
         double lotSize = CalculateLotSize(slDistance);
         if(lotSize <= 0) return;
         
         if(g_trade.PositionOpen(_Symbol, ORDER_TYPE_SELL, lotSize, 0, entry, sl, tp, 0, 0, "SMC Sell", InpMagicNumber))
         {
            g_inTrade = true;
            Print("معامله فروش باز شد.");
         }
      }
   }
}

// تابع محاسبه حجم بر اساس ریسک
double CalculateLotSize(double slDistance)
{
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   if(tickValue <= 0 || tickSize <= 0) return 0;
   
   double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskAmount = InpRiskPercent / 100.0 * accountBalance;
   double riskPerLot = slDistance * (tickValue / tickSize);
   if(riskPerLot <= 0) return 0;
   
   double lotSize = riskAmount / riskPerLot;
   double volumeStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double volumeMin = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double volumeMax = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   
   lotSize = MathRound(lotSize / volumeStep) * volumeStep;
   lotSize = MathMax(volumeMin, MathMin(volumeMax, lotSize));
   
   if(lotSize < volumeMin)
   {
      Print("حجم محاسبه‌شده کمتر از حداقل است.");
      return 0;
   }
   
   return lotSize;
}

// تابع چک بسته شدن معامله (برای ریست فلگ)
void OnTradeTransaction(const MqlTradeTransaction &trans, const MqlTradeRequest &req, const MqlTradeResult &res)
{
   if(trans.type == TRADE_TRANSACTION_DEAL_ADD && trans.magic == InpMagicNumber)
   {
      // معامله باز شد
   }
   else if(trans.type == TRADE_TRANSACTION_HISTORY_ADD && trans.magic == InpMagicNumber)
   {
      // معامله بسته شد
      g_inTrade = false;
      // ریست سطوح
      g_fvgHigh = 0.0;
      g_fvgLow = 0.0;
      g_isBuyBOS = false;
      g_isSellBOS = false;
   }
}
