//+------------------------------------------------------------------+
//|                                              SMC_Pullback_EA.mq5 |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Hipoalgorithm Team"
#property link      "https://hipoalgorithm.com"
#property version   "1.00"
#property strict
#property description "SMC Pullback on FVG with BOS Confirmation EA for MT5"

#include <Trade\Trade.mqh>  // برای کلاس CTrade

// ورودی‌ها برای تنظیمات
input double InpRiskPercent = 1.0;       // درصد ریسک هر معامله (1%)
input ENUM_TIMEFRAMES InpTimeframe = PERIOD_H4;  // تایم‌فریم (پیش‌فرض H4)
input double InpFVG_Threshold_Pips = 5.0;  // حداقل اندازه FVG به پیپ (برای تشخیص گپ)
input double InpRR_Ratio = 2.0;          // نسبت R:R برای TP (2:1)
input int InpMagicNumber = 123456;       // مجیک نامبر برای تمایز معاملات
input int InpSlippage = 3;               // حداکثر اسلیپیج (پیپ)

// متغیرهای جهانی
datetime g_lastBarTime = 0;              // زمان آخرین کندل برای تشخیص کندل جدید
double g_lastHigh = 0.0;                 // آخرین High برای تشخیص BOS
double g_lastLow = 0.0;                  // آخرین Low برای تشخیص BOS
double g_fvgHigh = 0.0;                  // سقف FVG تشخیص داده‌شده
double g_fvgLow = 0.0;                   // کف FVG تشخیص داده‌شده
bool g_isBuyBOS = false;                 // فلگ BOS خرید
bool g_isSellBOS = false;                // فلگ BOS فروش
bool g_inTrade = false;                  // فلگ برای جلوگیری از معاملات متعدد

// کلاس معامله
CTrade g_trade;                          // نمونه CTrade برای باز کردن معاملات

// تابع شروع اکسپرت
int OnInit()
{
   // چک نماد و تایم‌فریم
   if(_Symbol != "EURUSD")
   {
      Print("این اکسپرت فقط برای EURUSD طراحی شده است.");
      return(INIT_PARAMETERS_INCORRECT);
   }
   
   // تنظیم مجیک نامبر و اسلیپیج
   g_trade.SetExpertMagicNumber(InpMagicNumber);
   g_trade.SetDeviation(InpSlippage);
   
   // تنظیم اولیه سطوح
   g_lastHigh = iHigh(_Symbol, InpTimeframe, 1);
   g_lastLow = iLow(_Symbol, InpTimeframe, 1);
   
   Print("اکسپرت SMC Pullback شروع شد.");
   return(INIT_SUCCEEDED);
}

// تابع پایان اکسپرت
void OnDeinit(const int reason)
{
   Print("اکسپرت SMC Pullback پایان یافت. دلیل: ", reason);
}

// تابع اصلی هر تیک
void OnTick()
{
   // چک کندل جدید
   datetime currentTime = iTime(_Symbol, InpTimeframe, 0);
   if(currentTime == g_lastBarTime) return;
   g_lastBarTime = currentTime;
   
   // چک اگر معامله باز هست یا نه (برای ریست فلگ)
   int totalPositions = PositionsTotal();
   bool hasOpenPosition = false;
   for(int i = 0; i < totalPositions; i++)
   {
      if(PositionGetSymbol(i) == _Symbol && PositionGetInteger(POSITION_MAGIC) == InpMagicNumber)
      {
         hasOpenPosition = true;
         break;
      }
   }
   if(!hasOpenPosition)
   {
      g_inTrade = false;
      // ریست سطوح اگر لازم
      if(g_fvgHigh != 0.0 || g_fvgLow != 0.0)
      {
         g_fvgHigh = 0.0;
         g_fvgLow = 0.0;
         g_isBuyBOS = false;
         g_isSellBOS = false;
         Print("سطوح ریست شد.");
      }
   }
   
   // اگر در معامله هستیم، خارج شو (مدیریت معامله توسط MT5 انجام می‌شود)
   if(g_inTrade) return;
   
   // گرفتن داده‌های کندل
   double high = iHigh(_Symbol, InpTimeframe, 1);
   double low = iLow(_Symbol, InpTimeframe, 1);
   double close = iClose(_Symbol, InpTimeframe, 1);
   double open = iOpen(_Symbol, InpTimeframe, 1);
   double currentBid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double currentAsk = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   
   // تشخیص BOS (Break of Structure)
   if(high > g_lastHigh)
   {
      g_isBuyBOS = true;
      g_isSellBOS = false;
      Print("BOS خرید تشخیص داده شد.");
   }
   else if(low < g_lastLow)
   {
      g_isSellBOS = true;
      g_isBuyBOS = false;
      Print("BOS فروش تشخیص داده شد.");
   }
   
   // به‌روزرسانی سطوح قبلی
   g_lastHigh = MathMax(g_lastHigh, high);
   g_lastLow = MathMin(g_lastLow, low);
   
   // تشخیص FVG (Fair Value Gap)
   double fvgThreshold = InpFVG_Threshold_Pips * _Point;
   if(g_isBuyBOS && close > open && (close - open) > fvgThreshold)
   {
      // FVG صعودی: گپ بین low و high قبلی
      g_fvgLow = low;
      g_fvgHigh = high;
      Print("FVG صعودی تشخیص داده شد: از ", DoubleToString(g_fvgLow, _Digits), " تا ", DoubleToString(g_fvgHigh, _Digits));
   }
   else if(g_isSellBOS && close < open && (open - close) > fvgThreshold)
   {
      // FVG نزولی
      g_fvgHigh = high;
      g_fvgLow = low;
      Print("FVG نزولی تشخیص داده شد: از ", DoubleToString(g_fvgLow, _Digits), " تا ", DoubleToString(g_fvgHigh, _Digits));
   }
   
   // چک pullback به FVG و ورود با کندل تأییدی (مثلاً engulfing ساده)
   if(g_fvgHigh > 0 && g_fvgLow > 0)
   {
      if(g_isBuyBOS && currentAsk <= g_fvgHigh && currentAsk >= g_fvgLow && close > open)  // pullback به FVG و کندل صعودی
      {
         // محاسبه SL و TP
         double sl = g_fvgLow - _Point * 10;  // زیر FVG با بافر
         double entry = currentAsk;
         double slDistance = entry - sl;
         double tp = entry + slDistance * InpRR_Ratio;
         
         // محاسبه حجم
         double lotSize = CalculateLotSize(slDistance);
         if(lotSize <= 0) return;
         
         // باز کردن معامله خرید
         if(g_trade.PositionOpen(_Symbol, ORDER_TYPE_BUY, lotSize, entry, sl, tp, "SMC Buy"))
         {
            g_inTrade = true;
            Print("معامله خرید باز شد.");
         }
      }
      else if(g_isSellBOS && currentBid >= g_fvgLow && currentBid <= g_fvgHigh && close < open)  // pullback و کندل نزولی
      {
         double sl = g_fvgHigh + _Point * 10;  // بالای FVG با بافر
         double entry = currentBid;
         double slDistance = sl - entry;
         double tp = entry - slDistance * InpRR_Ratio;
         
         double lotSize = CalculateLotSize(slDistance);
         if(lotSize <= 0) return;
         
         if(g_trade.PositionOpen(_Symbol, ORDER_TYPE_SELL, lotSize, entry, sl, tp, "SMC Sell"))
         {
            g_inTrade = true;
            Print("معامله فروش باز شد.");
         }
      }
   }
}

// تابع محاسبه حجم بر اساس ریسک
double CalculateLotSize(double slDistance)
{
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   if(tickValue <= 0 || tickSize <= 0)
   {
      Print("خطا: tickValue یا tickSize نامعتبر است.");
      return 0;
   }
   
   double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskAmount = InpRiskPercent / 100.0 * accountBalance;
   double riskPerLot = slDistance * (tickValue / tickSize);
   if(riskPerLot <= 0)
   {
      Print("خطا: riskPerLot نامعتبر است.");
      return 0;
   }
   
   double lotSize = riskAmount / riskPerLot;
   double volumeStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double volumeMin = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double volumeMax = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   
   lotSize = MathRound(lotSize / volumeStep) * volumeStep;
   lotSize = MathMax(volumeMin, MathMin(volumeMax, lotSize));
   
   if(lotSize < volumeMin)
   {
      Print("حجم محاسبه‌شده کمتر از حداقل است.");
      return 0;
   }
   
   return lotSize;
}
