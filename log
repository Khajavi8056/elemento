//+------------------------------------------------------------------+
//|                                                         CRange.mqh |
//|                       Copyright 2025, Hipoalgorithm Team         |
//|                       https://hipoalgorithm.com                  |
//+------------------------------------------------------------------+
// این فایل کلاس CRange را تعریف می‌کند که هسته استراتژی شکست رنج را مدیریت می‌کند.
// استراتژی کلی اکسپرت: هر رنج زمانی (مانند سشن آسیا) را شناسایی می‌کند، سقف و کف آن را تعیین می‌کند، 
// اگر ارتفاع معتبر باشد، با افست (بر اساس ATR یا درصد) مسلح می‌شود، منتظر کندل بریک (شکست) می‌ماند، 
// به صورت اختیاری قیمت را تأیید می‌کند (اگر Inp_PriceConfirmation_Enabled فعال باشد)، 
// فیلتر روند را به طور مستقل و در لحظه چک می‌کند، معامله باز می‌کند 
// و سپس معامله را با خروج پله‌ای (هنگام رسیدن به RR)، انتقال SL به ورود، و تریلینگ مدیریت می‌کند. 
// این استراتژی برای بازارهای رنجی با شکست قوی مناسب است و با فیلتر ایچیموکو ریسک خلاف روند را کاهش می‌دهد.
// منطق فایل CRange.mqh: این کلاس برای هر رنج جداگانه عمل می‌کند. 
// ماشین حالت (ENUM_RANGE_STATE) جریان را کنترل می‌کند: از انتظار رنج جدید شروع می‌شود، 
// رنج را شناسایی و ولید می‌کند، مسلح می‌کند، منتظر بریک و تأییدها می‌ماند، معامله اجرا می‌کند و مدیریت می‌کند. 
// پاکسازی نرم برای ریست روزانه و سخت برای بستن معاملات در تعطیلات استفاده می‌شود. 
// کش ATR برای بهینه‌سازی محاسبات، و فراخوانی مستقل g_trendFilter برای فیلتر دینامیک. 
// تغییرات جدید در نسخه 2.10: حذف CleanupPaths و ادغام در SoftCleanup جدید برای حل باگ قفل شدن، 
// اصلاح CheckCleanup برای فراخوانی SoftCleanup، اصلاح ManageActiveTrade برای ریست فوری با SoftCleanup، 
// اضافه m_initialSlDistance و ذخیره در کامنت معامله، اضافه RestoreState برای بازیابی، 
// استفاده از m_initialSlDistance در ManageActiveTrade، اصلاح m_slToBeMoved در ManageActiveTrade برای جلوگیری از Race Condition، 
// کامنت‌گذاری دقیق هر خط، و حفظ ساختار قبلی.
// تغییرات اضافی برای نسخه 2.10 (اصلاحات ورود): اضافه متغیرهای m_buyAttemptDisabled، m_sellAttemptDisabled و m_isBuyAttempt برای مدیریت حافظه ابطال جهت‌ها،
// اصلاح WaitForBreakerCandle برای چک disabled و ذخیره جهت، بازنویسی ProcessEntryAttempt برای منطق جدید تایید/ابطال با switch،
// و تغییر فیلتر ایچیموکو به فقط هم‌جهت (بدون NEUTRAL، NEUTRAL صبر می‌کند).

#ifndef CRANGE_MQH  // چک وجود فایل
#define CRANGE_MQH  // تعریف ماکرو

#include "TimeHelper.mqh"  // کلاس کمک‌کننده زمان برای محاسبات رنج و پاکسازی
#include "RiskManager.mqh"  // کلاس مدیریت ریسک برای محاسبه حجم
#include "Utils.mqh"  // کلاس کمکی برای نرمال‌سازی قیمت‌ها
#include "Logger.mqh"  // کتابخانه لاگ هوشمند برای چاپ پیام‌های کنترل‌شده

// تعریف enum برای حالت‌های رنج (ماشین حالت برای کنترل جریان هر رنج جداگانه)
// این enum جریان استراتژی را از انتظار تا مدیریت معامله کنترل می‌کند
enum ENUM_RANGE_STATE
{
   RANGE_IDLE,                  // انتظار برای رنج جدید (حالت اولیه یا پس از پاکسازی، آماده شناسایی)
   RANGE_IDENTIFYING,           // در حال شناسایی رنج (محاسبه سقف/کف و چک ارتفاع)
   RANGE_ARMED,                 // رنج مسلح شده و منتظر شکست (خطوط افست رسم شده)
   AWAITING_CONFIRMATION,       // انتظار تایید ورود (پس از کندل بریک، چک ابطال و تاییدها)
   RANGE_TRADE_ACTIVE,          // معامله این رنج فعال است (معامله باز شده، منتظر پاکسازی)
   RANGE_EXPIRED                // رنج منقضی شده (پس از پاکسازی یا نامعتبر، آماده رنج جدید)
};

// کلاس CRange برای مدیریت هر رنج زمانی به طور مستقل
// این کلاس تمام منطق یک رنج را از شناسایی تا باز کردن معامله کپسوله می‌کند (مدیریت معامله به CActiveTradeManager منتقل شده)
class CRange  // کلاس اصلی مدیریت رنج
{
private:
   int m_rangeIndex;  // ایندکس رنج (1 تا 4 برای تمایز، برای لاگ و اشیاء)
   long m_magicNumber;  // مجیک نامبر منحصربه‌فرد برای معاملات این رنج (برای تمایز در PositionsTotal)
   ENUM_TIMEFRAMES m_timeframe;  // تایم‌فریم اجرا برای محاسبات رنج (برای iHigh/iLow/iClose)
   int m_startHour;  // ساعت شروع رنج (0-23، بر اساس GMT سرور)
   int m_startMinute;  // دقیقه شروع رنج (0-59)
   int m_endHour;  // ساعت پایان رنج (0-23)
   int m_endMinute;  // دقیقه پایان رنج (0-59)
   int m_minRangePoints;  // حداقل ارتفاع مجاز رنج به پوینت (برای فیلتر رنج‌های کوچک)
   int m_maxRangePoints;  // حداکثر ارتفاع مجاز رنج به پوینت (برای فیلتر رنج‌های بزرگ)
   ENUM_PLACEMENT_MODE m_placementMode;  // حالت افست شکست (ATR یا درصد، برای محاسبه سطوح)
   int m_atrPeriod;  // دوره ATR برای افست (برای iATR)
   double m_atrMultiplier;  // ضریب ATR برای افست (برای حساسیت)
   ENUM_SL_STRATEGY m_slStrategy;  // استراتژی جایگذاری SL (مقابل یا سطح شکست، برای base point)
   ENUM_SL_CALC_MODE m_slCalcMode;  // حالت محاسبه بافر SL (ATR یا درصد)
   int m_slAtrPeriod;  // دوره ATR برای بافر SL
   double m_slAtrMultiplier;  // ضریب ATR برای بافر SL
   ENUM_TRAILING_MODE m_trailingMode;  // حالت تریلینگ (ATR یا Senkou B)
   int m_trailingAtrPeriod;  // دوره ATR برای تریلینگ
   double m_trailingAtrMultiplier;  // ضریب ATR برای تریلینگ
   double m_rrRatio;  // نسبت R:R برای خروج پله‌ای (سود/ریسک)
   double m_partialClosePercent;  // درصد خروج پله‌ای (0-100)
   int m_cleanupHours;  // ساعت‌های پاکسازی پس از پایان رنج (0-24)
   color m_color;  // رنگ مستطیل رنج (برای OBJ_RECTANGLE)
   ENUM_TIMEFRAMES m_trendFilterTimeframe;  // تایم‌فریم فیلتر روند (برای GetTrendDirection)
   int m_atrHandle;  // هندل ATR برای افست (shared از Elemento)
   int m_slAtrHandle;  // هندل ATR برای SL (جداگانه برای دوره متفاوت)
   int m_trailingAtrHandle;  // هندل ATR برای تریلینگ (جداگانه)
   ENUM_RANGE_STATE m_currentState;  // حالت فعلی رنج (ماشین حالت)
   double m_rangeHigh;  // سقف رنج شناسایی‌شده (از iHighest)
   double m_rangeLow;  // کف رنج شناسایی‌شده (از iLowest)
   double m_potentialBuyPrice;  // سطح خرید با افست (برای چک بریک)
   double m_potentialSellPrice;  // سطح فروش با افست (برای چک بریک)
   double m_breakerCandleLevel;  // سطح کلوز کندل شکننده (برای تایید قیمت)
   ulong m_activeTicket;  // تیکت معامله فعال (از result.deal)
   double m_cachedATR;  // کش ATR برای ورود (ثابت، محاسبه در شناسایی)
   double m_cachedSlATR;  // کش ATR برای SL (ثابت)
   double m_cachedTrailingATR;  // کش ATR برای تریلینگ (پویا در مدیریت، اما کش اولیه)
   int m_waitCounter;  // شمارنده کندل برای حالت تایمر قدیمی (فقط اگر CONFIRMATION_TIMEOUT)
   datetime m_cleanupTime;  // زمان پاکسازی محاسبه‌شده (از CalculateCleanupTime)
   datetime m_lastEndTime;  // آخرین زمان پایان پردازش شده (برای جلوگیری از تکرار شناسایی)
   bool m_lastInvalid;  // فلگ آخرین رنج نامعتبر (برای جلوگیری از تکرار)
   datetime m_rangeEndTime;  // زمان کامل پایان رنج (برای محاسبه دقیق پاکسازی)
   datetime m_lastFilterBarTime;  // زمان آخرین کندل فیلتر روند (برای آپدیت نمایش)
   double m_fixedOffsetValue;  // مقدار ثابت افست ATR یا درصد در لحظه شناسایی رنج (برای ثابت کردن خطوط)
   string m_rangeObjectName;  // نام مستطیل رنج (برای OBJ_RECTANGLE)
   string m_buyLineName;  // نام خط خرید (برای OBJ_HLINE)
   string m_sellLineName;  // نام خط فروش (برای OBJ_HLINE)
   double m_initialSlDistance; // فاصله SL اولیه (برای ذخیره و بازیابی در کامنت معامله، برای حل باگ بازیابی ناقص)
   bool m_isCleanedForThisCycle;  // فلگ برای جلوگیری از پاکسازی مکرر در یک چرخه
   // (جدید) متغیرهای برای مدیریت حافظه ابطال جهت‌ها و ذخیره جهت سیگنال (برای اصلاح منطق ورود)
   bool m_buyAttemptDisabled;  // فلگ برای غیرفعال کردن دائمی تلاش خرید پس از timeout (حافظه ابطال)
   bool m_sellAttemptDisabled;  // فلگ برای غیرفعال کردن دائمی تلاش فروش پس از timeout (حافظه ابطال)
   bool m_isBuyAttempt;  // فلگ برای ذخیره جهت سیگنال فعلی (true برای خرید، false برای فروش، برای تشخیص قطعی در ProcessEntryAttempt)

   // شناسایی و ولید رنج: محاسبه سقف/کف، چک ارتفاع و رسم مستطیل اگر معتبر باشد
   // این تابع رنج را بر اساس زمان محاسبه و ولید می‌کند
   void IdentifyAndValidateRange();  // شناسایی و ولید رنج

   // انتظار برای کندل بریک: چک کلوز بالای/پایین افست برای شروع تایید ورود
   // این تابع شکست را تشخیص می‌دهد
   void WaitForBreakerCandle();  // انتظار برای کندل بریک

   // فرآیند تلاش ورود: چک ابطال، تایید قیمت و فیلتر روند، اجرای معامله اگر تایید شد
   // این تابع ابطال و تاییدها را مدیریت می‌کند
   void ProcessEntryAttempt();  // فرآیند تلاش ورود

   // ریست به حالت مسلح: ریست سطح بریک بدون حذف خطوط برای حفظ فرصت‌ها
   // این تابع برای ابطال بدون پاکسازی استفاده می‌شود
   void ResetToArmedState();  // ریست به حالت مسلح

   // اجرای معامله: محاسبه SL با استراتژی جدید، حجم و ارسال سفارش بازار
   // این تابع معامله را باز می‌کند
   void ExecuteTrade(bool isBuy);  // اجرای معامله

   // غیرفعال کردن مسیر مخالف: حذف خط و ریست قیمت برای OCO
   // این تابع مسیر مخالف را غیرفعال می‌کند
   void DisableOppositePath(bool isBuy);  // غیرفعال کردن مسیر مخالف

   // پاکسازی نرم: ریست متغیرها و حذف اشیاء بدون بستن معامله
   // این تابع برای ریست روزانه استفاده می‌شود
   void SoftCleanup();  // پاکسازی نرم

   // گرفتن ATR کش‌شده: محاسبه اگر خالی باشد (برای ورود ثابت)
   // این تابع کش ATR را مدیریت می‌کند
   double GetCachedATR();  // گرفتن ATR کش‌شده

   // گرفتن ATR برای SL: مشابه برای SL (ثابت)
   // این تابع کش SL را مدیریت می‌کند
   double GetSlATR();  // گرفتن ATR برای SL

   // گرفتن ATR برای تریلینگ: مشابه برای تریلینگ (پویا در مدیریت)
   // این تابع کش تریلینگ را مدیریت می‌کند
   double GetTrailingATR();  // گرفتن ATR برای تریلینگ

public:
   // سازنده پیش‌فرض با مقادیر اولیه برای جلوگیری از garbage values
   CRange() : m_rangeIndex(0), m_magicNumber(0), m_timeframe(PERIOD_CURRENT), m_startHour(0), m_startMinute(0), m_endHour(0), m_endMinute(0),
              m_minRangePoints(0), m_maxRangePoints(0), m_placementMode(PLACEMENT_ATR), m_atrPeriod(0), m_atrMultiplier(0.0),
              m_slStrategy(SL_OPPOSITE_SIDE), m_slCalcMode(SL_CALC_ATR), m_slAtrPeriod(0), m_slAtrMultiplier(0.0),
              m_trailingMode(TRAILING_ATR), m_trailingAtrPeriod(0), m_trailingAtrMultiplier(0.0), m_rrRatio(0.0), m_partialClosePercent(0.0),
              m_cleanupHours(0), m_color(clrNONE), m_trendFilterTimeframe(PERIOD_CURRENT), m_atrHandle(INVALID_HANDLE),
              m_slAtrHandle(INVALID_HANDLE), m_trailingAtrHandle(INVALID_HANDLE), m_currentState(RANGE_IDLE),
              m_rangeHigh(0), m_rangeLow(0), m_potentialBuyPrice(0), m_potentialSellPrice(0), m_breakerCandleLevel(0),
              m_activeTicket(0), m_cachedATR(0), m_cachedSlATR(0), m_cachedTrailingATR(0),
              m_waitCounter(0), m_cleanupTime(0), m_lastEndTime(0), m_lastInvalid(false), m_rangeEndTime(0), m_lastFilterBarTime(0),
              m_fixedOffsetValue(0.0), m_rangeObjectName(""), m_buyLineName(""), m_sellLineName(""), m_initialSlDistance(0.0), m_isCleanedForThisCycle(false),
              m_buyAttemptDisabled(false), m_sellAttemptDisabled(false), m_isBuyAttempt(false) {}  // سازنده پیش‌فرض با مقادیر اولیه (شامل متغیرهای جدید برای ابطال)

   // مقداردهی رنج: تنظیم پارامترها، ایجاد هندل‌های ATR و نام‌گذاری اشیاء
   // این تابع تمام پارامترها را از ورودی‌ها می‌گیرد
   bool Init(int index, long magic, ENUM_TIMEFRAMES timeframe, int startHour, int startMinute, int endHour, int endMinute,
             int minRangePoints, int maxRangePoints, ENUM_PLACEMENT_MODE placementMode, int atrPeriod, double atrMultiplier,
             ENUM_SL_STRATEGY slStrategy, ENUM_SL_CALC_MODE slCalcMode, int slAtrPeriod, double slAtrMultiplier,
             ENUM_TRAILING_MODE trailingMode, int trailingAtrPeriod, double trailingAtrMultiplier,
             double rrRatio, double partialClosePercent, int cleanupHours, color col, ENUM_TIMEFRAMES trendTf, int sharedAtrHandle);  // مقداردهی رنج
int GetTrailingAtrHandle() const { return m_trailingAtrHandle; }
   // دفع رنج: آزادسازی هندل‌های ATR
   // این تابع منابع را آزاد می‌کند
   void Deinit();  // دفع رنج

   // به‌روزرسانی در کندل جدید: اجرای ماشین حالت
   // این تابع بر اساس حالت فعلی عمل می‌کند
   void UpdateOnNewBar();  // به‌روزرسانی در کندل جدید

   // پاکسازی سخت: بستن معامله اگر باز باشد و سپس پاکسازی نرم (برای تعطیلات یا دفع)
   // این تابع برای پاکسازی کامل استفاده می‌شود
   void HardCleanup();  // پاکسازی سخت

   // چک پاکسازی: چک زمان انقضا و فراخوانی پاکسازی مناسب
   // این تابع در OnTick فراخوانی می‌شود
   void CheckCleanup();  // چک پاکسازی

   // ریست کش‌ها: صفر کردن کش ATRها برای رنج جدید
   // این تابع کش‌ها را ریست می‌کند
   void ResetCaches();  // ریست کش‌ها

   // گرفتن تایم‌فریم اجرا
   // این گتر تایم‌فریم را برمی‌گرداند
   ENUM_TIMEFRAMES GetTimeframe() const { return m_timeframe; }  // بازگشت تایم‌فریم اجرا

   // گرفتن تایم‌فریم فیلتر روند
   // این گتر فیلتر را برمی‌گرداند
   ENUM_TIMEFRAMES GetTrendFilterTimeframe() const { return m_trendFilterTimeframe; }  // بازگشت تایم‌فریم فیلتر

   // گرفتن حالت فعلی
   // این گتر حالت را برمی‌گرداند
   ENUM_RANGE_STATE GetCurrentState() const { return m_currentState; }  // بازگشت حالت فعلی

   // تنظیم حالت فعلی (برای استفاده داخلی یا بازیابی حافظه)
   // این ستر حالت را تنظیم می‌کند
   void SetCurrentState(ENUM_RANGE_STATE state) { m_currentState = state; }  // تنظیم حالت

   // گرفتن زمان آخرین کندل فیلتر
   // این گتر زمان فیلتر را برمی‌گرداند
   datetime GetLastFilterBarTime() const { return m_lastFilterBarTime; }  // بازگشت زمان فیلتر

   // به‌روزرسانی زمان آخرین کندل فیلتر
   // این ستر زمان را آپدیت می‌کند
   void UpdateLastFilterBarTime(datetime time) { m_lastFilterBarTime = time; }  // تنظیم زمان فیلتر

   // تنظیم تیکت فعال (برای بازیابی حافظه)
   // این ستر تیکت را تنظیم می‌کند
   void SetActiveTicket(ulong ticket) { m_activeTicket = ticket; }  // تنظیم تیکت

   // (جدید) بازیابی وضعیت: ذخیره سقف، کف و فاصله SL اولیه برای استفاده پس از ری‌استارت
   // این تابع وضعیت را از کامنت بازیابی می‌کند
   void RestoreState(double range_high, double range_low, double initial_sl_distance)  // بازیابی وضعیت
   {
      m_rangeHigh = range_high;  // ذخیره سقف
      m_rangeLow = range_low;  // ذخیره کف
      m_initialSlDistance = initial_sl_distance;  // ذخیره فاصله SL
      CLogger::Log("وضعیت رنج " + IntegerToString(m_rangeIndex) + " با موفقیت بازیابی شد.", m_rangeIndex);  // چاپ موفقیت
   }
};

// پیاده‌سازی توابع کلاس CRange (خارج از تعریف کلاس برای خوانایی)
// تمام توابع private/public در ادامه تعریف می‌شوند

// مقداردهی رنج: تنظیم پارامترها، ایجاد هندل‌های ATR و نام‌گذاری اشیاء
// این تابع تمام فیلدهای private را مقداردهی می‌کند
bool CRange::Init(int index, long magic, ENUM_TIMEFRAMES timeframe, int startHour, int startMinute, int endHour, int endMinute,
                  int minRangePoints, int maxRangePoints, ENUM_PLACEMENT_MODE placementMode, int atrPeriod, double atrMultiplier,
                  ENUM_SL_STRATEGY slStrategy, ENUM_SL_CALC_MODE slCalcMode, int slAtrPeriod, double slAtrMultiplier,
                  ENUM_TRAILING_MODE trailingMode, int trailingAtrPeriod, double trailingAtrMultiplier,
                  double rrRatio, double partialClosePercent, int cleanupHours, color col, ENUM_TIMEFRAMES trendTf, int sharedAtrHandle)  // پارامترهای ورودی
{
   // تنظیم ایندکس رنج برای لاگ و اشیاء
   m_rangeIndex = index;  // تنظیم ایندکس رنج
   // تنظیم مجیک برای تمایز معاملات
   m_magicNumber = magic;  // تنظیم مجیک
   // تنظیم تایم‌فریم اجرا
   m_timeframe = timeframe;  // تنظیم تایم‌فریم اجرا
   // تنظیم زمان شروع
   m_startHour = startHour;  // تنظیم ساعت شروع
   m_startMinute = startMinute;  // تنظیم دقیقه شروع
   // تنظیم زمان پایان
   m_endHour = endHour;  // تنظیم ساعت پایان
   m_endMinute = endMinute;  // تنظیم دقیقه پایان
   // تنظیم محدودیت‌های ارتفاع
   m_minRangePoints = minRangePoints;  // تنظیم حداقل ارتفاع
   m_maxRangePoints = maxRangePoints;  // تنظیم حداکثر ارتفاع
   // تنظیم حالت افست
   m_placementMode = placementMode;  // تنظیم حالت افست
   // تنظیم پارامترهای ATR افست
   m_atrPeriod = atrPeriod;  // تنظیم دوره ATR افست
   m_atrMultiplier = atrMultiplier;  // تنظیم ضریب ATR افست
   // تنظیم پارامترهای SL
   m_slStrategy = slStrategy;  // تنظیم استراتژی SL
   m_slCalcMode = slCalcMode;  // تنظیم حالت بافر SL
   m_slAtrPeriod = slAtrPeriod;  // تنظیم دوره ATR SL
   m_slAtrMultiplier = slAtrMultiplier;  // تنظیم ضریب ATR SL
   // تنظیم پارامترهای تریلینگ
   m_trailingMode = trailingMode;  // تنظیم حالت تریلینگ
   m_trailingAtrPeriod = trailingAtrPeriod;  // تنظیم دوره ATR تریلینگ
   m_trailingAtrMultiplier = trailingAtrMultiplier;  // تنظیم ضریب ATR تریلینگ
   // تنظیم پارامترهای مدیریت معامله
   m_rrRatio = rrRatio;  // تنظیم نسبت RR
   m_partialClosePercent = partialClosePercent;  // تنظیم درصد پله‌ای
   m_cleanupHours = cleanupHours;  // تنظیم ساعت‌های پاکسازی
   m_color = col;  // تنظیم رنگ
   m_trendFilterTimeframe = trendTf;  // تنظیم تایم‌فریم فیلتر
   m_atrHandle = sharedAtrHandle;  // هندل ATR افست (مشترک)

   // ایجاد هندل‌های جداگانه برای SL و تریلینگ (برای دوره‌های متفاوت)
   // iATR هندل اندیکاتور را ایجاد می‌کند
   m_slAtrHandle = iATR(_Symbol, timeframe, m_slAtrPeriod);  // هندل ATR برای SL
   if(m_slAtrHandle == INVALID_HANDLE)  // چک موفقیت ایجاد
   {
      CLogger::Log("خطا در ایجاد هندل ATR برای SL رنج " + IntegerToString(index), index);  // چاپ خطا
      return false;  // بازگشت شکست
   }
   m_trailingAtrHandle = iATR(_Symbol, timeframe, m_trailingAtrPeriod);  // هندل ATR برای تریلینگ
   if(m_trailingAtrHandle == INVALID_HANDLE)  // چک موفقیت
   {
      CLogger::Log("خطا در ایجاد هندل ATR برای تریلینگ رنج " + IntegerToString(index), index);  // چاپ خطا
      return false;  // بازگشت شکست
   }

   // نام‌گذاری اشیاء گرافیکی با ایندکس برای تمایز
   m_rangeObjectName = "Range_Rect_" + IntegerToString(index);  // نام مستطیل رنج
   m_buyLineName = "Range_BuyLine_" + IntegerToString(index);  // نام خط خرید
   m_sellLineName = "Range_SellLine_" + IntegerToString(index);  // نام خط فروش

   ResetCaches();  // ریست کش‌ها در شروع
   m_currentState = RANGE_IDLE;  // حالت اولیه انتظار
   m_lastFilterBarTime = 0;  // ریست زمان فیلتر
   m_isCleanedForThisCycle = false;  // ریست فلگ پاکسازی چرخه
   // (جدید) ریست متغیرهای ابطال جهت‌ها در Init
   m_buyAttemptDisabled = false;  // ریست فلگ غیرفعال خرید
   m_sellAttemptDisabled = false;  // ریست فلگ غیرفعال فروش
   m_isBuyAttempt = false;  // ریست جهت سیگنال
   // چاپ موفقیت با CLogger
   CLogger::Log("رنج " + IntegerToString(index) + " مقداردهی شد.", index);  // چاپ موفقیت
   return true;  // بازگشت موفقیت
}

// دفع رنج: آزادسازی هندل‌های ATR
// IndicatorRelease هندل‌ها را آزاد می‌کند
void CRange::Deinit()  // تابع دفع
{
   if(m_slAtrHandle != INVALID_HANDLE) IndicatorRelease(m_slAtrHandle);  // آزادسازی هندل SL
   if(m_trailingAtrHandle != INVALID_HANDLE) IndicatorRelease(m_trailingAtrHandle);  // آزادسازی هندل تریلینگ
   CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " دفع شد.", m_rangeIndex);  // چاپ دیباگ
}

// به‌روزرسانی در کندل جدید: اجرای ماشین حالت
// سوئیچ بر اساس حالت فعلی برای کنترل جریان
void CRange::UpdateOnNewBar()  // تابع به‌روزرسانی
{

     // ==================== راه حل قطعی اینجا قرار دارد ====================
   // قدم اول: قبل از هر کاری و فارغ از هر حالتی، زمان پاکسازی رو چک کن
   if (m_cleanupTime != 0 && TimeCurrent() >= m_cleanupTime && !m_isCleanedForThisCycle)
   {
       CLogger::Log("زمان پاکسازی فرا رسید (حالت فعلی: " + EnumToString(m_currentState) + "). اجرای پاکسازی نرم.", m_rangeIndex);
       
       // مستقیماً SoftCleanup رو اجرا میکنیم
       SoftCleanup();
       
       // حالت رو به IDLE تغییر میدیم تا برای روز بعد آماده بشه
       m_currentState = RANGE_IDLE;
       
       // با return از تابع خارج میشیم تا هیچ منطق دیگه‌ای در این کندل اجرا نشه
       return;
   }
   // =================================================================

   // لاگ ورود به تابع برای ردیابی
   CLogger::Log("------ در حالت " + EnumToString(m_currentState) + " ------", m_rangeIndex);  // عنوان حالت

   // سوئیچ بر اساس حالت فعلی برای اجرای تابع مربوطه
   switch(m_currentState)  // سوئیچ بر اساس حالت فعلی
   {
      case RANGE_IDLE:  // حالت بیکار
     {
        // چک اگر زمان وارد محدوده رنج شده باشد
         datetime currentTime = TimeCurrent();  // زمان فعلی
         datetime startTime, endTime;  // زمان شروع و پایان
         if(CTimeHelper::CalculateRangeTimes(m_startHour, m_startMinute, m_endHour, m_endMinute, startTime, endTime))  // محاسبه زمان‌ها
         {
            if(currentTime >= startTime && currentTime < endTime)  // چک داخل محدوده
            {
               CLogger::Log("زمان رنج فرا رسید. انتقال به RANGE_IDENTIFYING.", m_rangeIndex);  // لاگ انتقال
               m_currentState = RANGE_IDENTIFYING;  // تغییر به شناسایی
            }
         }
         break;  // خروج از کیس
     }  
      case RANGE_IDENTIFYING:  // در حال شناسایی
         IdentifyAndValidateRange();  // شناسایی رنج
         break;  // خروج
      case RANGE_ARMED:  // مسلح و انتظار
         WaitForBreakerCandle();  // انتظار بریک
         break;  // خروج
      case AWAITING_CONFIRMATION:  // انتظار تایید
         ProcessEntryAttempt();  // فرآیند ورود
         break;  // خروج
      case RANGE_TRADE_ACTIVE:  // معامله فعال
         // هیچ عملی، منتظر پاکسازی
         CLogger::Log("معامله فعال است. منتظر پاکسازی.", m_rangeIndex);  // لاگ وضعیت
         break;  // خروج
      case RANGE_EXPIRED:  // منقضی
         SoftCleanup();  // پاکسازی نرم
         m_currentState = RANGE_IDLE;  // بازگشت به بیکار
         break;  // خروج
   }

  // CheckCleanup();  // چک پاکسازی در هر کندل جدید
}

// شناسایی و ولید رنج: محاسبه سقف/کف، چک ارتفاع، محاسبه ثابت افست و رسم مستطیل اگر معتبر باشد
// این تابع رنج را بر اساس زمان و داده‌های کندل محاسبه و ولید می‌کند
void CRange::IdentifyAndValidateRange()  // تابع شناسایی
{
   CLogger::Log("شناسایی رنج " + IntegerToString(m_rangeIndex) + "...", m_rangeIndex);  // چاپ دیباگ برای شناسایی

   datetime startTime, endTime;  // متغیرهای زمان شروع و پایان
   // محاسبه زمان‌ها با CTimeHelper
   if(!CTimeHelper::CalculateRangeTimes(m_startHour, m_startMinute, m_endHour, m_endMinute, startTime, endTime))  // محاسبه زمان‌ها
   {
      CLogger::Log("خطا در محاسبه زمان رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);  // چاپ خطا
      m_currentState = RANGE_EXPIRED;  // تنظیم به منقضی
      return;  // خروج
   }

   // چک برای جلوگیری از پردازش تکراری رنج در یک روز (با چک نامعتبر بودن آخرین)
   // این شرط از محاسبات مکرر جلوگیری می‌کند
   if(endTime == m_lastEndTime && !m_lastInvalid) return;  // اگر همان پایان قبلی و معتبر، پرش
   if(endTime == m_lastEndTime && m_lastInvalid) return;  // اگر همان و نامعتبر، پرش
   if(TimeCurrent() < endTime) return;  // اگر هنوز پایان نرسیده، پرش

   m_rangeEndTime = endTime;  // ذخیره زمان پایان کامل برای پاکسازی دقیق

   // iBarShift شیفت کندل را بر اساس زمان برمی‌گرداند
   int startShift = iBarShift(_Symbol, m_timeframe, startTime);  // شیفت شروع
   int endShift = iBarShift(_Symbol, m_timeframe, endTime);  // شیفت پایان

   if(startShift < 0 || endShift < 0)  // چک شیفت معتبر (برای Edge Case بدون کندل)
   {
      CLogger::Log("خطا: کندلی در بازه زمانی مشخص شده برای رنج " + IntegerToString(m_rangeIndex) + " یافت نشد.", m_rangeIndex);  // چاپ خطا
      m_lastInvalid = true;  // تنظیم فلگ نامعتبر
      m_lastEndTime = endTime;  // ذخیره پایان
      m_currentState = RANGE_EXPIRED;  // تنظیم به منقضی
      return;  // خروج
   }

   int bars = startShift - endShift + 1;  // تعداد بارها در رنج
   if(bars <= 0)  // چک تعداد معتبر
   {
      CLogger::Log("خطا: تعداد بارها نامعتبر برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);  // چاپ خطا
      m_lastInvalid = true;  // تنظیم فلگ
      m_lastEndTime = endTime;  // ذخیره پایان
      m_currentState = RANGE_EXPIRED;  // تنظیم به منقضی
      return;  // خروج
   }

   // محاسبه سقف و کف رنج با iHighest/iLowest
   int highestIdx = iHighest(_Symbol, m_timeframe, MODE_HIGH, bars, endShift);  // ایندکس سقف
   int lowestIdx = iLowest(_Symbol, m_timeframe, MODE_LOW, bars, endShift);  // ایندکس کف
   m_rangeHigh = iHigh(_Symbol, m_timeframe, highestIdx);  // سقف رنج
   m_rangeLow = iLow(_Symbol, m_timeframe, lowestIdx);  // کف رنج

   double rangeHeight = (m_rangeHigh - m_rangeLow) / _Point;  // ارتفاع به پوینت
   CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + ": سقف=" + DoubleToString(m_rangeHigh, _Digits) + ", کف=" + DoubleToString(m_rangeLow, _Digits) + ", ارتفاع=" + DoubleToString(rangeHeight, 0) + " پوینت", m_rangeIndex);  // چاپ دیباگ

   // چک کیفیت رنج (ارتفاع در محدوده مجاز)
   if(rangeHeight < m_minRangePoints || rangeHeight > m_maxRangePoints)  // شرط چک ارتفاع
   {
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " بی‌کیفیت است. ارتفاع خارج از محدوده مجاز.", m_rangeIndex);  // چاپ خطا
      m_lastInvalid = true;  // تنظیم فلگ
      m_lastEndTime = endTime;  // ذخیره پایان
      m_currentState = RANGE_EXPIRED;  // تنظیم به منقضی
      return;  // خروج
   }

   // --- START: Calculate and Fix Offset Value --- (محاسبه ثابت افست در لحظه شناسایی برای جلوگیری از جابجایی)
   // این بخش افست را ثابت می‌کند
   if(m_placementMode == PLACEMENT_ATR)  // حالت ATR
   {
      double atr_buffer[];  // بافر ATR (دینامیک بدون اندازه ثابت)
      ArraySetAsSeries(atr_buffer, true);  // تنظیم سری آرایه
      if(CopyBuffer(m_atrHandle, 0, 1, 1, atr_buffer) > 0)  // کپی ATR فعلی (shift 1 برای کندل بسته)
      {
         m_fixedOffsetValue = atr_buffer[0] * m_atrMultiplier;  // محاسبه و ذخیره ثابت
      }
      else  // شرط شکست کپی
      {
         CLogger::Log("خطا در گرفتن ATR برای تثبیت افست رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);  // چاپ خطا
         m_currentState = RANGE_EXPIRED;  // تنظیم به منقضی
         return;  // خروج
      }
   }
   else  // حالت درصد
   {
      m_fixedOffsetValue = (m_rangeHigh - m_rangeLow) * m_atrMultiplier / 100.0;  // محاسبه ثابت درصد
   }
   // --- END: Calculate and Fix Offset Value ---

   // رسم مستطیل رنج اگر معتبر باشد با ObjectCreate
   if(!ObjectCreate(0, m_rangeObjectName, OBJ_RECTANGLE, 0, startTime, m_rangeHigh, endTime, m_rangeLow))  // رسم مستطیل
   {
      CLogger::Log("خطا در رسم مستطیل رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(GetLastError()), m_rangeIndex);  // چاپ خطا
   }
   else  // شرط موفقیت رسم
   {
      ObjectSetInteger(0, m_rangeObjectName, OBJPROP_COLOR, m_color);  // تنظیم رنگ
      ObjectSetInteger(0, m_rangeObjectName, OBJPROP_STYLE, STYLE_SOLID);  // تنظیم استایل
      ObjectSetInteger(0, m_rangeObjectName, OBJPROP_WIDTH, 1);  // تنظیم عرض
      ObjectSetInteger(0, m_rangeObjectName, OBJPROP_FILL, true);  // توپر کردن مستطیل (شیشه‌ای)
      ObjectSetInteger(0, m_rangeObjectName, OBJPROP_BACK, true);  // پس‌زمینه برای شفافیت
   }
   
   // ++++++++++++++++ START: کد اضافه شده از ArmAndWait ++++++++++++++++
   CLogger::Log("مسلح کردن رنج " + IntegerToString(m_rangeIndex) + "...", m_rangeIndex);

   // استفاده از افست ثابت محاسبه‌شده در شناسایی (برای جلوگیری از جابجایی خطوط)
   m_potentialBuyPrice = NormalizePrice(m_rangeHigh + m_fixedOffsetValue);
   m_potentialSellPrice = NormalizePrice(m_rangeLow - m_fixedOffsetValue);

   datetime currentTime = TimeCurrent();
   // رسم خط خرید
   if(!ObjectCreate(0, m_buyLineName, OBJ_HLINE, 0, currentTime, m_potentialBuyPrice))
   {
      CLogger::Log("خطا در رسم خط BUY برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);
   }
   else
   {
      ObjectSetInteger(0, m_buyLineName, OBJPROP_COLOR, clrGreen);
      ObjectSetInteger(0, m_buyLineName, OBJPROP_STYLE, STYLE_DASH);
   }
   // رسم خط فروش
   if(!ObjectCreate(0, m_sellLineName, OBJ_HLINE, 0, currentTime, m_potentialSellPrice))
   {
      CLogger::Log("خطا در رسم خط SELL برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);
   }
   else
   {
      ObjectSetInteger(0, m_sellLineName, OBJPROP_COLOR, clrRed);
      ObjectSetInteger(0, m_sellLineName, OBJPROP_STYLE, STYLE_DASH);
   }

   // محاسبه زمان پاکسازی
   m_cleanupTime = CTimeHelper::CalculateCleanupTime(m_rangeEndTime, m_cleanupHours);
   CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " مسلح شد. Potential Buy: " + DoubleToString(m_potentialBuyPrice, _Digits) + ", Sell: " + DoubleToString(m_potentialSellPrice, _Digits), m_rangeIndex);
   // ++++++++++++++++ END: کد اضافه شده از ArmAndWait ++++++++++++++++

   m_lastInvalid = false;  // ریست فلگ نامعتبر
   m_lastEndTime = endTime;  // ذخیره پایان
   m_currentState = RANGE_ARMED;  // تغییر حالت به مسلح
   CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " معتبر است. تغییر حالت به ARMED.", m_rangeIndex);  // چاپ دیباگ
}

// انتظار برای کندل بریک: چک کلوز بالای/پایین افست برای شروع تایید ورود (اصلاح شده برای چک disabled و ذخیره جهت)
// این تابع همیشه برای هر دو جهت آماده است و شکست معتبر را تشخیص می‌دهد
void CRange::WaitForBreakerCandle()  // تابع انتظار بریک (اصلاح شده)
{
   // iClose کلوز کندل قبلی (shift 1) را برمی‌گرداند
   double close1 = iClose(_Symbol, m_timeframe, 1);  // کلوز کندل قبلی
   if(close1 == 0)  // چک مقدار معتبر
   {
      CLogger::Log("خطا: iClose مقدار نامعتبر برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);  // چاپ خطا
      return;  // خروج
   }

   // چک شکست خرید: فقط اگر disabled نباشد
   if(!m_buyAttemptDisabled && close1 > m_potentialBuyPrice)  // چک شکست خرید با فلگ disabled
   {
      m_breakerCandleLevel = iHigh(_Symbol, m_timeframe, 1);  // سطح های کندل شکست
      m_isBuyAttempt = true;  // ذخیره جهت سیگنال (خرید)
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " - BUY Breaker Candle detected! Level: " + DoubleToString(m_breakerCandleLevel, _Digits), m_rangeIndex);  // چاپ دیباگ
      m_waitCounter = 0;  // ریست شمارنده برای حالت قدیمی
      m_currentState = AWAITING_CONFIRMATION;  // تغییر حالت به انتظار ورود
      return;  // خروج پس از تشخیص (فقط یک جهت در هر کندل)
   }
   // چک شکست فروش: فقط اگر disabled نباشد
   else if(!m_sellAttemptDisabled && close1 < m_potentialSellPrice)  // چک شکست فروش با فلگ disabled
   {
      m_breakerCandleLevel = iLow(_Symbol, m_timeframe, 1);  // سطح لو کندل شکست
      m_isBuyAttempt = false;  // ذخیره جهت سیگنال (فروش)
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " - SELL Breaker Candle detected! Level: " + DoubleToString(m_breakerCandleLevel, _Digits), m_rangeIndex);  // چاپ دیباگ
      m_waitCounter = 0;  // ریست شمارنده برای حالت قدیمی
      m_currentState = AWAITING_CONFIRMATION;  // تغییر حالت به انتظار ورود
      return;  // خروج پس از تشخیص
   }
   // اگر هیچ شکستی نبود، منتظر بمان (حالت ARMED حفظ می‌شود)
}

// فرآیند تلاش ورود: چک ابطال، تایید قیمت و فیلتر روند، اجرای معامله اگر تایید شد (نسخه کاملاً صحیح)
void CRange::ProcessEntryAttempt()
{
   // قدم اول: تشخیص جهت معتبر از متغیر ذخیره‌شده
   bool isBuyAttempt = m_isBuyAttempt;
   double close1 = iClose(_Symbol, m_timeframe, 1);

   // قدم دوم: اجرای استراتژی تایید/ابطال با switch
   switch(Inp_Confirmation_Strategy)
   {
      case CONFIRMATION_TIMEOUT:
         m_waitCounter++;
         if(m_waitCounter > Inp_Confirmation_Timeout)
         {
            if(isBuyAttempt) m_buyAttemptDisabled = true;
            else m_sellAttemptDisabled = true;
            CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + ": مهلت تایید تمام شد. ابطال دائمی جهت " + (isBuyAttempt ? "خرید" : "فروش") + ".", m_rangeIndex);
            ResetToArmedState();
            return;
         }
         break;

      // ================== شروع اصلاحیه آکولاد ==================
      case CONFIRMATION_PRICE_INVALIDATION:
      { // آکولاد باز برای شروع محدوده case
         bool isInvalid = false;
         if(Inp_Invalidation_Mode == INVALIDATION_RANGE_REENTRY)
         {
            if(isBuyAttempt && close1 < m_rangeHigh) isInvalid = true;
            if(!isBuyAttempt && close1 > m_rangeLow) isInvalid = true;
         }
         else
         {
            if(isBuyAttempt && close1 < m_potentialBuyPrice) isInvalid = true;
            if(!isBuyAttempt && close1 > m_potentialSellPrice) isInvalid = true;
         }

         if(isInvalid)
         {
            CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + ": شرط ابطال قیمتی رخ داد. ریست موقت.", m_rangeIndex);
            ResetToArmedState();
            return;
         }
         break;
      } // آکولاد بسته برای پایان محدوده case
      // ================== پایان اصلاحیه آکولاد ===================
   }

   // قدم سوم: تایید قیمت اختیاری (این بخش باید خارج از switch باشه)
   if(Inp_PriceConfirmation_Enabled)
   {
      bool priceConfirmed = (isBuyAttempt ? (close1 > m_breakerCandleLevel) : (close1 < m_breakerCandleLevel));
      if(!priceConfirmed)
      {
         CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + ": تایید قیمت برقرار نیست. صبر برای کندل بعدی.", m_rangeIndex);
         return;
      }
   }

   // قدم چهارم: اجرای فیلتر روند (این بخش هم باید خارج از switch باشه)
   ENUM_TREND_DIRECTION currentTrend = g_trendFilter.GetTrendDirection(m_trendFilterTimeframe);
   bool filterConfirmed = false;
   if(!Inp_IchimokuFilter_Enabled)
   {
      filterConfirmed = true;
   }
   else
   {
      if(isBuyAttempt && currentTrend == TREND_BUY) filterConfirmed = true;
      else if(!isBuyAttempt && currentTrend == TREND_SELL) filterConfirmed = true;
      else if(currentTrend == TREND_NEUTRAL)
      {
         CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + ": روند خنثی. صبر برای جهت مشخص.", m_rangeIndex);
         return;
      }
   }

   // اجرای معامله اگر فیلتر تایید شد
   if(filterConfirmed)
   {
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + ": تمام تاییدها برقرار. اجرای معامله.", m_rangeIndex);
      ExecuteTrade(isBuyAttempt);
   }
}
//------------------------------------------------------------------------

// ریست به حالت مسلح: ریست سطح بریک بدون حذف خطوط گرافیکی یا مسیرها (برای حفظ فرصت‌ها)
// این تابع برای ابطال موقت یا timeout استفاده می‌شود (ریست m_isBuyAttempt برای جهت جدید)
void CRange::ResetToArmedState()  // تابع ریست (اصلاح شده)
{
   CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + ": ریست به حالت مسلح (حفظ خطوط).", m_rangeIndex);  // چاپ دیباگ برای ریست
   m_breakerCandleLevel = 0;  // پاک کردن سطح کندل شکننده
   m_waitCounter = 0;  // ریست شمارنده برای حالت بعدی
   m_isBuyAttempt = false;  // ریست جهت سیگنال برای تشخیص جدید
   m_currentState = RANGE_ARMED;  // ریست حالت به مسلح و انتظار
   // نکته کلیدی: هیچ خط گرافیکی یا مسیری اینجا حذف نمی‌شود تا فرصت دوباره شکل گیرد
}

// اجرای معامله: محاسبه SL بر اساس SL strategy جدید (base point + بافر)، حجم و ارسال سفارش بازار
// این تابع معامله را باز می‌کند
void CRange::ExecuteTrade(bool isBuy)  // تابع اجرای معامله
{
   // قیمت ورود فعلی (ASK برای خرید، BID برای فروش)
   double entryPrice = isBuy ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);  // قیمت ورود فعلی (ASK برای خرید، BID برای فروش)
   double adjustment;  // بافر SL

   // چک حالت ATR برای بافر SL
   if(m_slCalcMode == SL_CALC_ATR)  // چک حالت ATR برای بافر SL
   {
      double atr_buffer[];  // آرایه ATR (دینامیک بدون اندازه ثابت)
      ArraySetAsSeries(atr_buffer, true);  // تنظیم سری آرایه
      if(CopyBuffer(m_slAtrHandle, 0, 1, 1, atr_buffer) <= 0)  // کپی بافر (shift 1)
      {
         CLogger::Log("خطا در گرفتن ATR برای SL رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(GetLastError()), m_rangeIndex);  // چاپ خطا
         return;  // خروج
      }
      adjustment = atr_buffer[0] * m_slAtrMultiplier;  // محاسبه بافر ATR
   }
   else  // حالت درصد
   {
      adjustment = (m_rangeHigh - m_rangeLow) * m_slAtrMultiplier / 100.0;  // محاسبه بافر درصد
   }

   // انتخاب base point بر اساس SL strategy
   double basePoint;  // پایه SL
   if(m_slStrategy == SL_OPPOSITE_SIDE)  // حالت مقابل رنج
   {
      basePoint = isBuy ? m_rangeLow : m_rangeHigh;  // مقابل رنج برای BUY/SELL
   }
   else  // SL_BREAKOUT_LEVEL - سطح شکست
   {
      basePoint = isBuy ? m_rangeHigh : m_rangeLow;  // سطح شکست برای BUY/SELL
   }

   // محاسبه SL بر اساس base point با NormalizePrice
   double slPrice = isBuy ? NormalizePrice(basePoint - adjustment) : NormalizePrice(basePoint + adjustment);  // قیمت SL نرمالایز شده
   double slDistance = MathAbs(entryPrice - slPrice);  // فاصله SL از ورود
   m_initialSlDistance = slDistance;  // ذخیره فاصله SL اولیه برای بازیابی

   // سطح حداقل فاصله از SYMBOL_TRADE_STOPS_LEVEL
   long stops_level = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);  // سطح حداقل فاصله
   double minStop = stops_level * _Point + _Point;  // حداقل فاصله با بافر
   if(slDistance <= 0 || slDistance < minStop)  // چک فاصله معتبر
   {
      CLogger::Log("خطا: slDistance نامعتبر یا کمتر از حداقل فاصله مجاز برای رنج " + IntegerToString(m_rangeIndex) + " (slDistance=" + DoubleToString(slDistance, _Digits) + ")", m_rangeIndex);  // چاپ خطا
      m_currentState = RANGE_EXPIRED;  // تنظیم به منقضی
      return;  // خروج
   }

   CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + ": SL Strategy=" + EnumToString(m_slStrategy) + ", slDistance=" + DoubleToString(slDistance, _Digits) + ", slPrice=" + DoubleToString(slPrice, _Digits), m_rangeIndex);  // چاپ دیباگ SL

   // محاسبه حجم با CRiskManager
   double lotSize = CRiskManager::CalculateLotSize(InpRiskPercent, slDistance);  // محاسبه حجم بر اساس ریسک
   if(lotSize == 0)  // چک حجم معتبر
   {
      CLogger::Log("خطا در محاسبه حجم برای رنج " + IntegerToString(m_rangeIndex), m_rangeIndex);  // چاپ خطا
      m_currentState = RANGE_EXPIRED;  // تنظیم به منقضی
      return;  // خروج
   }

   CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + ": lotSize=" + DoubleToString(lotSize, 2), m_rangeIndex);  // چاپ دیباگ حجم

   // --- START: Margin Pre-validation --- (چک پیش-اعتبارسنجی مارجین برای جلوگیری از معامله بدون مارجین کافی)
   double margin_required;  // متغیر برای مارجین مورد نیاز
   // OrderCalcMargin مارجین را محاسبه می‌کند
   if(!OrderCalcMargin(isBuy ? ORDER_TYPE_BUY : ORDER_TYPE_SELL, _Symbol, lotSize, entryPrice, margin_required))  // محاسبه مارجین
   {
      CLogger::Log("خطا در محاسبه مارجین برای رنج " + IntegerToString(m_rangeIndex) + ". معامله لغو شد.", m_rangeIndex);  // چاپ خطا
      m_currentState = RANGE_EXPIRED;  // تنظیم به منقضی
      return;  // خروج
   }
   // AccountInfoDouble مارجین آزاد را برمی‌گرداند
   if(margin_required > AccountInfoDouble(ACCOUNT_MARGIN_FREE))  // چک مارجین کافی
   {
      CLogger::Log("مارجین کافی نیست. نیاز: " + DoubleToString(margin_required, 2) + ", موجود: " + DoubleToString(AccountInfoDouble(ACCOUNT_MARGIN_FREE), 2), m_rangeIndex);  // چاپ خطا
      m_currentState = RANGE_EXPIRED;  // تنظیم به منقضی
      return;  // خروج
   }
   // --- END: Margin Pre-validation ---

   // نمونه CTrade برای ارسال سفارش
   CTrade trade;  // نمونه کلاس معامله
   MqlTradeRequest request;  // درخواست معامله
   MqlTradeResult result;  // نتیجه معامله
   ZeroMemory(request);  // صفر کردن درخواست
   request.action = TRADE_ACTION_DEAL;  // عمل معامله بازار
   request.symbol = _Symbol;  // نماد
   request.volume = lotSize;  // حجم
   request.type = isBuy ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;  // نوع سفارش
   request.price = entryPrice;  // استفاده از قیمت لحظه‌ای برای سفارش بازار
   request.sl = slPrice;  // SL
   request.tp = 0.0;  // TP به 0.0 برای حذف حد سود اولیه (اجازه روند ادامه)
   request.magic = m_magicNumber;  // مجیک
   request.comment = StringFormat("R%d;H:%.5f;L:%.5f;SLD:%.5f", m_rangeIndex, m_rangeHigh, m_rangeLow, m_initialSlDistance);  // کامنت با اطلاعات حیاتی
   request.deviation = 10;  // انحراف مجاز
   // OrderSend درخواست را ارسال می‌کند
   if(!trade.OrderSend(request, result) || result.deal == 0)  // ارسال سفارش
   {
      CLogger::Log("خطا در باز کردن معامله برای رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(result.retcode), m_rangeIndex);  // چاپ خطا
      m_currentState = RANGE_EXPIRED;  // تنظیم به منقضی
      return;  // خروج
   }
   m_activeTicket = result.deal;  // ذخیره تیکت

   CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " - " + (isBuy ? "BUY" : "SELL") + " Trade Opened! Ticket: " + (string)m_activeTicket, m_rangeIndex);  // چاپ موفقیت

   // ثبت معامله در مدیر معاملات برای مدیریت آینده
   g_tradeManager.RegisterTrade(m_activeTicket, m_magicNumber, m_rangeIndex, m_initialSlDistance, entryPrice, m_rrRatio, m_partialClosePercent, m_trailingMode, m_trailingAtrPeriod, m_trailingAtrMultiplier, m_timeframe, m_trailingAtrHandle, m_trendFilterTimeframe);  // ثبت معامله

   DisableOppositePath(isBuy);  // غیرفعال کردن مسیر مخالف برای OCO
   m_currentState = RANGE_TRADE_ACTIVE;  // تغییر حالت به معامله فعال
}

// غیرفعال کردن مسیر مخالف: حذف خط و ریست قیمت بالقوه برای جلوگیری از سیگنال دوگانه
// این تابع OCO را شبیه‌سازی می‌کند
void CRange::DisableOppositePath(bool isBuy)  // تابع غیرفعال کردن
{
   if(isBuy)  // برای خرید
   {
      m_potentialSellPrice = 0;  // ریست قیمت فروش
      ObjectDelete(0, m_sellLineName);  // حذف خط فروش
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " - SELL path deactivated (OCO).", m_rangeIndex);  // چاپ دیباگ
   }
   else  // برای فروش
   {
      m_potentialBuyPrice = 0;  // ریست قیمت خرید
      ObjectDelete(0, m_buyLineName);  // حذف خط خرید
      CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " - BUY path deactivated (OCO).", m_rangeIndex);  // چاپ دیباگ
   }
}

// پاکسازی نرم: ریست متغیرها و حذف اشیاء بدون بستن معامله برای آماده‌سازی رنج بعدی
// این تابع برای ریست روزانه بدون بستن معامله است (اصلاح شده برای ریست متغیرهای جدید)
void CRange::SoftCleanup()  // تابع پاکسازی نرم (اصلاح شده)
{
   CLogger::Log("پاکسازی نرم رنج " + IntegerToString(m_rangeIndex) + "...", m_rangeIndex);  // چاپ دیباگ برای پاکسازی نرم

   // ۱. پاکسازی متغیرهای مربوط به تلاش برای ورود
   m_potentialBuyPrice = 0;  // ریست قیمت خرید
   m_potentialSellPrice = 0;  // ریست قیمت فروش
   m_breakerCandleLevel = 0;  // ریست سطح بریک
   m_waitCounter = 0;  // ریست شمارنده

   // ۲. حذف تمام اشیاء گرافیکی مربوط به رنج
   ObjectDelete(0, m_buyLineName);  // حذف خط خرید
   ObjectDelete(0, m_sellLineName);  // حذف خط فروش
   ObjectDelete(0, m_rangeObjectName);  // حذف مستطیل رنج

   // ۳. ریست کردن متغیرهای کنترلی برای شناسایی رنج بعدی
   m_lastEndTime = 0;  // << بسیار مهم: این خط باگ اصلی قفل شدن را حل می‌کند
   m_lastInvalid = false;  // ریست فلگ نامعتبر

   // ۴. ریست کردن کش‌ها
   ResetCaches();  // ریست کش‌ها

   // ریست متغیر معامله
   m_activeTicket = 0;  // ریست تیکت
   
   // (جدید) ریست متغیرهای ابطال جهت‌ها در پاکسازی نرم (برای رنج جدید)
   m_buyAttemptDisabled = false;  // ریست فلگ غیرفعال خرید
   m_sellAttemptDisabled = false;  // ریست فلگ غیرفعال فروش
   m_isBuyAttempt = false;  // ریست جهت سیگنال

   // ۵. اضافه کردن علامت پاکسازی روی کندل فعلی (کد 217 برای OBJ_ARROW)
   string cleanupMarkerName = "Cleanup_Marker_" + IntegerToString(m_rangeIndex);  // نام علامت پاکسازی
   datetime currentTime = TimeCurrent();  // زمان فعلی برای علامت
   double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);  // قیمت فعلی برای علامت
   if(!ObjectCreate(0, cleanupMarkerName, OBJ_ARROW, 0, currentTime, currentPrice))  // رسم علامت
   {
      CLogger::Log("خطا در رسم علامت پاکسازی برای رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(GetLastError()), m_rangeIndex);  // چاپ خطا
   }
   else  // شرط موفقیت
   {
      ObjectSetInteger(0, cleanupMarkerName, OBJPROP_ARROWCODE, 217);  // کد علامت (217)
      ObjectSetInteger(0, cleanupMarkerName, OBJPROP_COLOR, clrYellow);  // رنگ زرد برای تمایز
   }

   // 6. تنظیم فلگ پاکسازی چرخه
   m_isCleanedForThisCycle = true;  // فلگ پاکسازی انجام شده
   m_cleanupTime = 0;  // ساعت پاکسازی را صفر کن تا این فرآیند تکرار نشود
   CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " پاکسازی نرم شد.", m_rangeIndex);  // چاپ موفقیت
}

// پاکسازی سخت: بستن معامله اگر باز باشد و سپس پاکسازی نرم (برای تعطیلات یا دفع)
// تغییرات 2.10: ریست دستی فلگ‌ها قبل از SoftCleanup
void CRange::HardCleanup()  // تابع پاکسازی سخت
{
   CLogger::Log("پاکسازی سخت رنج " + IntegerToString(m_rangeIndex) + "...", m_rangeIndex);  // چاپ دیباگ برای پاکسازی سخت

   if(m_activeTicket != 0)  // چک معامله باز
   {
      if(g_tradeManager.ClosePosition(m_activeTicket))  // بستن کامل معامله از مدیر معاملات
      {
         CLogger::Log("معامله با تیکت " + (string)m_activeTicket + " بسته شد (سخت).", m_rangeIndex);  // چاپ دیباگ
      }
      // ریست کردن متغیرهای مربوط به معامله باز قبل از SoftCleanup
      m_activeTicket = 0;  // ریست تیکت پس از بستن
   }

   SoftCleanup();  // فراخوانی پاکسازی نرم پس از بستن و ریست متغیرها
   CLogger::Log("رنج " + IntegerToString(m_rangeIndex) + " پاکسازی سخت شد.", m_rangeIndex);  // چاپ موفقیت
}

// چک پاکسازی: چک زمان انقضا و فراخوانی پاکسازی مناسب بر اساس حالت (با معامله: فقط مسیرها، بدون: نرم)
// این تابع در OnTick فراخوانی می‌شود
void CRange::CheckCleanup()  // تابع چک پاکسازی
{
   // اگر زمان پاکسازی نرسیده یا قبلاً انجام شده، خارج شو
   if(m_cleanupTime == 0 || TimeCurrent() < m_cleanupTime || m_isCleanedForThisCycle) return;  // چک زمان و فلگ

   CLogger::Log("زمان پاکسازی فرا رسید...", m_rangeIndex);  // چاپ دیباگ
   m_currentState = RANGE_EXPIRED;  // تغییر به منقضی برای اجرای پاکسازی
}

// ریست کش‌ها: صفر کردن کش ATRها برای رنج جدید (برای جلوگیری از استفاده از داده‌های کهنه)
// این تابع کش‌ها را صفر می‌کند
void CRange::ResetCaches()  // تابع ریست کش
{
   m_cachedATR = 0;  // ریست کش ATR افست
   m_cachedSlATR = 0;  // ریست کش ATR SL
   m_cachedTrailingATR = 0;  // ریست کش ATR تریلینگ
   CLogger::Log("کش‌های ATR برای رنج " + IntegerToString(m_rangeIndex) + " ریست شدند.", m_rangeIndex);  // چاپ دیباگ
}

// گرفتن ATR کش‌شده اصلی: اگر کش خالی باشد، از هندل کپی می‌گیرد (فقط برای ورود استفاده شود)
// CopyBuffer بافر را کپی می‌کند
double CRange::GetCachedATR()  // تابع گرفتن ATR
{
   if(m_cachedATR <= 0)  // چک کش خالی
   {
      double atr[];  // آرایه ATR (دینامیک بدون اندازه ثابت)
      ArraySetAsSeries(atr, true);  // تنظیم سری
      if(CopyBuffer(m_atrHandle, 0, 1, 1, atr) <= 0)  // کپی بافر
      {
         CLogger::Log("خطا در گرفتن ATR برای رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(GetLastError()), m_rangeIndex);  // چاپ خطا
         return 0;  // بازگشت صفر
      }
      m_cachedATR = atr[0];  // ذخیره در کش
   }
   return m_cachedATR;  // بازگشت کش
}

// گرفتن ATR کش‌شده برای SL: مشابه برای بهینه‌سازی محاسبات SL (فقط برای ورود استفاده شود)
double CRange::GetSlATR()  // تابع گرفتن SL ATR
{
   if(m_cachedSlATR <= 0)  // چک کش خالی
   {
      double atr[];  // آرایه ATR (دینامیک بدون اندازه ثابت)
      ArraySetAsSeries(atr, true);  // تنظیم سری
      if(CopyBuffer(m_slAtrHandle, 0, 1, 1, atr) <= 0)  // کپی بافر
      {
         CLogger::Log("خطا در گرفتن ATR برای SL رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(GetLastError()), m_rangeIndex);  // چاپ خطا
         return 0;  // بازگشت صفر
      }
      m_cachedSlATR = atr[0];  // ذخیره در کش
   }
   return m_cachedSlATR;  // بازگشت کش
}

// گرفتن ATR کش‌شده برای تریلینگ: مشابه برای بهینه‌سازی تریلینگ (فقط برای ورود استفاده شود، برای مدیریت پویا استفاده نشود)
double CRange::GetTrailingATR()  // تابع گرفتن تریلینگ ATR
{
   if(m_cachedTrailingATR <= 0)  // چک کش خالی
   {
      double atr[];  // آرایه ATR (دینامیک بدون اندازه ثابت)
      ArraySetAsSeries(atr, true);  // تنظیم سری
      if(CopyBuffer(m_trailingAtrHandle, 0, 1, 1, atr) <= 0)  // کپی بافر
      {
         CLogger::Log("خطا در گرفتن ATR برای تریلینگ رنج " + IntegerToString(m_rangeIndex) + ": " + IntegerToString(GetLastError()), m_rangeIndex);  // چاپ خطا
         return 0;  // بازگشت صفر
      }
      m_cachedTrailingATR = atr[0];  // ذخیره در کش
   }
   return m_cachedTrailingATR;  // بازگشت کش
}

#endif // پایان چک include
